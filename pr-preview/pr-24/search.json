[
  {
    "objectID": "download/components/md_url_checker/bash/Testfile.html",
    "href": "download/components/md_url_checker/bash/Testfile.html",
    "title": "Viash",
    "section": "",
    "text": "Test File\nThis is a simple markdown file with some hyperlinks to test if the component works correctly. Some links to websites:\n\nGoogle\nReddit\nA broken link\n\nLinks that are relative to viash.io:\n\nYou can install viash here.\nIt all starts with a script and a config file."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Viash",
    "section": "",
    "text": "Viash is developed and maintained by Data Intuitive.\nYou can find out more information about Viash in our preprint.\nFor more information or support contact us at info@data-intuitive.com."
  },
  {
    "objectID": "about.html#logos",
    "href": "about.html#logos",
    "title": "About Viash",
    "section": "Logos",
    "text": "Logos"
  },
  {
    "objectID": "privacy.html",
    "href": "privacy.html",
    "title": "Privacy Policy",
    "section": "",
    "text": "TL;DR: We do not use cookies and we do not collect any personal data.\n\nWebsite visitors\n\nNo personal information is collected.\nNo information is stored in the browser.\nNo information is shared with, sent to or sold to third-parties.\nNo information is shared with advertising companies.\nNo information is mined and harvested for personal and behavioral trends.\nNo information is monetized.\n\n\n\nInformation we collect and what we use it for\nWe run Google Analytics analytics on viash.io. The following information is collected:\n\nPage URL. We track the page URL of each page view on this website. We use this to understand which pages have been viewed and how many times a particular page has been viewed. For example: https://viash.io/.\nHTTP Referrer. We use the referrer string to understand the number of visitors referred to this website from links on other sites. For example: https://github.com/.\nBrowser. We use this to understand what browsers people use when visiting this website. This is derived from the User-Agent HTTP header. The full User-Agent is discarded. For example: Chrome.\nOperating system. We use this to understand what operating systems people use when visiting this website. We only use the brand of the operating system and don’t include the version number or any other details. This is derived from the User-Agent HTTP header. The full User-Agent is discarded. For example: GNU/Linux.\nDevice type. We use this to understand what devices people use when visiting this website. This is derived from window.innerWidth. The actual width of the browser in pixels is discarded. For example: Desktop.\nVisitor Country. We look up the visitor’s country using the IP address. We do not track anything more granular than the country of origin and the IP address of the visitor is discarded. We never store IP addresses in our database or logs. For example: Canada.\n\n\n\nContact us\nContact us if you have any questions."
  },
  {
    "objectID": "faq/index.html",
    "href": "faq/index.html",
    "title": "Frequently Asked Questions",
    "section": "",
    "text": "One or more of my output files are owned by root after running a component. Why is this?\nIn Linux, files created by Docker are owned by root by default.\nYou can set up the chown attribute in your config file to automatically transfer the ownership of files to the user running the component. Any file output where an argument of the type file with an output direction was used will also have their ownership transferred.\n\n\nCan I store helper functions as separate files?\nYes, though you’ll need to let Viash know which additional files are required to run the component. For example, if several helper functions are stored in an additional file mymodule.py or mymodule.R, use the following code to import the helper functions:\n\nPython\nIn the resources section of the Viash config file:\nresources:\n  - type: python_script\n    path: script.py\n  - path: mymodule.py\nIn the main Python script:\nimport sys\n\n## VIASH START\nmeta = { 'resources_dir': '.' }\n## VIASH END\n\nsys.path.append(meta['resources_dir'])\nfrom mymodule import helper_fun\n\n\nR\nIn the resources section of the Viash config file:\nresources:\n  - type: r_script\n    path: script.R\n  - path: mymodule.R\nIn the main R script:\n## VIASH START\nmeta <- list(resources_dir = \".\")\n## VIASH END\n\nsource(paste0(meta[[\"resources_dir\"]], \"/mymodule.R\"))\nhelper_fun(...)"
  },
  {
    "objectID": "reference/config/requirements/rubyRequirements.html",
    "href": "reference/config/requirements/rubyRequirements.html",
    "title": "Ruby Requirements",
    "section": "",
    "text": "Specify which Ruby packages should be available in order to run the component.\n\nExample\nsetup:\n  - type: ruby\n    packages: [ rspec ]"
  },
  {
    "objectID": "reference/config/requirements/pythonRequirements.html",
    "href": "reference/config/requirements/pythonRequirements.html",
    "title": "Python Requirements",
    "section": "",
    "text": "Specify which Python packages should be available in order to run the component.\n\nExample\nsetup:\n  - type: python\n    pip: [ numpy ]\n    git: [ https://some.git.repository/org/repo ]\n    github: [ jkbr/httpie ]\n    gitlab: [ foo/bar ]\n    mercurial: [ http://... ]\n    svn: [ http://...]\n    bazaar: [ http://... ]\n    url: [ http://... ]"
  },
  {
    "objectID": "reference/config/requirements/dockerRequirements.html",
    "href": "reference/config/requirements/dockerRequirements.html",
    "title": "Docker Requirements",
    "section": "",
    "text": "Specify which Docker commands should be run during setup.\n\nExample\nsetup:\n  - type: docker\n    build_args: [ GITHUB_PAT=hello_world ]\n    run: [ git clone ... ]\n    add: [ \"http://foo.bar .\" ]\n    copy: [ \"http://foo.bar .\" ]\n    resources: \n      - resource.txt /path/to/resource.txt"
  },
  {
    "objectID": "reference/config/requirements/apkRequirements.html",
    "href": "reference/config/requirements/apkRequirements.html",
    "title": "Apk Requirements",
    "section": "",
    "text": "Specify which apk packages should be available in order to run the component.\n\nExample\nsetup:\n  - type: apk\n    packages: [ sl ]"
  },
  {
    "objectID": "reference/config/requirements/javascriptRequirements.html",
    "href": "reference/config/requirements/javascriptRequirements.html",
    "title": "Javascript Requirements",
    "section": "",
    "text": "Specify which JavaScript packages should be available in order to run the component.\n\nExample\nsetup:\n  - type: javascript\n    npm: [ packagename ]\n    git: [ https://... ]\n    github: [ owner/repository ]\n    url: [ https://... ]"
  },
  {
    "objectID": "reference/config/requirements/aptRequirements.html",
    "href": "reference/config/requirements/aptRequirements.html",
    "title": "Apt Requirements",
    "section": "",
    "text": "Specify which apt packages should be available in order to run the component.\n\nExample\nsetup:\n  - type: apt\n    packages: [ sl ]"
  },
  {
    "objectID": "reference/config/requirements/rRequirements.html",
    "href": "reference/config/requirements/rRequirements.html",
    "title": "R Requirements",
    "section": "",
    "text": "Specify which R packages should be available in order to run the component.\n\nExample\nsetup: \n  - type: r\n    cran: [ dynutils ]\n    bioc: [ AnnotationDbi ]\n    git: [ https://some.git.repository/org/repo ]\n    github: [ rcannood/SCORPIUS ]\n    gitlab: [ org/package ]\n    svn: [ https://path.to.svn/group/repo ]\n    url: [ https://github.com/hadley/stringr/archive/HEAD.zip ]\n    script: [ 'devtools::install(\".\")' ]"
  },
  {
    "objectID": "reference/config/requirements/yumRequirements.html",
    "href": "reference/config/requirements/yumRequirements.html",
    "title": "Yum Requirements",
    "section": "",
    "text": "Specify which yum packages should be available in order to run the component.\n\nExample\nsetup:\n  - type: yum\n    packages: [ sl ]"
  },
  {
    "objectID": "reference/config/arguments/string.html",
    "href": "reference/config/arguments/string.html",
    "title": "string",
    "section": "",
    "text": "A string type argument has a value made up of an ordered sequences of characters, like “Hello” or “I’m a string”.\nExample:"
  },
  {
    "objectID": "reference/config/arguments/string.html#alternatives",
    "href": "reference/config/arguments/string.html#alternatives",
    "title": "string",
    "section": "alternatives",
    "text": "alternatives\nType: String / List of String\nList of alternative format variations for this argument."
  },
  {
    "objectID": "reference/config/arguments/string.html#choices",
    "href": "reference/config/arguments/string.html#choices",
    "title": "string",
    "section": "choices",
    "text": "choices\nType: List of String\nLimit the amount of valid values for this argument to those set in this list. When set and a value not present in the list is provided, an error will be produced.\nExample:\n- name: --language\n  type: string\n  choices: [\"python\", \"r\", \"javascript\"]"
  },
  {
    "objectID": "reference/config/arguments/string.html#default",
    "href": "reference/config/arguments/string.html#default",
    "title": "string",
    "section": "default",
    "text": "default\nType: String / List of String\nThe default value when no argument value is provided. This will not work if the required property is enabled.\nExample:\n- name: --my_string\n  type: string\n  default: \"The answer is 42\""
  },
  {
    "objectID": "reference/config/arguments/string.html#description",
    "href": "reference/config/arguments/string.html#description",
    "title": "string",
    "section": "description",
    "text": "description\nType: String\nA description of the argument. This will be displayed with --help."
  },
  {
    "objectID": "reference/config/arguments/string.html#example",
    "href": "reference/config/arguments/string.html#example",
    "title": "string",
    "section": "example",
    "text": "example\nType: String / List of String\nAn example value for this argument. If no default property was specified, this will be used for that purpose.\nExample:\n- name: --my_string\n  type: string\n  example: \"Hello World\""
  },
  {
    "objectID": "reference/config/arguments/string.html#info",
    "href": "reference/config/arguments/string.html#info",
    "title": "string",
    "section": "info",
    "text": "info\nType: Json\nStructured information. Can be any shape: a string, vector, map or even nested map.\nExample:\ninfo:\n  category: cat1\n  labels: [one, two, three]"
  },
  {
    "objectID": "reference/config/arguments/string.html#multiple",
    "href": "reference/config/arguments/string.html#multiple",
    "title": "string",
    "section": "multiple",
    "text": "multiple\nType: Boolean\nTreat the argument value as an array. Arrays can be passed using the delimiter --foo=1:2:3 or by providing the same argument multiple times --foo 1 --foo 2. You can use a custom delimiter by using the multiple_sep property. false by default.\nExample:\n- name: --my_string\n  type: string\n  multiple: true\nHere’s an example of how to use this:\nmy_component --my_string=Marc:Susan:Paul"
  },
  {
    "objectID": "reference/config/arguments/string.html#multiple_sep",
    "href": "reference/config/arguments/string.html#multiple_sep",
    "title": "string",
    "section": "multiple_sep",
    "text": "multiple_sep\nType: String\nThe delimiter character for providing multiple values. : by default.\nExample:\n- name: --my_string\n  type: string\n  multiple: true\n  multiple_sep: \",\"\nHere’s an example of how to use this:\nmy_component --my_string=Marc,Susan,Paul"
  },
  {
    "objectID": "reference/config/arguments/string.html#name",
    "href": "reference/config/arguments/string.html#name",
    "title": "string",
    "section": "name",
    "text": "name\nType: String\nThe name of the argument. Can be in the formats --foo, -f or foo. The number of dashes determines how values can be passed:\n\n--foo is a long option, which can be passed with executable_name --foo=value or executable_name --foo value\n-f is a short option, which can be passed with executable_name -f value\nfoo is an argument, which can be passed with executable_name value"
  },
  {
    "objectID": "reference/config/arguments/string.html#required",
    "href": "reference/config/arguments/string.html#required",
    "title": "string",
    "section": "required",
    "text": "required\nType: Boolean\nMake the value for this argument required. If set to true, an error will be produced if no value was provided. false by default.\nExample:\n- name: --my_string\n  type: string\n  required: true"
  },
  {
    "objectID": "reference/config/arguments/string.html#type",
    "href": "reference/config/arguments/string.html#type",
    "title": "string",
    "section": "type",
    "text": "type\nType: String\nSpecifies the type of the argument."
  },
  {
    "objectID": "reference/config/arguments/integer.html",
    "href": "reference/config/arguments/integer.html",
    "title": "integer",
    "section": "",
    "text": "An integer type argument has a numeric value without decimal points.\nExample:"
  },
  {
    "objectID": "reference/config/arguments/integer.html#alternatives",
    "href": "reference/config/arguments/integer.html#alternatives",
    "title": "integer",
    "section": "alternatives",
    "text": "alternatives\nType: String / List of String\nList of alternative format variations for this argument."
  },
  {
    "objectID": "reference/config/arguments/integer.html#choices",
    "href": "reference/config/arguments/integer.html#choices",
    "title": "integer",
    "section": "choices",
    "text": "choices\nType: List of Int\nLimit the amount of valid values for this argument to those set in this list. When set and a value not present in the list is provided, an error will be produced.\nExample:\n- name: --values\n  type: integer\n  choices: [1024, 2048, 4096]"
  },
  {
    "objectID": "reference/config/arguments/integer.html#default",
    "href": "reference/config/arguments/integer.html#default",
    "title": "integer",
    "section": "default",
    "text": "default\nType: Int / List of Int\nThe default value when no argument value is provided. This will not work if the required property is enabled.\nExample:\n- name: --my_integer\n  type: integer\n  default: 100"
  },
  {
    "objectID": "reference/config/arguments/integer.html#description",
    "href": "reference/config/arguments/integer.html#description",
    "title": "integer",
    "section": "description",
    "text": "description\nType: String\nA description of the argument. This will be displayed with --help."
  },
  {
    "objectID": "reference/config/arguments/integer.html#example",
    "href": "reference/config/arguments/integer.html#example",
    "title": "integer",
    "section": "example",
    "text": "example\nType: Int / List of Int\nAn example value for this argument. If no default property was specified, this will be used for that purpose.\nExample:\n- name: --my_integer\n  type: integer\n  example: 100"
  },
  {
    "objectID": "reference/config/arguments/integer.html#info",
    "href": "reference/config/arguments/integer.html#info",
    "title": "integer",
    "section": "info",
    "text": "info\nType: Json\nStructured information. Can be any shape: a string, vector, map or even nested map.\nExample:\ninfo:\n  category: cat1\n  labels: [one, two, three]"
  },
  {
    "objectID": "reference/config/arguments/integer.html#max",
    "href": "reference/config/arguments/integer.html#max",
    "title": "integer",
    "section": "max",
    "text": "max\nType: Int\nMaximum allowed value for this argument. If set and the provided value is higher than the maximum, an error will be produced. Can be combined with min to clamp values.\nExample:\n- name: --my_integer\n  type: integer\n  max: 150"
  },
  {
    "objectID": "reference/config/arguments/integer.html#min",
    "href": "reference/config/arguments/integer.html#min",
    "title": "integer",
    "section": "min",
    "text": "min\nType: Int\nMinimum allowed value for this argument. If set and the provided value is lower than the minimum, an error will be produced. Can be combined with max to clamp values.\nExample:\n- name: --my_integer\n  type: integer\n  min: 50"
  },
  {
    "objectID": "reference/config/arguments/integer.html#multiple",
    "href": "reference/config/arguments/integer.html#multiple",
    "title": "integer",
    "section": "multiple",
    "text": "multiple\nType: Boolean\nTreat the argument value as an array. Arrays can be passed using the delimiter --foo=1:2:3 or by providing the same argument multiple times --foo 1 --foo 2. You can use a custom delimiter by using the multiple_sep property. false by default.\nExample:\n- name: --my_integer\n  type: integer\n  multiple: true\nHere’s an example of how to use this:\nmy_component --my_integer=10:80:152"
  },
  {
    "objectID": "reference/config/arguments/integer.html#multiple_sep",
    "href": "reference/config/arguments/integer.html#multiple_sep",
    "title": "integer",
    "section": "multiple_sep",
    "text": "multiple_sep\nType: String\nThe delimiter character for providing multiple values. : by default.\nExample:\n- name: --my_integer\n  type: integer\n  multiple: true\n  multiple_sep: \",\"\nHere’s an example of how to use this:\nmy_component --my_integer=10:80:152"
  },
  {
    "objectID": "reference/config/arguments/integer.html#name",
    "href": "reference/config/arguments/integer.html#name",
    "title": "integer",
    "section": "name",
    "text": "name\nType: String\nThe name of the argument. Can be in the formats --foo, -f or foo. The number of dashes determines how values can be passed:\n\n--foo is a long option, which can be passed with executable_name --foo=value or executable_name --foo value\n-f is a short option, which can be passed with executable_name -f value\nfoo is an argument, which can be passed with executable_name value"
  },
  {
    "objectID": "reference/config/arguments/integer.html#required",
    "href": "reference/config/arguments/integer.html#required",
    "title": "integer",
    "section": "required",
    "text": "required\nType: Boolean\nMake the value for this argument required. If set to true, an error will be produced if no value was provided. false by default.\nExample:\n- name: --my_integer\n  type: integer\n  required: true"
  },
  {
    "objectID": "reference/config/arguments/integer.html#type",
    "href": "reference/config/arguments/integer.html#type",
    "title": "integer",
    "section": "type",
    "text": "type\nType: String\nSpecifies the type of the argument."
  },
  {
    "objectID": "reference/config/arguments/boolean.html",
    "href": "reference/config/arguments/boolean.html",
    "title": "boolean",
    "section": "",
    "text": "A boolean type argument has two possible values: true or false.\nExample:"
  },
  {
    "objectID": "reference/config/arguments/boolean.html#alternatives",
    "href": "reference/config/arguments/boolean.html#alternatives",
    "title": "boolean",
    "section": "alternatives",
    "text": "alternatives\nType: String / List of String\nList of alternative format variations for this argument."
  },
  {
    "objectID": "reference/config/arguments/boolean.html#default",
    "href": "reference/config/arguments/boolean.html#default",
    "title": "boolean",
    "section": "default",
    "text": "default\nType: Boolean / List of Boolean\nThe default value when no argument value is provided. This will not work if the required property is enabled.\nExample:\n- name: --my_boolean\n  type: boolean\n  default: true"
  },
  {
    "objectID": "reference/config/arguments/boolean.html#description",
    "href": "reference/config/arguments/boolean.html#description",
    "title": "boolean",
    "section": "description",
    "text": "description\nType: String\nA description of the argument. This will be displayed with --help."
  },
  {
    "objectID": "reference/config/arguments/boolean.html#example",
    "href": "reference/config/arguments/boolean.html#example",
    "title": "boolean",
    "section": "example",
    "text": "example\nType: Boolean / List of Boolean\nAn example value for this argument. If no default property was specified, this will be used for that purpose.\nExample:\n- name: --my_boolean\n  type: boolean\n  example: true"
  },
  {
    "objectID": "reference/config/arguments/boolean.html#info",
    "href": "reference/config/arguments/boolean.html#info",
    "title": "boolean",
    "section": "info",
    "text": "info\nType: Json\nStructured information. Can be any shape: a string, vector, map or even nested map.\nExample:\ninfo:\n  category: cat1\n  labels: [one, two, three]"
  },
  {
    "objectID": "reference/config/arguments/boolean.html#multiple",
    "href": "reference/config/arguments/boolean.html#multiple",
    "title": "boolean",
    "section": "multiple",
    "text": "multiple\nType: Boolean\nTreat the argument value as an array. Arrays can be passed using the delimiter --foo=1:2:3 or by providing the same argument multiple times --foo 1 --foo 2. You can use a custom delimiter by using the multiple_sep property. false by default.\nExample:\n- name: --my_boolean\n  type: boolean\n  multiple: true\nHere’s an example of how to use this:\nmy_component --my_boolean=true:true:false"
  },
  {
    "objectID": "reference/config/arguments/boolean.html#multiple_sep",
    "href": "reference/config/arguments/boolean.html#multiple_sep",
    "title": "boolean",
    "section": "multiple_sep",
    "text": "multiple_sep\nType: String\nThe delimiter character for providing multiple values. : by default.\nExample:\n- name: --my_boolean\n  type: boolean\n  multiple: true\n  multiple_sep: \",\"\nHere’s an example of how to use this:\nmy_component --my_boolean=true,true,false"
  },
  {
    "objectID": "reference/config/arguments/boolean.html#name",
    "href": "reference/config/arguments/boolean.html#name",
    "title": "boolean",
    "section": "name",
    "text": "name\nType: String\nThe name of the argument. Can be in the formats --trim, -t or trim. The number of dashes determines how values can be passed:\n\n--trim is a long option, which can be passed with executable_name --trim\n-t is a short option, which can be passed with executable_name -t\ntrim is an argument, which can be passed with executable_name trim"
  },
  {
    "objectID": "reference/config/arguments/boolean.html#required",
    "href": "reference/config/arguments/boolean.html#required",
    "title": "boolean",
    "section": "required",
    "text": "required\nType: Boolean\nMake the value for this argument required. If set to true, an error will be produced if no value was provided. false by default.\nExample:\n- name: --my_boolean\n  type: boolean\n  required: true"
  },
  {
    "objectID": "reference/config/arguments/boolean.html#type",
    "href": "reference/config/arguments/boolean.html#type",
    "title": "boolean",
    "section": "type",
    "text": "type\nType: String\nSpecifies the type of the argument."
  },
  {
    "objectID": "reference/config/arguments/file.html",
    "href": "reference/config/arguments/file.html",
    "title": "file",
    "section": "",
    "text": "A file type argument has a string value that points to a file or folder path.\nExample:"
  },
  {
    "objectID": "reference/config/arguments/file.html#alternatives",
    "href": "reference/config/arguments/file.html#alternatives",
    "title": "file",
    "section": "alternatives",
    "text": "alternatives\nType: String / List of String\nList of alternative format variations for this argument."
  },
  {
    "objectID": "reference/config/arguments/file.html#default",
    "href": "reference/config/arguments/file.html#default",
    "title": "file",
    "section": "default",
    "text": "default\nType: Path / List of Path\nThe default value when no argument value is provided. This will not work if the required property is enabled.\nExample:\n- name: --my_file\n  type: file\n  default: data.csv"
  },
  {
    "objectID": "reference/config/arguments/file.html#description",
    "href": "reference/config/arguments/file.html#description",
    "title": "file",
    "section": "description",
    "text": "description\nType: String\nA description of the argument. This will be displayed with --help."
  },
  {
    "objectID": "reference/config/arguments/file.html#direction",
    "href": "reference/config/arguments/file.html#direction",
    "title": "file",
    "section": "direction",
    "text": "direction\nType: Direction\nMakes this argument an input or an output, as in does the file/folder needs to be read or written. input by default.\nExample:\n- name: --my_output_file\n  type: file\n  direction: output"
  },
  {
    "objectID": "reference/config/arguments/file.html#example",
    "href": "reference/config/arguments/file.html#example",
    "title": "file",
    "section": "example",
    "text": "example\nType: Path / List of Path\nAn example value for this argument. If no default property was specified, this will be used for that purpose.\nExample:\n- name: --my_file\n  type: file\n  example: data.csv"
  },
  {
    "objectID": "reference/config/arguments/file.html#info",
    "href": "reference/config/arguments/file.html#info",
    "title": "file",
    "section": "info",
    "text": "info\nType: Json\nStructured information. Can be any shape: a string, vector, map or even nested map.\nExample:\ninfo:\n  category: cat1\n  labels: [one, two, three]"
  },
  {
    "objectID": "reference/config/arguments/file.html#multiple",
    "href": "reference/config/arguments/file.html#multiple",
    "title": "file",
    "section": "multiple",
    "text": "multiple\nType: Boolean\nTreat the argument value as an array. Arrays can be passed using the delimiter --foo=1:2:3 or by providing the same argument multiple times --foo 1 --foo 2. You can use a custom delimiter by using the multiple_sep property. false by default.\nExample:\n- name: --my_files\n  type: file\n  multiple: true\nHere’s an example of how to use this:\nmy_component --my_files=firstFile.csv:anotherFile.csv:yetAnother.csv"
  },
  {
    "objectID": "reference/config/arguments/file.html#multiple_sep",
    "href": "reference/config/arguments/file.html#multiple_sep",
    "title": "file",
    "section": "multiple_sep",
    "text": "multiple_sep\nType: String\nThe delimiter character for providing multiple values. : by default.\nExample:\n- name: --my_files\n  type: file\n  multiple: true\n  multiple_sep: \",\"\nHere’s an example of how to use this:\nmy_component --my_files=firstFile.csv,anotherFile.csv,yetAnother.csv"
  },
  {
    "objectID": "reference/config/arguments/file.html#must_exist",
    "href": "reference/config/arguments/file.html#must_exist",
    "title": "file",
    "section": "must_exist",
    "text": "must_exist\nType: Boolean\nThe file or folder should exist before the start of execution. If set to true, an error will be produced if the file or folder wasn’t found.\nExample:\n- name: --my_file\n  type: file\n  must_exist: true"
  },
  {
    "objectID": "reference/config/arguments/file.html#name",
    "href": "reference/config/arguments/file.html#name",
    "title": "file",
    "section": "name",
    "text": "name\nType: String\nThe name of the argument. Can be in the formats --foo, -f or foo. The number of dashes determines how values can be passed:\n\n--foo is a long option, which can be passed with executable_name --foo=value or executable_name --foo value\n-f is a short option, which can be passed with executable_name -f value\nfoo is an argument, which can be passed with executable_name value"
  },
  {
    "objectID": "reference/config/arguments/file.html#required",
    "href": "reference/config/arguments/file.html#required",
    "title": "file",
    "section": "required",
    "text": "required\nType: Boolean\nMake the value for this argument required. If set to true, an error will be produced if no value was provided. false by default.\nExample:\n- name: --my_file\n  type: file\n  required: true"
  },
  {
    "objectID": "reference/config/arguments/file.html#type",
    "href": "reference/config/arguments/file.html#type",
    "title": "file",
    "section": "type",
    "text": "type\nType: String\nSpecifies the type of the argument."
  },
  {
    "objectID": "reference/config/arguments/boolean_false.html",
    "href": "reference/config/arguments/boolean_false.html",
    "title": "boolean_false",
    "section": "",
    "text": "An argument of the boolean_false type acts like an inverted boolean flag with a default value of true. When called as an argument it sets the boolean to false.\nExample:"
  },
  {
    "objectID": "reference/config/arguments/boolean_false.html#alternatives",
    "href": "reference/config/arguments/boolean_false.html#alternatives",
    "title": "boolean_false",
    "section": "alternatives",
    "text": "alternatives\nType: String / List of String\nList of alternative format variations for this argument."
  },
  {
    "objectID": "reference/config/arguments/boolean_false.html#description",
    "href": "reference/config/arguments/boolean_false.html#description",
    "title": "boolean_false",
    "section": "description",
    "text": "description\nType: String\nA description of the argument. This will be displayed with --help."
  },
  {
    "objectID": "reference/config/arguments/boolean_false.html#info",
    "href": "reference/config/arguments/boolean_false.html#info",
    "title": "boolean_false",
    "section": "info",
    "text": "info\nType: Json\nStructured information. Can be any shape: a string, vector, map or even nested map.\nExample:\ninfo:\n  category: cat1\n  labels: [one, two, three]"
  },
  {
    "objectID": "reference/config/arguments/boolean_false.html#name",
    "href": "reference/config/arguments/boolean_false.html#name",
    "title": "boolean_false",
    "section": "name",
    "text": "name\nType: String\nThe name of the argument. Can be in the formats --no-log, -n or no-log. The number of dashes determines how values can be passed:\n\n--no-log is a long option, which can be passed with executable_name --no-log\n-n is a short option, which can be passed with executable_name -n\nno-log is an argument, which can be passed with executable_name no-log"
  },
  {
    "objectID": "reference/config/arguments/boolean_false.html#type",
    "href": "reference/config/arguments/boolean_false.html#type",
    "title": "boolean_false",
    "section": "type",
    "text": "type\nType: String\nSpecifies the type of the argument."
  },
  {
    "objectID": "reference/config/arguments/double.html",
    "href": "reference/config/arguments/double.html",
    "title": "double",
    "section": "",
    "text": "A double type argument has a numeric value with decimal points\nExample:"
  },
  {
    "objectID": "reference/config/arguments/double.html#alternatives",
    "href": "reference/config/arguments/double.html#alternatives",
    "title": "double",
    "section": "alternatives",
    "text": "alternatives\nType: String / List of String\nList of alternative format variations for this argument."
  },
  {
    "objectID": "reference/config/arguments/double.html#default",
    "href": "reference/config/arguments/double.html#default",
    "title": "double",
    "section": "default",
    "text": "default\nType: Double / List of Double\nThe default value when no argument value is provided. This will not work if the required property is enabled.\nExample:\n- name: --my_double\n  type: double\n  default: 5.8"
  },
  {
    "objectID": "reference/config/arguments/double.html#description",
    "href": "reference/config/arguments/double.html#description",
    "title": "double",
    "section": "description",
    "text": "description\nType: String\nA description of the argument. This will be displayed with --help."
  },
  {
    "objectID": "reference/config/arguments/double.html#example",
    "href": "reference/config/arguments/double.html#example",
    "title": "double",
    "section": "example",
    "text": "example\nType: Double / List of Double\nAn example value for this argument. If no default property was specified, this will be used for that purpose.\nExample:\n- name: --my_double\n  type: double\n  example: 5.8"
  },
  {
    "objectID": "reference/config/arguments/double.html#info",
    "href": "reference/config/arguments/double.html#info",
    "title": "double",
    "section": "info",
    "text": "info\nType: Json\nStructured information. Can be any shape: a string, vector, map or even nested map.\nExample:\ninfo:\n  category: cat1\n  labels: [one, two, three]"
  },
  {
    "objectID": "reference/config/arguments/double.html#max",
    "href": "reference/config/arguments/double.html#max",
    "title": "double",
    "section": "max",
    "text": "max\nType: Double\nMaximum allowed value for this argument. If set and the provided value is higher than the maximum, an error will be produced. Can be combined with min to clamp values.\nExample:\n- name: --my_double\n  type: double\n  max: 80.4"
  },
  {
    "objectID": "reference/config/arguments/double.html#min",
    "href": "reference/config/arguments/double.html#min",
    "title": "double",
    "section": "min",
    "text": "min\nType: Double\nMinimum allowed value for this argument. If set and the provided value is lower than the minimum, an error will be produced. Can be combined with max to clamp values.\nExample:\n- name: --my_double\n  type: double\n  min: 25.5"
  },
  {
    "objectID": "reference/config/arguments/double.html#multiple",
    "href": "reference/config/arguments/double.html#multiple",
    "title": "double",
    "section": "multiple",
    "text": "multiple\nType: Boolean\nTreat the argument value as an array. Arrays can be passed using the delimiter --foo=1:2:3 or by providing the same argument multiple times --foo 1 --foo 2. You can use a custom delimiter by using the multiple_sep property. false by default.\nExample:\n- name: --my_double\n  type: double\n  multiple: true\nHere’s an example of how to use this:\nmy_component --my_double=5.8:22.6:200.4"
  },
  {
    "objectID": "reference/config/arguments/double.html#multiple_sep",
    "href": "reference/config/arguments/double.html#multiple_sep",
    "title": "double",
    "section": "multiple_sep",
    "text": "multiple_sep\nType: String\nThe delimiter character for providing multiple values. : by default.\nExample:\n- name: --my_double\n  type: double\n  multiple: true\n  multiple_sep: \",\"\nHere’s an example of how to use this:\nmy_component --my_double=5.8,22.6,200.4"
  },
  {
    "objectID": "reference/config/arguments/double.html#name",
    "href": "reference/config/arguments/double.html#name",
    "title": "double",
    "section": "name",
    "text": "name\nType: String\nThe name of the argument. Can be in the formats --foo, -f or foo. The number of dashes determines how values can be passed:\n\n--foo is a long option, which can be passed with executable_name --foo=value or executable_name --foo value\n-f is a short option, which can be passed with executable_name -f value\nfoo is an argument, which can be passed with executable_name value"
  },
  {
    "objectID": "reference/config/arguments/double.html#required",
    "href": "reference/config/arguments/double.html#required",
    "title": "double",
    "section": "required",
    "text": "required\nType: Boolean\nMake the value for this argument required. If set to true, an error will be produced if no value was provided. false by default.\nExample:\n- name: --my_double\n  type: double\n  required: true"
  },
  {
    "objectID": "reference/config/arguments/double.html#type",
    "href": "reference/config/arguments/double.html#type",
    "title": "double",
    "section": "type",
    "text": "type\nType: String\nSpecifies the type of the argument."
  },
  {
    "objectID": "reference/config/arguments/long.html",
    "href": "reference/config/arguments/long.html",
    "title": "long",
    "section": "",
    "text": "An long type argument has a numeric value without decimal points.\nExample:"
  },
  {
    "objectID": "reference/config/arguments/long.html#alternatives",
    "href": "reference/config/arguments/long.html#alternatives",
    "title": "long",
    "section": "alternatives",
    "text": "alternatives\nType: String / List of String\nList of alternative format variations for this argument."
  },
  {
    "objectID": "reference/config/arguments/long.html#choices",
    "href": "reference/config/arguments/long.html#choices",
    "title": "long",
    "section": "choices",
    "text": "choices\nType: List of Long\nLimit the amount of valid values for this argument to those set in this list. When set and a value not present in the list is provided, an error will be produced.\nExample:\n- name: --values\n  type: long\n  choices: [1024, 2048, 4096]"
  },
  {
    "objectID": "reference/config/arguments/long.html#default",
    "href": "reference/config/arguments/long.html#default",
    "title": "long",
    "section": "default",
    "text": "default\nType: Long / List of Long\nThe default value when no argument value is provided. This will not work if the required property is enabled.\nExample:\n- name: --my_long\n  type: long\n  default: 100"
  },
  {
    "objectID": "reference/config/arguments/long.html#description",
    "href": "reference/config/arguments/long.html#description",
    "title": "long",
    "section": "description",
    "text": "description\nType: String\nA description of the argument. This will be displayed with --help."
  },
  {
    "objectID": "reference/config/arguments/long.html#example",
    "href": "reference/config/arguments/long.html#example",
    "title": "long",
    "section": "example",
    "text": "example\nType: Long / List of Long\nAn example value for this argument. If no default property was specified, this will be used for that purpose.\nExample:\n- name: --my_long\n  type: long\n  example: 100"
  },
  {
    "objectID": "reference/config/arguments/long.html#info",
    "href": "reference/config/arguments/long.html#info",
    "title": "long",
    "section": "info",
    "text": "info\nType: Json\nStructured information. Can be any shape: a string, vector, map or even nested map.\nExample:\ninfo:\n  category: cat1\n  labels: [one, two, three]"
  },
  {
    "objectID": "reference/config/arguments/long.html#max",
    "href": "reference/config/arguments/long.html#max",
    "title": "long",
    "section": "max",
    "text": "max\nType: Long\nMaximum allowed value for this argument. If set and the provided value is higher than the maximum, an error will be produced. Can be combined with min to clamp values.\nExample:\n- name: --my_long\n  type: long\n  max: 150"
  },
  {
    "objectID": "reference/config/arguments/long.html#min",
    "href": "reference/config/arguments/long.html#min",
    "title": "long",
    "section": "min",
    "text": "min\nType: Long\nMinimum allowed value for this argument. If set and the provided value is lower than the minimum, an error will be produced. Can be combined with max to clamp values.\nExample:\n- name: --my_long\n  type: long\n  min: 50"
  },
  {
    "objectID": "reference/config/arguments/long.html#multiple",
    "href": "reference/config/arguments/long.html#multiple",
    "title": "long",
    "section": "multiple",
    "text": "multiple\nType: Boolean\nTreat the argument value as an array. Arrays can be passed using the delimiter --foo=1:2:3 or by providing the same argument multiple times --foo 1 --foo 2. You can use a custom delimiter by using the multiple_sep property. false by default.\nExample:\n- name: --my_long\n  type: long\n  multiple: true\nHere’s an example of how to use this:\nmy_component --my_long=10:80:152"
  },
  {
    "objectID": "reference/config/arguments/long.html#multiple_sep",
    "href": "reference/config/arguments/long.html#multiple_sep",
    "title": "long",
    "section": "multiple_sep",
    "text": "multiple_sep\nType: String\nThe delimiter character for providing multiple values. : by default.\nExample:\n- name: --my_long\n  type: long\n  multiple: true\n  multiple_sep: \",\"\nHere’s an example of how to use this:\nmy_component --my_long=10:80:152"
  },
  {
    "objectID": "reference/config/arguments/long.html#name",
    "href": "reference/config/arguments/long.html#name",
    "title": "long",
    "section": "name",
    "text": "name\nType: String\nThe name of the argument. Can be in the formats --foo, -f or foo. The number of dashes determines how values can be passed:\n\n--foo is a long option, which can be passed with executable_name --foo=value or executable_name --foo value\n-f is a short option, which can be passed with executable_name -f value\nfoo is an argument, which can be passed with executable_name value"
  },
  {
    "objectID": "reference/config/arguments/long.html#required",
    "href": "reference/config/arguments/long.html#required",
    "title": "long",
    "section": "required",
    "text": "required\nType: Boolean\nMake the value for this argument required. If set to true, an error will be produced if no value was provided. false by default.\nExample:\n- name: --my_long\n  type: long\n  required: true"
  },
  {
    "objectID": "reference/config/arguments/long.html#type",
    "href": "reference/config/arguments/long.html#type",
    "title": "long",
    "section": "type",
    "text": "type\nType: String\nSpecifies the type of the argument."
  },
  {
    "objectID": "reference/config/arguments/boolean_true.html",
    "href": "reference/config/arguments/boolean_true.html",
    "title": "boolean_true",
    "section": "",
    "text": "An argument of the boolean_true type acts like a boolean flag with a default value of false. When called as an argument it sets the boolean to true.\nExample:"
  },
  {
    "objectID": "reference/config/arguments/boolean_true.html#alternatives",
    "href": "reference/config/arguments/boolean_true.html#alternatives",
    "title": "boolean_true",
    "section": "alternatives",
    "text": "alternatives\nType: String / List of String\nList of alternative format variations for this argument."
  },
  {
    "objectID": "reference/config/arguments/boolean_true.html#description",
    "href": "reference/config/arguments/boolean_true.html#description",
    "title": "boolean_true",
    "section": "description",
    "text": "description\nType: String\nA description of the argument. This will be displayed with --help."
  },
  {
    "objectID": "reference/config/arguments/boolean_true.html#info",
    "href": "reference/config/arguments/boolean_true.html#info",
    "title": "boolean_true",
    "section": "info",
    "text": "info\nType: Json\nStructured information. Can be any shape: a string, vector, map or even nested map.\nExample:\ninfo:\n  category: cat1\n  labels: [one, two, three]"
  },
  {
    "objectID": "reference/config/arguments/boolean_true.html#name",
    "href": "reference/config/arguments/boolean_true.html#name",
    "title": "boolean_true",
    "section": "name",
    "text": "name\nType: String\nThe name of the argument. Can be in the formats --silent, -s or silent. The number of dashes determines how values can be passed:\n\n--silent is a long option, which can be passed with executable_name --silent\n-s is a short option, which can be passed with executable_name -s\nsilent is an argument, which can be passed with executable_name silent"
  },
  {
    "objectID": "reference/config/arguments/boolean_true.html#type",
    "href": "reference/config/arguments/boolean_true.html#type",
    "title": "boolean_true",
    "section": "type",
    "text": "type\nType: String\nSpecifies the type of the argument."
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html",
    "href": "reference/config/platforms/DockerPlatform.html",
    "title": "Docker Platform",
    "section": "",
    "text": "Run a Viash component on a Docker backend platform. By specifying which dependencies your component needs, users will be able to build a docker container from scratch using the setup flag, or pull it from a docker repository."
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#apk",
    "href": "reference/config/platforms/DockerPlatform.html#apk",
    "title": "Docker Platform",
    "section": "apk",
    "text": "apk\nType: ApkRequirements\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.5.15. Use setup instead.\n\n\nSpecify which apk packages should be available in order to run the component.\nExample:\nsetup:\n  - type: apk\n    packages: [ sl ]"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#apt",
    "href": "reference/config/platforms/DockerPlatform.html#apt",
    "title": "Docker Platform",
    "section": "apt",
    "text": "apt\nType: AptRequirements\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.5.15. Use setup instead.\n\n\nSpecify which apt packages should be available in order to run the component.\nExample:\nsetup:\n  - type: apt\n    packages: [ sl ]"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#chown",
    "href": "reference/config/platforms/DockerPlatform.html#chown",
    "title": "Docker Platform",
    "section": "chown",
    "text": "chown\nType: Boolean\nIn Linux, files created by a Docker container will be owned by root. With chown: true, Viash will automatically change the ownership of output files (arguments with type: file and direction: output) to the user running the Viash command after execution of the component. Default value: true.\nExample:\nchown: false"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#docker",
    "href": "reference/config/platforms/DockerPlatform.html#docker",
    "title": "Docker Platform",
    "section": "docker",
    "text": "docker\nType: DockerRequirements\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.5.15. Use setup instead.\n\n\nSpecify which Docker commands should be run during setup.\nExample:\nsetup:\n  - type: docker\n    build_args: [ GITHUB_PAT=hello_world ]\n    run: [ git clone ... ]\n    add: [ \"http://foo.bar .\" ]\n    copy: [ \"http://foo.bar .\" ]\n    resources: \n      - resource.txt /path/to/resource.txt"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#id",
    "href": "reference/config/platforms/DockerPlatform.html#id",
    "title": "Docker Platform",
    "section": "id",
    "text": "id\nType: String\nAs with all platforms, you can give a platform a different name. By specifying id: foo, you can target this platform (only) by specifying -p foo in any of the Viash commands.\nExample:\nid: foo"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#image",
    "href": "reference/config/platforms/DockerPlatform.html#image",
    "title": "Docker Platform",
    "section": "image",
    "text": "image\nType: String\nThe base container to start from. You can also add the tag here if you wish.\nExample:\nimage: \"bash:4.0\""
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#namespace_separator",
    "href": "reference/config/platforms/DockerPlatform.html#namespace_separator",
    "title": "Docker Platform",
    "section": "namespace_separator",
    "text": "namespace_separator\nType: String\nThe default namespace separator is “_“.\nExample:\nnamespace_separator: \"+\""
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#organization",
    "href": "reference/config/platforms/DockerPlatform.html#organization",
    "title": "Docker Platform",
    "section": "organization",
    "text": "organization\nType: String\nName of a container’s organization."
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#port",
    "href": "reference/config/platforms/DockerPlatform.html#port",
    "title": "Docker Platform",
    "section": "port",
    "text": "port\nType: String / List of String\nA list of enabled ports. This doesn’t change the Dockerfile but gets added as a command-line argument at runtime.\nExample:\nport:\n  - 80\n  - 8080"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#privileged",
    "href": "reference/config/platforms/DockerPlatform.html#privileged",
    "title": "Docker Platform",
    "section": "privileged",
    "text": "privileged\nType: Boolean\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.6.3. Add a privileged flag in run_args instead.\n\n\nAdds a privileged flag to the docker run."
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#python",
    "href": "reference/config/platforms/DockerPlatform.html#python",
    "title": "Docker Platform",
    "section": "python",
    "text": "python\nType: PythonRequirements\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.5.15. Use setup instead.\n\n\nSpecify which Python packages should be available in order to run the component.\nExample:\nsetup:\n  - type: python\n    pip: [ numpy ]\n    git: [ https://some.git.repository/org/repo ]\n    github: [ jkbr/httpie ]\n    gitlab: [ foo/bar ]\n    mercurial: [ http://... ]\n    svn: [ http://...]\n    bazaar: [ http://... ]\n    url: [ http://... ]"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#r",
    "href": "reference/config/platforms/DockerPlatform.html#r",
    "title": "Docker Platform",
    "section": "r",
    "text": "r\nType: RRequirements\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.5.15. Use setup instead.\n\n\nSpecify which R packages should be available in order to run the component.\nExample:\nsetup: \n  - type: r\n    cran: [ dynutils ]\n    bioc: [ AnnotationDbi ]\n    git: [ https://some.git.repository/org/repo ]\n    github: [ rcannood/SCORPIUS ]\n    gitlab: [ org/package ]\n    svn: [ https://path.to.svn/group/repo ]\n    url: [ https://github.com/hadley/stringr/archive/HEAD.zip ]\n    script: [ 'devtools::install(\".\")' ]"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#registry",
    "href": "reference/config/platforms/DockerPlatform.html#registry",
    "title": "Docker Platform",
    "section": "registry",
    "text": "registry\nType: String\nThe URL to the a custom Docker registry\nExample:\nregistry: https://my-docker-registry.org"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#resolve_volume",
    "href": "reference/config/platforms/DockerPlatform.html#resolve_volume",
    "title": "Docker Platform",
    "section": "resolve_volume",
    "text": "resolve_volume\nType: DockerResolveVolume\nEnables or disables automatic volume mapping. Enabled when set to Automatic or disabled when set to Manual. Default: Automatic"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#run_args",
    "href": "reference/config/platforms/DockerPlatform.html#run_args",
    "title": "Docker Platform",
    "section": "run_args",
    "text": "run_args\nType: String / List of String\nAdd docker run arguments."
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#setup",
    "href": "reference/config/platforms/DockerPlatform.html#setup",
    "title": "Docker Platform",
    "section": "setup",
    "text": "setup\nType: List of Requirements\nA list of requirements for installing the following types of packages:\n\napt\napk\nDocker setup instructions\nJavaScript\nPython\nR\nRuby\nyum\n\nThe order in which these dependencies are specified determines the order in which they will be installed."
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#setup_strategy",
    "href": "reference/config/platforms/DockerPlatform.html#setup_strategy",
    "title": "Docker Platform",
    "section": "setup_strategy",
    "text": "setup_strategy\nType: DockerSetupStrategy\nThe Docker setup strategy to use when building a container.\n\n\n\nStrategy\nDescription\n\n\n\n\nalwaysbuild / build / b\nAlways build the image from the dockerfile. This is the default setup strategy.\n\n\nalwayscachedbuild / cachedbuild / cb\nAlways build the image from the dockerfile, with caching enabled.\n\n\nifneedbebuild\nBuild the image if it does not exist locally.\n\n\nifneedbecachedbuild\nBuild the image with caching enabled if it does not exist locally, with caching enabled.\n\n\nalwayspull / pull / p\nTry to pull the container from Docker Hub or the specified docker registry.\n\n\nalwayspullelsebuild / pullelsebuild\nTry to pull the image from a registry and build it if it doesn’t exist.\n\n\nalwayspullelsecachedbuild / pullelsecachedbuild\nTry to pull the image from a registry and build it with caching if it doesn’t exist.\n\n\nifneedbepull\nIf the image does not exist locally, pull the image.\n\n\nifneedbepullelsebuild\nIf the image does not exist locally, pull the image. If the image does exist, build it.\n\n\nifneedbepullelsecachedbuild\nIf the image does not exist locally, pull the image. If the image does exist, build it with caching enabled.\n\n\npush\nPush the container to Docker Hub or the specified docker registry.\n\n\npushifnotpresent\nPush the container to Docker Hub or the specified docker registry if the tag does not exist yet.\n\n\ndonothing / meh\nDo not build or pull anything.\n\n\n\nExample:\nsetup_strategy: alwaysbuild"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#tag",
    "href": "reference/config/platforms/DockerPlatform.html#tag",
    "title": "Docker Platform",
    "section": "tag",
    "text": "tag\nType: String\nSpecify a Docker image based on its tag.\nExample:\ntag: 4.0"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#target_image",
    "href": "reference/config/platforms/DockerPlatform.html#target_image",
    "title": "Docker Platform",
    "section": "target_image",
    "text": "target_image\nType: String\nIf anything is specified in the setup section, running the ---setup will result in an image with the name of <target_image>:<version>. If nothing is specified in the setup section, simply image will be used. Advanced usage only.\nExample:\ntarget_image: myfoo"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#target_image_source",
    "href": "reference/config/platforms/DockerPlatform.html#target_image_source",
    "title": "Docker Platform",
    "section": "target_image_source",
    "text": "target_image_source\nType: String\nThe source of the target image. This is used for defining labels in the dockerfile.\nExample:\ntarget_image_source: https://github.com/foo/bar"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#target_organization",
    "href": "reference/config/platforms/DockerPlatform.html#target_organization",
    "title": "Docker Platform",
    "section": "target_organization",
    "text": "target_organization\nType: String\nThe organization set in the resulting image. Advanced usage only.\nExample:\ntarget_organization: viash-io"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#target_registry",
    "href": "reference/config/platforms/DockerPlatform.html#target_registry",
    "title": "Docker Platform",
    "section": "target_registry",
    "text": "target_registry\nType: String\nThe URL where the resulting image will be pushed to. Advanced usage only.\nExample:\ntarget_registry: https://my-docker-registry.org"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#target_tag",
    "href": "reference/config/platforms/DockerPlatform.html#target_tag",
    "title": "Docker Platform",
    "section": "target_tag",
    "text": "target_tag\nType: String\nThe tag the resulting image gets. Advanced usage only.\nExample:\ntarget_tag: 0.5.0"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#test_setup",
    "href": "reference/config/platforms/DockerPlatform.html#test_setup",
    "title": "Docker Platform",
    "section": "test_setup",
    "text": "test_setup\nType: List of Requirements\nAdditional requirements specific for running unit tests."
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#type",
    "href": "reference/config/platforms/DockerPlatform.html#type",
    "title": "Docker Platform",
    "section": "type",
    "text": "type\nType: String\nSpecifies the type of the platform."
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#workdir",
    "href": "reference/config/platforms/DockerPlatform.html#workdir",
    "title": "Docker Platform",
    "section": "workdir",
    "text": "workdir\nType: String\nThe working directory when starting the container. This doesn’t change the Dockerfile but gets added as a command-line argument at runtime.\nExample:\nworkdir: /home/user"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#yum",
    "href": "reference/config/platforms/DockerPlatform.html#yum",
    "title": "Docker Platform",
    "section": "yum",
    "text": "yum\nType: YumRequirements\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.5.15. Use setup instead.\n\n\nSpecify which yum packages should be available in order to run the component.\nExample:\nsetup:\n  - type: yum\n    packages: [ sl ]"
  },
  {
    "objectID": "reference/config/platforms/NativePlatform.html",
    "href": "reference/config/platforms/NativePlatform.html",
    "title": "Native Platform",
    "section": "",
    "text": "Running a Viash component on a native platform means that the script will be executed in your current environment. Any dependencies are assumed to have been installed by the user, so the native platform is meant for developers (who know what they’re doing) or for simple bash scripts (which have no extra dependencies)."
  },
  {
    "objectID": "reference/config/platforms/NativePlatform.html#id",
    "href": "reference/config/platforms/NativePlatform.html#id",
    "title": "Native Platform",
    "section": "id",
    "text": "id\nType: String\nAs with all platforms, you can give a platform a different name. By specifying id: foo, you can target this platform (only) by specifying -p foo in any of the Viash commands.\nExample:\nid: foo"
  },
  {
    "objectID": "reference/config/platforms/NativePlatform.html#type",
    "href": "reference/config/platforms/NativePlatform.html#type",
    "title": "Native Platform",
    "section": "type",
    "text": "type\nType: String\nSpecifies the type of the platform."
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html",
    "title": "Nextflow Legacy Platform",
    "section": "",
    "text": "Run a Viash component as a Nextflow module."
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#executor",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#executor",
    "title": "Nextflow Legacy Platform",
    "section": "executor",
    "text": "executor\nType: String\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.6.3. Undocumented & stale value"
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#id",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#id",
    "title": "Nextflow Legacy Platform",
    "section": "id",
    "text": "id\nType: String\nEvery platform can be given a specific id that can later be referred to explicitly when running or building the Viash component."
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#image",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#image",
    "title": "Nextflow Legacy Platform",
    "section": "image",
    "text": "image\nType: String\nIf no image attributes are configured, Viash will use the auto-generated image name from the Docker platform:\n[<namespace>/]<name>:<version>\nIt’s possible to specify the container image explicitly with which to run the module in different ways:\nimage: dataintuitive/viash:0.4.0\nExactly the same can be obtained with\nimage: dataintuitive/viash\nregistry: index.docker.io/v1/\ntag: 0.4.0\nSpecifying the attribute(s) like this will use the container dataintuitive/viash:0.4.0 from Docker hub (registry).\nIf no tag is specified Viash will use functionality.version as the tag.\nIf no registry is specified, Viash (and NextFlow) will assume the image is available locally or on Docker Hub. In other words, the registry: ... attribute above is superfluous. No other registry is checked automatically due to a limitation from Docker itself."
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#label",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#label",
    "title": "Nextflow Legacy Platform",
    "section": "label",
    "text": "label\nType: String\nWhen running the module in a cluster context and depending on the cluster type, NextFlow allows for attaching labels to the process that can later be used as selectors for associating resources to this process.\nIn order to attach one label to a process/component, one can use the label: ... attribute, multiple labels can be added using labels: [ ..., ... ] and the two can even be mixed.\nIn the main nextflow.config, one can now use this label:\nprocess { … withLabel: bigmem { maxForks = 5 … } }\nExample:\nlabel: highmem labels: [ highmem, highcpu ]"
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#labels",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#labels",
    "title": "Nextflow Legacy Platform",
    "section": "labels",
    "text": "labels\nType: String / List of String\nWhen running the module in a cluster context and depending on the cluster type, NextFlow allows for attaching labels to the process that can later be used as selectors for associating resources to this process.\nIn order to attach one label to a process/component, one can use the label: ... attribute, multiple labels can be added using labels: [ ..., ... ] and the two can even be mixed.\nIn the main nextflow.config, one can now use this label:\nprocess { … withLabel: bigmem { maxForks = 5 … } }\nExample:\nlabel: highmem labels: [ highmem, highcpu ]"
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#namespace_separator",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#namespace_separator",
    "title": "Nextflow Legacy Platform",
    "section": "namespace_separator",
    "text": "namespace_separator\nType: String\nThe default namespace separator is “_“.\nExample:\nnamespace_separator: \"+\""
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#organization",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#organization",
    "title": "Nextflow Legacy Platform",
    "section": "organization",
    "text": "organization\nType: String\nName of a container’s organization.\nExample:\norganization: viash-io"
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#path",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#path",
    "title": "Nextflow Legacy Platform",
    "section": "path",
    "text": "path\nType: String\nWhen publish: true, this attribute defines where the output is written relative to the params.publishDir setting. For example, path: processed in combination with --output s3://some_bucket/ will store the output of this component under\ns3://some_bucket/processed/\nThis attribute gives control over the directory structure of the output. For example:\npath: raw_data\nOr even:\npath: raw_data/bcl\nPlease note that per_id and path can be combined."
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#per_id",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#per_id",
    "title": "Nextflow Legacy Platform",
    "section": "per_id",
    "text": "per_id\nType: Boolean\nBy default, a subdirectory is created corresponding to the unique ID that is passed in the triplet. Let us illustrate this with an example. The following code snippet uses the value of --input as an input of a workflow. The input can include a wildcard so that multiple samples can run in parallel. We use the parent directory name (.getParent().baseName) as an identifier for the sample. We pass this as the first entry of the triplet:\nChannel.fromPath(params.input) \\\n    | map{ it -> [ it.getParent().baseName , it ] } \\\n    | map{ it -> [ it[0] , it[1], params ] }\n    | ...\nSay the resulting sample names are SAMPLE1 and SAMPLE2. The next step in the pipeline will be published (at least by default) under:\n<publishDir>/SAMPLE1/\n<publishDir>/SAMPLE2/\nThese per-ID subdirectories can be avoided by setting:\nper_id: false"
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#publish",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#publish",
    "title": "Nextflow Legacy Platform",
    "section": "publish",
    "text": "publish\nType: Boolean\nNextFlow uses the autogenerated work dirs to manage process IO under the hood. In order effectively output something one can publish the results a module or step in the pipeline. In order to do this, add publish: true to the config:\n\npublish is optional\nDefault value is false\n\nThis attribute simply defines if output of a component should be published yes or no. The output location has to be provided at pipeline launch by means of the option --publishDir ... or as params.publishDir in nextflow.config:\nparams.publishDir = \"...\""
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#registry",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#registry",
    "title": "Nextflow Legacy Platform",
    "section": "registry",
    "text": "registry\nType: String\nThe URL to the a custom Docker registry.\nExample:\nregistry: https://my-docker-registry.org"
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#separate_multiple_outputs",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#separate_multiple_outputs",
    "title": "Nextflow Legacy Platform",
    "section": "separate_multiple_outputs",
    "text": "separate_multiple_outputs\nType: Boolean\nSeparates the outputs generated by a Nextflow component with multiple outputs as separate events on the channel. Default value: true.\nExample:\nseparate_multiple_outputs: false"
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#stageinmode",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#stageinmode",
    "title": "Nextflow Legacy Platform",
    "section": "stageInMode",
    "text": "stageInMode\nType: String\nBy default NextFlow will create a symbolic link to the inputs for a process/module and run the tool at hand using those symbolic links. Some applications do not cope well with this strategy, in that case the files should effectively be copied rather than linked to. This can be achieved by using stageInMode: copy. This attribute is optional, the default is symlink.\nExample:\nstageInMode: copy"
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#tag",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#tag",
    "title": "Nextflow Legacy Platform",
    "section": "tag",
    "text": "tag\nType: String\nSpecify a Docker image based on its tag.\nExample:\ntag: 4.0"
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#type",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#type",
    "title": "Nextflow Legacy Platform",
    "section": "type",
    "text": "type\nType: String\nSpecifies the type of the platform."
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#version",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#version",
    "title": "Nextflow Legacy Platform",
    "section": "version",
    "text": "version\nType: String\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.4.0. nextflow platform: attribute ‘version’ is deprecated and should be left empty."
  },
  {
    "objectID": "reference/config/platforms/NextflowVdsl3Platform.html",
    "href": "reference/config/platforms/NextflowVdsl3Platform.html",
    "title": "Nextflow Vdsl3 Platform",
    "section": "",
    "text": "Next-gen platform for generating NextFlow VDSL3 modules."
  },
  {
    "objectID": "reference/config/platforms/NextflowVdsl3Platform.html#auto",
    "href": "reference/config/platforms/NextflowVdsl3Platform.html#auto",
    "title": "Nextflow Vdsl3 Platform",
    "section": "auto",
    "text": "auto\nType: NextflowAuto\nAutomated processing flags which can be toggled on or off:\n\n\n\n\n\n\n\n\nFlag\nDescription\nDefault\n\n\n\n\nsimplifyInput\nIf true, an input tuple only containing only a single File (e.g. [\"foo\", file(\"in.h5ad\")]) is automatically transformed to a map (i.e. [\"foo\", [ input: file(\"in.h5ad\") ] ]).\ntrue\n\n\nsimplifyOutput\nIf true, an output tuple containing a map with a File (e.g. [\"foo\", [ output: file(\"out.h5ad\") ] ]) is automatically transformed to a map (i.e. [\"foo\", file(\"out.h5ad\")]).\ntrue\n\n\ntranscript\nIf true, the module’s transcripts from work/ are automatically published to params.transcriptDir. If not defined, params.publishDir + \"/_transcripts\" will be used. Will throw an error if neither are defined.\nfalse\n\n\npublish\nIf true, the module’s outputs are automatically published to params.publishDir. Will throw an error if params.publishDir is not defined.\nfalse\n\n\n\nExample:\nauto:\n    publish: true"
  },
  {
    "objectID": "reference/config/platforms/NextflowVdsl3Platform.html#container",
    "href": "reference/config/platforms/NextflowVdsl3Platform.html#container",
    "title": "Nextflow Vdsl3 Platform",
    "section": "container",
    "text": "container\nType: String\nSpecifies the Docker platform id to be used to run Nextflow."
  },
  {
    "objectID": "reference/config/platforms/NextflowVdsl3Platform.html#debug",
    "href": "reference/config/platforms/NextflowVdsl3Platform.html#debug",
    "title": "Nextflow Vdsl3 Platform",
    "section": "debug",
    "text": "debug\nType: Boolean\nWhether or not to print debug messages."
  },
  {
    "objectID": "reference/config/platforms/NextflowVdsl3Platform.html#directives",
    "href": "reference/config/platforms/NextflowVdsl3Platform.html#directives",
    "title": "Nextflow Vdsl3 Platform",
    "section": "directives",
    "text": "directives\nType: NextflowDirectives\nDirectives are optional settings that affect the execution of the process. These mostly match up with the Nextflow counterparts that are linked below:\n\naccelerator\nafterScript\nbeforeScript\ncache\nconda\ncontainer\ncontainerOptions\ncpus\ndisk\necho\nerrorStrategy\nexecutor\nmachineType\nmaxErrors\nmaxForks\nmaxRetries\nmemory\nmodule\npenv\npublishDir\nqueue\nscratch\nstoreDir\nstageInMode\nstageOutMode\ntag\ntime\n\nExample:\ndirectives:\n    container: rocker/r-ver:4.1\n    label: highcpu\n    cpus: 4\n    memory: 16 GB"
  },
  {
    "objectID": "reference/config/platforms/NextflowVdsl3Platform.html#id",
    "href": "reference/config/platforms/NextflowVdsl3Platform.html#id",
    "title": "Nextflow Vdsl3 Platform",
    "section": "id",
    "text": "id\nType: String\nEvery platform can be given a specific id that can later be referred to explicitly when running or building the Viash component.\nExample:\nid: foo"
  },
  {
    "objectID": "reference/config/platforms/NextflowVdsl3Platform.html#type",
    "href": "reference/config/platforms/NextflowVdsl3Platform.html#type",
    "title": "Nextflow Vdsl3 Platform",
    "section": "type",
    "text": "type\nType: String\nSpecifies the type of the platform."
  },
  {
    "objectID": "reference/config/config-modding.html",
    "href": "reference/config/config-modding.html",
    "title": "Dynamic Config Modding",
    "section": "",
    "text": "Viash can modify a viash config at runtime using a custom Domain Specific Language (DSL). This allows making dynamic changes to your components or projects.\nAll Viash subcommands have support for the DSL through the -c|--config_mod parameter. The format for these is as follows:\nMultiple config mods can be added by adding more -c|--config_mod parameters:"
  },
  {
    "objectID": "reference/config/config-modding.html#examples",
    "href": "reference/config/config-modding.html#examples",
    "title": "Dynamic Config Modding",
    "section": "Examples",
    "text": "Examples\nChange the version of a component:\nviash build -c '.functionality.version := \"0.3.0\"'\nChange the registry of a docker container:\nviash build -c \\\n  '.platforms[.type == \"docker\"].container_registry := \"url-to-registry\"'\nAdd an author to the list:\nviash build -c '.functionality.authors += { name: \"Mr. T\", role: \"sponsor\" }'\nYou can use dynamic config modding to alter the config of multiple components at once:\nviash ns build \\\n  -c '.functionality.version := \"0.3.0\"' \\\n  -c '.platforms[.type == \"docker\"].container_registry := \"url-to-registry\"' \\\n  -c '.functionality.authors += { name: \"Mr. T\", role: \"sponsor\" }'"
  },
  {
    "objectID": "reference/config/functionality.html",
    "href": "reference/config/functionality.html",
    "title": "Functionality",
    "section": "",
    "text": "The functionality-part of the config file describes the behaviour of the script in terms of arguments and resources. By specifying a few restrictions (e.g. mandatory arguments) and adding some descriptions, Viash will automatically generate a stylish command-line interface for you."
  },
  {
    "objectID": "reference/config/functionality.html#add_resources_to_path",
    "href": "reference/config/functionality.html#add_resources_to_path",
    "title": "Functionality",
    "section": "add_resources_to_path",
    "text": "add_resources_to_path\nType: Boolean\n\n\n\n\n\n\nWarning\n\n\n\nRemoved since Viash 0.5.11. Extending the PATH turned out to be not desirable.\n\n\nAdds the resources directory to the PATH variable when set to true. This is set to false by default."
  },
  {
    "objectID": "reference/config/functionality.html#argument_groups",
    "href": "reference/config/functionality.html#argument_groups",
    "title": "Functionality",
    "section": "argument_groups",
    "text": "argument_groups\nType: List of ArgumentGroup\nA grouping of the arguments, used to display the help message.\n\nname: foo, the name of the argument group.\ndescription: Description of foo, a description of the argument group. Multiline descriptions are supported.\narguments: [arg1, arg2, ...], list of the arguments names.\n\nExample:\nargument_groups:\n  - name: \"Input\"\n    arguments:\n      - name: \"--id\"\n        type: string\n        required: true\n      - name: \"--input\"\n        type: file\n        required: true\n  - name: \"Output\"\n    arguments:\n      - name: \"--output\"\n        type: file\n        direction: output\n        required: true\n      - name: \"--output_optional\"\n        type: file\n        direction: output\nThis results in the following output when calling the component with the --help argument:\ncomponent_name\n\n  Input:\n      --id\n          type: string\n\n      --input\n          type: file\n\n  Output:\n      --output\n          type: file\n\n      --optional_output\n          type: file"
  },
  {
    "objectID": "reference/config/functionality.html#arguments",
    "href": "reference/config/functionality.html#arguments",
    "title": "Functionality",
    "section": "arguments",
    "text": "arguments\nType: List of Argument\nA list of arguments for this component. For each argument, a type and a name must be specified. Depending on the type of argument, different properties can be set. See these reference pages per type for more information:\n\nstring\nfile\ninteger\ndouble\nboolean\nboolean_true\nboolean_false\n\nExample:\narguments:\n   - name: --foo\n    type: file\n    alternatives: [-f]\n    description: Description of foo\n    default: \"/foo/bar\"\n    must_exist: true\n    direction: output\n    required: false\n    multiple: true\n    multiple_sep: \",\"\n   - name: --bar\n    type: string"
  },
  {
    "objectID": "reference/config/functionality.html#authors",
    "href": "reference/config/functionality.html#authors",
    "title": "Functionality",
    "section": "authors",
    "text": "authors\nType: List of Author\nA list of authors. An author must at least have a name, but can also have a list of roles, an e-mail address, and a map of custom properties.\nSuggested values for roles are:\n\n\n\n\n\n\n\n\nRole\nAbbrev.\nDescription\n\n\n\n\nmaintainer\nmnt\nfor the maintainer of the code. Ideally, exactly one maintainer is specified.\n\n\nauthor\naut\nfor persons who have made substantial contributions to the software.\n\n\ncontributor\nctb\nfor persons who have made smaller contributions (such as code patches).\n\n\ndatacontributor\ndtc\nfor persons or organisations that contributed data sets for the software\n\n\ncopyrightholder\ncph\nfor all copyright holders. This is a legal concept so should use the legal name of an institution or corporate body.\n\n\nfunder\nfnd\nfor persons or organizations that furnished financial support for the development of the software\n\n\n\nThe full list of roles is extremely comprehensive.\nExample:\nauthors:\n  - name: Bob Cando\n    roles: [maintainer, author]\n    email: bob@can.do\n    props: {github: bobcando, orcid: 0000-0001-0002-0003}\n  - name: Tim Farbe\n    roles: [author]\n    email: tim@far.be"
  },
  {
    "objectID": "reference/config/functionality.html#description",
    "href": "reference/config/functionality.html#description",
    "title": "Functionality",
    "section": "description",
    "text": "description\nType: String\nA description of the component. This will be displayed with --help.\nExample:\ndescription: |\n  This component performs function Y and Z.\n  It is possible to make this a multiline string."
  },
  {
    "objectID": "reference/config/functionality.html#enabled",
    "href": "reference/config/functionality.html#enabled",
    "title": "Functionality",
    "section": "enabled",
    "text": "enabled\nType: Boolean\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.6.0. Use status instead.\n\n\nSetting this to false with disable this component when using namespaces."
  },
  {
    "objectID": "reference/config/functionality.html#info",
    "href": "reference/config/functionality.html#info",
    "title": "Functionality",
    "section": "info",
    "text": "info\nType: Json\nStructured information. Can be any shape: a string, vector, map or even nested map.\nExample:\ninfo:\n  twitter: wizzkid\n  classes: [ one, two, three ]"
  },
  {
    "objectID": "reference/config/functionality.html#inputs",
    "href": "reference/config/functionality.html#inputs",
    "title": "Functionality",
    "section": "inputs",
    "text": "inputs\nType: List of Argument\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.6.0. Use arguments instead.\n\n\nA list of input arguments in addition to the arguments list. Any arguments specified here will have their type set to file and the direction set to input by default.\nExample:\ninputs:\n  - name: input_file\n  - name: another_input\nThis results in the following output when calling the component with the --help argument:\ncomponent_with_inputs\n  \n  Inputs:\n      input_file\n          type: file\n  \n      another_input\n          type: file"
  },
  {
    "objectID": "reference/config/functionality.html#name",
    "href": "reference/config/functionality.html#name",
    "title": "Functionality",
    "section": "name",
    "text": "name\nType: String\nName of the component and the filename of the executable when built with viash build.\nExample:\nname: this_is_my_component"
  },
  {
    "objectID": "reference/config/functionality.html#namespace",
    "href": "reference/config/functionality.html#namespace",
    "title": "Functionality",
    "section": "namespace",
    "text": "namespace\nType: String\nNamespace this component is a part of. See the Namespaces guide for more information on namespaces.\nExample:\nnamespace: fancy_components"
  },
  {
    "objectID": "reference/config/functionality.html#outputs",
    "href": "reference/config/functionality.html#outputs",
    "title": "Functionality",
    "section": "outputs",
    "text": "outputs\nType: List of Argument\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.6.0. Use arguments instead.\n\n\nA list of output arguments in addition to the arguments list. Any arguments specified here will have their type set to file and thr direction set to output by default.\nExample:\noutputs:\n  - name: output_file\n  - name: another_output\nThis results in the following output when calling the component with the --help argument:\ncomponent_with_outputs\n  \n  Outputs:\n      output_file\n          type: file, output\n  \n      another_output\n          type: file, output"
  },
  {
    "objectID": "reference/config/functionality.html#requirements",
    "href": "reference/config/functionality.html#requirements",
    "title": "Functionality",
    "section": "requirements",
    "text": "requirements\nType: ComputationalRequirements\nComputational requirements related to running the component. cpus specifies the maximum number of (logical) cpus a component is allowed to use., whereas memory specifies the maximum amount of memory a component is allowed to allicate. Memory units must be in B, KB, MB, GB, TB or PB.\nExample:\nrequirements:\n  cpus: 5\n  memory: 10GB"
  },
  {
    "objectID": "reference/config/functionality.html#resources",
    "href": "reference/config/functionality.html#resources",
    "title": "Functionality",
    "section": "resources",
    "text": "resources\nType: List of Resource\nResources are files that support the component. The first resource should be a script that will be executed when the functionality is run. Additional resources will be copied to the same directory.\nCommon properties:\n\ntype: file / r_script / python_script / bash_script / javascript_script / scala_script / csharp_script, the type of resource. The first resource cannot be of type file. When the type is not specified, the default type is simply file.\nname: filename, the resulting name of the resource.\npath: path/to/file, the path of the input file. Can be a relative or an absolute path, or a URI.\ntext: …multiline text…, the raw content of the input file. Exactly one of path or text must be defined, the other undefined.\nis_executable: true / false, whether the resulting file is made executable.\n\nExample:\nresources:\n  - type: r_script\n    path: script.R\n  - type: file\n    path: resource1.txt"
  },
  {
    "objectID": "reference/config/functionality.html#status",
    "href": "reference/config/functionality.html#status",
    "title": "Functionality",
    "section": "status",
    "text": "status\nType: Status\nAllows setting a component to active, deprecated or disabled."
  },
  {
    "objectID": "reference/config/functionality.html#test_resources",
    "href": "reference/config/functionality.html#test_resources",
    "title": "Functionality",
    "section": "test_resources",
    "text": "test_resources\nType: List of Resource\nOne or more scripts to be used to test the component behaviour when viash test is invoked. Additional files of type file will be made available only during testing. Each test script should expect no command-line inputs, be platform-independent, and return an exit code >0 when unexpected behaviour occurs during testing. See Unit Testing for more info.\nExample:\ntest_resources:\n  - type: bash_script\n    path: tests/test1.sh\n  - type: r_script\n    path: tests/test2.R\n  - path: resource1.txt"
  },
  {
    "objectID": "reference/config/functionality.html#tests",
    "href": "reference/config/functionality.html#tests",
    "title": "Functionality",
    "section": "tests",
    "text": "tests\nType: List of Resource\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.5.13. Use test_resources instead. No functional difference.\n\n\nOne or more Bash/R/Python scripts to be used to test the component behaviour when viash test is invoked. Additional files of type file will be made available only during testing. Each test script should expect no command-line inputs, be platform-independent, and return an exit code >0 when unexpected behaviour occurs during testing."
  },
  {
    "objectID": "reference/config/functionality.html#usage",
    "href": "reference/config/functionality.html#usage",
    "title": "Functionality",
    "section": "usage",
    "text": "usage\nType: String\nA description on how to use the component. This will be displayed with --help under the ‘Usage:’ section.\nExample:\nusage: Place the executable in a directory containing TSV files and run it"
  },
  {
    "objectID": "reference/config/functionality.html#version",
    "href": "reference/config/functionality.html#version",
    "title": "Functionality",
    "section": "version",
    "text": "version\nType: String\nVersion of the component. This field will be used to version the executable and the Docker container.\nExample:\nversion: 0.8"
  },
  {
    "objectID": "reference/config/requirements.html",
    "href": "reference/config/requirements.html",
    "title": "Setup Requirements",
    "section": "",
    "text": "Specify which apk packages should be available in order to run the component.\nExample:\nsetup:\n  - type: apk\n    packages: [ sl ]\n\n\nType: String / List of String\nSpecifies which packages to install.\nExample:\npackages: [ sl ]\n\n\n\nType: String\nSpecifies the type of the requirement specification."
  },
  {
    "objectID": "reference/config/requirements.html#apt-requirements",
    "href": "reference/config/requirements.html#apt-requirements",
    "title": "Setup Requirements",
    "section": "Apt Requirements",
    "text": "Apt Requirements\nSpecify which apt packages should be available in order to run the component.\nExample:\nsetup:\n  - type: apt\n    packages: [ sl ]\n\ninteractive\nType: Boolean\nIf false, the Debian frontend is set to non-interactive (recommended). Default: false.\n\n\npackages\nType: String / List of String\nSpecifies which packages to install.\nExample:\npackages: [ sl ]\n\n\ntype\nType: String\nSpecifies the type of the requirement specification."
  },
  {
    "objectID": "reference/config/requirements.html#docker-requirements",
    "href": "reference/config/requirements.html#docker-requirements",
    "title": "Setup Requirements",
    "section": "Docker Requirements",
    "text": "Docker Requirements\nSpecify which Docker commands should be run during setup.\nExample:\nsetup:\n  - type: docker\n    build_args: \"R_VERSION=hello_world\"\n    run: |\n      echo 'Run a custom command'\n      echo 'Foo' > /path/to/file.txt\n\nadd\nType: String / List of String\nSpecifies which ADD entries to add to the Dockerfile while building it.\nExample:\nadd: [ \"http://foo/bar .\" ]\n\n\nbuild_args\nType: String / List of String\nSpecifies which ARG entries to add to the Dockerfile while building it.\nExample:\nbuild_args: [ \"R_VERSION=4.2\" ]\n\n\ncopy\nType: String / List of String\nSpecifies which COPY entries to add to the Dockerfile while building it.\nExample:\ncopy: [ \"resource.txt /path/to/resource.txt\" ]\n\n\nenv\nType: String / List of String\nSpecifies which ENV entries to add to the Dockerfile while building it. Unlike ARG, ENV entries are also accessible from inside the container.\nExample:\nenv: [ \"R_VERSION=4.2\" ]\n\n\nlabel\nType: String / List of String\nSpecifies which LABEL entries to add to the Dockerfile while building it.\nExample:\nlabel: [ component=\"foo\" ]\n\n\nresources\nType: String / List of String\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.6.3. Use copy instead.\n\n\nSpecifies which COPY entries to add to the Dockerfile while building it.\nExample:\nresources: [ \"resource.txt /path/to/resource.txt\" ]\n\n\nrun\nType: String / List of String\nSpecifies which RUN entries to add to the Dockerfile while building it.\nExample:\nrun: |\n  echo 'Run a custom command'\n  echo 'Foo' > /path/to/file.txt\n\n\ntype\nType: String\nSpecifies the type of the requirement specification."
  },
  {
    "objectID": "reference/config/requirements.html#javascript-requirements",
    "href": "reference/config/requirements.html#javascript-requirements",
    "title": "Setup Requirements",
    "section": "Javascript Requirements",
    "text": "Javascript Requirements\nSpecify which JavaScript packages should be available in order to run the component.\nExample:\nsetup:\n  - type: javascript\n    npm: packagename\n    git: \"https://some.git.repository/org/repo\"\n    github: \"owner/repository\"\n    url: \"https://github.com/org/repo/archive/HEAD.zip\"\n\ngit\nType: String / List of String\nSpecifies which packages to install using a Git URI.\nExample:\ngit: [ https://some.git.repository/org/repo ]\n\n\ngithub\nType: String / List of String\nSpecifies which packages to install from GitHub.\nExample:\ngithub: [ owner/repository ]\n\n\nnpm\nType: String / List of String\nSpecifies which packages to install from npm.\nExample:\nnpm: [ packagename ]\n\n\npackages\nType: String / List of String\nSpecifies which packages to install from npm.\nExample:\npackages: [ packagename ]\n\n\ntype\nType: String\nSpecifies the type of the requirement specification.\n\n\nurl\nType: String / List of String\nSpecifies which packages to install using a generic URI.\nExample:\nurl: [ https://github.com/org/repo/archive/HEAD.zip ]"
  },
  {
    "objectID": "reference/config/requirements.html#python-requirements",
    "href": "reference/config/requirements.html#python-requirements",
    "title": "Setup Requirements",
    "section": "Python Requirements",
    "text": "Python Requirements\nSpecify which Python packages should be available in order to run the component.\nExample:\nsetup:\n  - type: python\n    pip: numpy\n    github: [ jkbr/httpie, foo/bar ]\n    url: \"https://github.com/some_org/some_pkg/zipball/master\"\n\nbazaar\nType: String / List of String\nSpecifies which packages to install using a Bazaar URI.\nExample:\nbazaar: [ http://bazaar.launchpad.net/some_pkg/some_pkg/release-0.1 ]\n\n\ngit\nType: String / List of String\nSpecifies which packages to install using a Git URI.\nExample:\ngit: [ https://some.git.repository/org/repo ]\n\n\ngithub\nType: String / List of String\nSpecifies which packages to install from GitHub.\nExample:\ngithub: [ jkbr/httpie ]\n\n\ngitlab\nType: String / List of String\nSpecifies which packages to install from GitLab.\nExample:\ngitlab: [ foo/bar ]\n\n\nmercurial\nType: String / List of String\nSpecifies which packages to install using a Mercurial URI.\nExample:\nmercurial: [ https://hg.myproject.org/MyProject/#egg=MyProject ]\n\n\npackages\nType: String / List of String\nSpecifies which packages to install from pip.\nExample:\npackages: [ numpy ]\n\n\npip\nType: String / List of String\nSpecifies which packages to install from pip.\nExample:\npip: [ numpy ]\n\n\npypi\nType: String / List of String\nSpecifies which packages to install from PyPI using pip.\nExample:\npypi: [ numpy ]\n\n\nscript\nType: String / List of String\nSpecifies a code block to run as part of the build.\nExample:\nscript: |\n  print(\"Running custom code\")\n  x = 1 + 1 == 2\n\n\nsvn\nType: String / List of String\nSpecifies which packages to install using an SVN URI.\nExample:\nsvn: [ http://svn.repo/some_pkg/trunk/#egg=SomePackage ]\n\n\ntype\nType: String\nSpecifies the type of the requirement specification.\n\n\nupgrade\nType: Boolean\nSets the --upgrade flag when set to true. Default: true.\n\n\nurl\nType: String / List of String\nSpecifies which packages to install using a generic URI.\nExample:\nurl: [ https://github.com/some_org/some_pkg/zipball/master ]\n\n\nuser\nType: Boolean\nSets the --user flag when set to true. Default: false."
  },
  {
    "objectID": "reference/config/requirements.html#r-requirements",
    "href": "reference/config/requirements.html#r-requirements",
    "title": "Setup Requirements",
    "section": "R Requirements",
    "text": "R Requirements\nSpecify which R packages should be available in order to run the component.\nExample:\nsetup: \n  - type: r\n    cran: anndata\n    bioc: [ AnnotationDbi, SingleCellExperiment ]\n    github: rcannood/SCORPIUS\n\nbioc\nType: String / List of String\nSpecifies which packages to install from BioConductor.\nExample:\nbioc: [ AnnotationDbi ]\n\n\nbioc_force_install\nType: Boolean\nForces packages specified in bioc to be reinstalled, even if they are already present in the container. Default: false.\nExample:\nbioc_force_install: false\n\n\nbitbucket\nType: String / List of String\nSpecifies which packages to install from Bitbucket.\nExample:\nbitbucket: [ org/package ]\n\n\ncran\nType: String / List of String\nSpecifies which packages to install from CRAN.\nExample:\ncran: [ anndata, ggplot2 ]\n\n\ngit\nType: String / List of String\nSpecifies which packages to install using a Git URI.\nExample:\ngit: [ https://some.git.repository/org/repo ]\n\n\ngithub\nType: String / List of String\nSpecifies which packages to install from GitHub.\nExample:\ngithub: [ rcannood/SCORPIUS ]\n\n\ngitlab\nType: String / List of String\nSpecifies which packages to install from GitLab.\nExample:\ngitlab: [ org/package ]\n\n\npackages\nType: String / List of String\nSpecifies which packages to install from CRAN.\nExample:\npackages: [ anndata, ggplot2 ]\n\n\nscript\nType: String / List of String\nSpecifies a code block to run as part of the build.\nExample:\nscript: |\n  cat(\"Running custom code\n\")\n  install.packages(\"anndata\")\n\n\nsvn\nType: String / List of String\nSpecifies which packages to install using an SVN URI.\nExample:\nsvn: [ https://path.to.svn/group/repo ]\n\n\ntype\nType: String\nSpecifies the type of the requirement specification.\n\n\nurl\nType: String / List of String\nSpecifies which packages to install using a generic URI.\nExample:\nurl: [ https://github.com/hadley/stringr/archive/HEAD.zip ]"
  },
  {
    "objectID": "reference/config/requirements.html#ruby-requirements",
    "href": "reference/config/requirements.html#ruby-requirements",
    "title": "Setup Requirements",
    "section": "Ruby Requirements",
    "text": "Ruby Requirements\nSpecify which Ruby packages should be available in order to run the component.\nExample:\nsetup:\n  - type: ruby\n    packages: [ rspec ]\n\npackages\nType: String / List of String\nSpecifies which packages to install.\nExample:\npackages: [ rspec ]\n\n\ntype\nType: String\nSpecifies the type of the requirement specification."
  },
  {
    "objectID": "reference/config/requirements.html#yum-requirements",
    "href": "reference/config/requirements.html#yum-requirements",
    "title": "Setup Requirements",
    "section": "Yum Requirements",
    "text": "Yum Requirements\nSpecify which yum packages should be available in order to run the component.\nExample:\nsetup:\n  - type: yum\n    packages: [ sl ]\n\npackages\nType: String / List of String\nSpecifies which packages to install.\nExample:\npackages: [ sl ]\n\n\ntype\nType: String\nSpecifies the type of the requirement specification."
  },
  {
    "objectID": "reference/config/index.html",
    "href": "reference/config/index.html",
    "title": "Overview",
    "section": "",
    "text": "A Viash configuration is a YAML file which contains metadata to describe the behaviour and build target(s) of a component.\nWe commonly name this file config.vsh.yaml in our examples, but you can name it however you choose.\nHere’s an example of a config file:\nEvery Viash config consists of two main sections: functionality and platforms."
  },
  {
    "objectID": "reference/config/index.html#functionality",
    "href": "reference/config/index.html#functionality",
    "title": "Overview",
    "section": "Functionality",
    "text": "Functionality\nThe functionality section describes the behaviour of the component. This includes a name, a description and the arguments and resources the component needs to function.\nCheck out our Arguments section on the left to find out more about the supported arguments. The External Resources guide contains information on how to add resources and use them."
  },
  {
    "objectID": "reference/config/index.html#platforms",
    "href": "reference/config/index.html#platforms",
    "title": "Overview",
    "section": "Platforms",
    "text": "Platforms\nThe platforms section specifies what platforms are supported as build targets for a component and their requirements. We support native, Docker and Nextflow. If no platforms are specified, the native platform is used by default."
  },
  {
    "objectID": "reference/viash/test.html",
    "href": "reference/viash/test.html",
    "title": "viash test",
    "section": "",
    "text": "Test the component using the tests defined in the viash config file.\nUsage:\nviash test config.vsh.yaml [-p docker] [-k true/false]\n\n\n\nArgument\nDescription\nType\n\n\n\n\nconfig\nA viash config file (example: config.vsh.yaml). This argument can also be a script with the config as a header. This is a required argument.\nString\n\n\n--config_mod, -c\nModify a viash config at runtime using dynamic config modding.\nList[String]\n\n\n--cpus\nThe maximum number of (logical) cpus a component is allowed to use.\nInt\n\n\n--keep, -k\nWhether or not to keep temporary files. By default, files will be deleted if all goes well but remain when an error occurs. By specifying –keep true, the temporary files will always be retained, whereas –keep false will always delete them. The temporary directory can be overwritten by setting defining a VIASH_TEMP directory.\nString\n\n\n--memory\nThe maximum amount of memory a component is allowed to allocate. Unit must be one of B, KB, MB, GB, TB or PB.\nString\n\n\n--platform, -p\nSpecifies which platform amongst those specified in the config to use. If this is not provided, the first platform will be used. If no platforms are defined in the config, the native platform will be used. In addition, the path to a platform yaml file can also be specified.\nString\n\n\n--help, -h\nShow help message"
  },
  {
    "objectID": "reference/viash/ns.html",
    "href": "reference/viash/ns.html",
    "title": "viash ns",
    "section": "",
    "text": "Build a namespace from many viash config files.\nUsage:\nviash ns build [-n nmspc] [-s src] [-t target] [-p docker] [--setup] [---push] [--parallel] [--flatten]\n\n\n\nArgument\nDescription\nType\n\n\n\n\n--config_mod, -c\nModify a viash config at runtime using dynamic config modding.\nList[String]\n\n\n--flatten, -f\nFlatten the target builds, handy for building one platform to a bin directory.\nBoolean\n\n\n--parallel, -l\nWhether or not to run the process in parallel.\nBoolean\n\n\n--platform, -p\nActs as a regular expression to filter the platform ids specified in the found config files. If this is not provided, all platforms will be used. If no platforms are defined in a config, the native platform will be used. In addition, the path to a platform yaml file can also be specified.\nString\n\n\n--push\nWhether or not to push the container to a Docker registry [Docker Platform only].\nBoolean\n\n\n--query, -q\nFilter which components get selected by component and namespace name. Can be a regex. Example: “^mynamespace/component1$”.\nString\n\n\n--query_name\nFilter which components get selected by component name. Can be a regex. Example: “^component1”.\nString\n\n\n--query_namespace, -n\nFilter which namespaces get selected by namespace name. Can be a regex. Example: “^mynamespace$”.\nString\n\n\n--setup\nWhich setup strategy for creating the container to use [Docker Platform only].\nString\n\n\n--src, -s\nA source directory containing viash config files, possibly structured in a hierarchical folder structure. Default: src/.\nString\n\n\n--target, -t\nA target directory to build the executables into. Default: target/.\nString\n\n\n--write_meta, -w\nWrite out some meta information to RESOURCES_DIR/viash.yaml at the end.\nBoolean\n\n\n--help, -h\nShow help message"
  },
  {
    "objectID": "reference/viash/ns.html#viash-ns-test",
    "href": "reference/viash/ns.html#viash-ns-test",
    "title": "viash ns",
    "section": "viash ns test",
    "text": "viash ns test\nTest a namespace containing many viash config files.\nUsage:\nviash ns test [-n nmspc] [-s src] [-p docker] [--parallel] [--tsv file.tsv] [--append]\n\n\n\nArgument\nDescription\nType\n\n\n\n\n--append, -a\nAppend to tsv instead of overwrite\nBoolean\n\n\n--config_mod, -c\nModify a viash config at runtime using dynamic config modding.\nList[String]\n\n\n--cpus\nThe maximum number of (logical) cpus a component is allowed to use.\nInt\n\n\n--keep, -k\nWhether or not to keep temporary files. By default, files will be deleted if all goes well but remain when an error occurs. By specifying –keep true, the temporary files will always be retained, whereas –keep false will always delete them. The temporary directory can be overwritten by setting defining a VIASH_TEMP directory.\nString\n\n\n--memory\nThe maximum amount of memory a component is allowed to allocate. Unit must be one of B, KB, MB, GB, TB or PB.\nString\n\n\n--parallel, -l\nWhether or not to run the process in parallel.\nBoolean\n\n\n--platform, -p\nActs as a regular expression to filter the platform ids specified in the found config files. If this is not provided, all platforms will be used. If no platforms are defined in a config, the native platform will be used. In addition, the path to a platform yaml file can also be specified.\nString\n\n\n--query, -q\nFilter which components get selected by component and namespace name. Can be a regex. Example: “^mynamespace/component1$”.\nString\n\n\n--query_name\nFilter which components get selected by component name. Can be a regex. Example: “^component1”.\nString\n\n\n--query_namespace, -n\nFilter which namespaces get selected by namespace name. Can be a regex. Example: “^mynamespace$”.\nString\n\n\n--src, -s\nA source directory containing viash config files, possibly structured in a hierarchical folder structure. Default: src/.\nString\n\n\n--tsv, -t\nPath to write a summary of the test results to.\nString\n\n\n--help, -h\nShow help message"
  },
  {
    "objectID": "reference/viash/ns.html#viash-ns-list",
    "href": "reference/viash/ns.html#viash-ns-list",
    "title": "viash ns",
    "section": "viash ns list",
    "text": "viash ns list\nList a namespace containing many viash config files.\nUsage:\nviash ns list [-n nmspc] [-s src] [-p docker]\n\n\n\nArgument\nDescription\nType\n\n\n\n\n--config_mod, -c\nModify a viash config at runtime using dynamic config modding.\nList[String]\n\n\n--format, -f\nWhich output format to use.\nString\n\n\n--parallel, -l\nWhether or not to run the process in parallel.\nBoolean\n\n\n--parse_argument_groups\nWhether or not to postprocess each component’s argument groups.\nBoolean\n\n\n--platform, -p\nActs as a regular expression to filter the platform ids specified in the found config files. If this is not provided, all platforms will be used. If no platforms are defined in a config, the native platform will be used. In addition, the path to a platform yaml file can also be specified.\nString\n\n\n--query, -q\nFilter which components get selected by component and namespace name. Can be a regex. Example: “^mynamespace/component1$”.\nString\n\n\n--query_name\nFilter which components get selected by component name. Can be a regex. Example: “^component1”.\nString\n\n\n--query_namespace, -n\nFilter which namespaces get selected by namespace name. Can be a regex. Example: “^mynamespace$”.\nString\n\n\n--src, -s\nA source directory containing viash config files, possibly structured in a hierarchical folder structure. Default: src/.\nString\n\n\n--help, -h\nShow help message"
  },
  {
    "objectID": "reference/viash/ns.html#viash-ns-exec",
    "href": "reference/viash/ns.html#viash-ns-exec",
    "title": "viash ns",
    "section": "viash ns exec",
    "text": "viash ns exec\nExecute a command for all found Viash components. The syntax of this command is inspired by find . -exec echo {} \\;.\nThe following fields are automatically replaced:\n\n{} | {path}: path to the config file\n{abs-path}: absolute path to the config file\n{dir}: path to the parent directory of the config file\n{abs-dir}: absolute path to the directory of the config file\n{main-script}: path to the main script (if any)\n{abs-main-script}: absolute path to the main script (if any)\n{functionality-name}: name of the component\n{namespace}: namespace of the component\n{platform}: selected platform id (only when –apply_platform is used)\n\nA command suffixed by \\; (or nothing) will execute one command for each of the Viash components, whereas a command suffixed by + will execute one command for all Viash components.\nUsage:\nviash ns exec 'echo {path} \\\\;'\nviash ns exec 'chmod +x {main-script} +'\n\n\n\n\n\n\n\n\nArgument\nDescription\nType\n\n\n\n\n--apply_platform, -a\nFills in the {platform} field by applying each platform to the config separately.\n\n\n\n\nNote that this results in the provided command being applied once for every platform that matches the –platform regex. | Boolean | | --cmd | The command to execute for each viash config file in the namespace. This is a required argument. | String | | --config_mod, -c | Modify a viash config at runtime using dynamic config modding. | List[String] | | --dry_run, -d | Perform a dry run. | Boolean | | --parallel, -l | Whether or not to run the process in parallel. | Boolean | | --platform, -p | Acts as a regular expression to filter the platform ids specified in the found config files. If this is not provided, all platforms will be used. If no platforms are defined in a config, the native platform will be used. In addition, the path to a platform yaml file can also be specified. | String | | --query, -q | Filter which components get selected by component and namespace name. Can be a regex. Example: “^mynamespace/component1$”. | String | | --query_name | Filter which components get selected by component name. Can be a regex. Example: “^component1”. | String | | --query_namespace, -n | Filter which namespaces get selected by namespace name. Can be a regex. Example: “^mynamespace$”. | String | | --src, -s | A source directory containing viash config files, possibly structured in a hierarchical folder structure. Default: src/. | String | | --help, -h | Show help message | |"
  },
  {
    "objectID": "reference/viash/run.html",
    "href": "reference/viash/run.html",
    "title": "viash run",
    "section": "",
    "text": "Executes a viash component from the provided viash config file. viash generates a temporary executable and immediately executes it with the given parameters.\nUsage:\nviash run config.vsh.yaml [-p docker] [-k true/false]  -- [arguments for script]\n\n\n\nArgument\nDescription\nType\n\n\n\n\nconfig\nA viash config file (example: config.vsh.yaml). This argument can also be a script with the config as a header. This is a required argument.\nString\n\n\n--config_mod, -c\nModify a viash config at runtime using dynamic config modding.\nList[String]\n\n\n--cpus\nThe maximum number of (logical) cpus a component is allowed to use.\nInt\n\n\n--keep, -k\nWhether or not to keep temporary files. By default, files will be deleted if all goes well but remain when an error occurs. By specifying –keep true, the temporary files will always be retained, whereas –keep false will always delete them. The temporary directory can be overwritten by setting defining a VIASH_TEMP directory.\nString\n\n\n--memory\nThe maximum amount of memory a component is allowed to allocate. Unit must be one of B, KB, MB, GB, TB or PB.\nString\n\n\n--platform, -p\nSpecifies which platform amongst those specified in the config to use. If this is not provided, the first platform will be used. If no platforms are defined in the config, the native platform will be used. In addition, the path to a platform yaml file can also be specified.\nString\n\n\n--help, -h\nShow help message"
  },
  {
    "objectID": "reference/viash/build.html",
    "href": "reference/viash/build.html",
    "title": "viash build",
    "section": "",
    "text": "Build an executable from the provided viash config file.\nUsage:\nviash build config.vsh.yaml -o output [-p docker] [-m] [-s]\n\n\n\nArgument\nDescription\nType\n\n\n\n\nconfig\nA viash config file (example: config.vsh.yaml). This argument can also be a script with the config as a header. This is a required argument.\nString\n\n\n--config_mod, -c\nModify a viash config at runtime using dynamic config modding.\nList[String]\n\n\n--meta, -m\nPrint out some meta information at the end.\nBoolean\n\n\n--output, -o\nPath to directory in which the executable and any resources is built to. Default: “output/”. This is a required argument.\nString\n\n\n--platform, -p\nSpecifies which platform amongst those specified in the config to use. If this is not provided, the first platform will be used. If no platforms are defined in the config, the native platform will be used. In addition, the path to a platform yaml file can also be specified.\nString\n\n\n--push\nWhether or not to push the container to a Docker registry [Docker Platform only].\nBoolean\n\n\n--setup, -s\nWhich setup strategy for creating the container to use [Docker Platform only].\nString\n\n\n--write_meta, -w\nWrite out some meta information to RESOURCES_DIR/viash.yaml at the end.\nBoolean\n\n\n--help, -h\nShow help message"
  },
  {
    "objectID": "reference/viash/config.html",
    "href": "reference/viash/config.html",
    "title": "viash config",
    "section": "",
    "text": "View the config file after parsing.\nUsage:\nviash config view config.vsh.yaml\n\n\n\nArgument\nDescription\nType\n\n\n\n\nconfig\nA viash config file (example: config.vsh.yaml). This argument can also be a script with the config as a header. This is a required argument.\nString\n\n\n--config_mod, -c\nModify a viash config at runtime using dynamic config modding.\nList[String]\n\n\n--format, -f\nWhich output format to use.\nString\n\n\n--parse_argument_groups\nWhether or not to postprocess each component’s argument groups.\nBoolean\n\n\n--platform, -p\nSpecifies which platform amongst those specified in the config to use. If this is not provided, the first platform will be used. If no platforms are defined in the config, the native platform will be used. In addition, the path to a platform yaml file can also be specified.\nString\n\n\n--help, -h\nShow help message"
  },
  {
    "objectID": "reference/viash/config.html#viash-config-inject",
    "href": "reference/viash/config.html#viash-config-inject",
    "title": "viash config",
    "section": "viash config inject",
    "text": "viash config inject\nInject a Viash header into the main script of a Viash component.\nUsage:\nviash config inject config.vsh.yaml\n\n\n\nArgument\nDescription\nType\n\n\n\n\nconfig\nA viash config file (example: config.vsh.yaml). This argument can also be a script with the config as a header. This is a required argument.\nString\n\n\n--config_mod, -c\nModify a viash config at runtime using dynamic config modding.\nList[String]\n\n\n--platform, -p\nSpecifies which platform amongst those specified in the config to use. If this is not provided, the first platform will be used. If no platforms are defined in the config, the native platform will be used. In addition, the path to a platform yaml file can also be specified.\nString\n\n\n--help, -h\nShow help message"
  },
  {
    "objectID": "quickstart/index.html",
    "href": "quickstart/index.html",
    "title": "Quickstart",
    "section": "",
    "text": "This tutorial will guide you through using our Viash template project to run a data pipeline."
  },
  {
    "objectID": "quickstart/index.html#requirements",
    "href": "quickstart/index.html#requirements",
    "title": "Quickstart",
    "section": "Requirements",
    "text": "Requirements\nThis guide assumes you’ve already installed Viash, Docker and Nextflow."
  },
  {
    "objectID": "quickstart/index.html#what-is-viash",
    "href": "quickstart/index.html#what-is-viash",
    "title": "Quickstart",
    "section": "What is Viash?",
    "text": "What is Viash?\nViash is a script code wrapper for building modular software components that serve as building blocks to develop (Nextflow) data pipelines. All you need is your script and a metadata file to get started.\nHere are a few of Viash’s key features:\n\nYou can use your preferred scripting language per component, and mix and match scripts between multiple components as you please. Supported languages include: Bash, Python, R, Scala, JS and C#.\nA custom Docker container is automatically generated based on your dependencies described in your metadata. No expert Docker knowledge is required.\nViash generates a Nextflow module from your script. No expert Nextflow knowledge is required.\nYou can simply script the nextflow modules to create and run your scalable and reproducible data pipeline.\nYou can test every single module on your local workstation through the built-in development kit."
  },
  {
    "objectID": "quickstart/index.html#quickstart-example-project",
    "href": "quickstart/index.html#quickstart-example-project",
    "title": "Quickstart",
    "section": "Quickstart example project",
    "text": "Quickstart example project\nThis page helps you get started with creating scalable and reproducible Nextflow data pipelines. Here’s the flow of the pipeline you’ll be using:\n\n\n\n\ngraph LR\n   A(file?.tsv) --> B[/remove_comments/]\n   B --> C[/take_column/]\n   C --> D[/combine_columns/]\n   D --> E(output)\n\n\n\n\n\n\n\n\nOne or more TSV files are taken as the input and will be processed through a series of modules. At the end, the output is written away to a folder."
  },
  {
    "objectID": "quickstart/index.html#step-1-get-the-template",
    "href": "quickstart/index.html#step-1-get-the-template",
    "title": "Quickstart",
    "section": "Step 1: Get the template",
    "text": "Step 1: Get the template\nTo get up and running fast, we provide a template project for you to use.\n\nUse GitHub templateZip download\n\n\nFirst create a new repository by clicking the “Use this template” button in the viash_project_template repository or clicking the button below.\nUse project template\nThen clone the repository using the following command.\ngit clone https://github.com/youruser/my_first_pipeline.git\n\n\nClick the button below to download a zip file containing the template project. Once downloaded, unzip the file and rename the root directory to my_first_pipeline.\nDownload template\n\n\n\nThe template repo contains the following files:\n.\n├── LICENSE.md                            License information\n├── README.qmd                            The source qmd file for this readme\n├── README.md                             This readme\n├── _viash.yaml                           Global Viash settings\n├── resources_test/*.tsv                  Sample files to showcase pipeline and\n│   ├── file1.tsv                         run component unit tests.\n│   └── file2.tsv\n├── src/demo                              Source directory with Viash components\n│   ├── combine_columns\n│   ├── remove_comments\n│   └── take_column\n└── workflows\n    └── demo_pipeline                     Demo Nextflow pipeline\n        ├── main.nf\n        └── nextflow.config"
  },
  {
    "objectID": "quickstart/index.html#step-2-build-the-viash-components",
    "href": "quickstart/index.html#step-2-build-the-viash-components",
    "title": "Quickstart",
    "section": "Step 2: Build the Viash components",
    "text": "Step 2: Build the Viash components\nWith Viash you can turn the components in src/ into Dockerized Nextflow modules by running:\nviash ns build --setup cachedbuild --parallel\nWhile building, this will result in the following output:\nExporting take_column (demo) =docker=> target/docker/demo/take_column\n[notice] Building container 'ghcr.io/viash-io/viash_project_template/demo_take_column:dev' with Dockerfile\nExporting take_column (demo) =nextflow=> target/nextflow/demo/take_column\nExporting remove_comments (demo) =docker=> target/docker/demo/remove_comments\n[notice] Building container 'ghcr.io/viash-io/viash_project_template/demo_remove_comments:dev' with Dockerfile\nExporting remove_comments (demo) =nextflow=> target/nextflow/demo/remove_comments\nExporting combine_columns (demo) =docker=> target/docker/demo/combine_columns\n[notice] Building container 'ghcr.io/viash-io/viash_project_template/demo_combine_columns:dev' with Dockerfile\nExporting combine_columns (demo) =nextflow=> target/nextflow/demo/combine_columns\nAll 6 configs built successfully\nOnce everything is built, a new target directory has been created containing the executables and modules grouped per platform:\ntarget/\n├── docker\n│   └── demo\n│       ├── combine_columns\n│       │   ├── combine_columns\n│       │   └── viash.yaml\n│       ├── remove_comments\n│       │   ├── remove_comments\n│       │   └── viash.yaml\n│       └── take_column\n│           ├── take_column\n│           └── viash.yaml\n└── nextflow\n    └── demo\n        ├── combine_columns\n        │   ├── main.nf\n        │   ├── nextflow.config\n        │   └── viash.yaml\n        ├── remove_comments\n        │   ├── main.nf\n        │   ├── nextflow.config\n        │   └── viash.yaml\n        └── take_column\n            ├── main.nf\n            ├── nextflow.config\n            └── viash.yaml"
  },
  {
    "objectID": "quickstart/index.html#step-3-run-the-pipeline",
    "href": "quickstart/index.html#step-3-run-the-pipeline",
    "title": "Quickstart",
    "section": "Step 3: Run the pipeline",
    "text": "Step 3: Run the pipeline\nNow run the pipeline with Nextflow:\nnextflow run . \\\n  -main-script workflows/demo_pipeline/main.nf \\\n  -with-docker \\\n  --input resources_test/file*.tsv \\\n  --publishDir temp\nThis will run the three modules in sequence, with the final result result being stored in a file named combined.combine_columns.output.tsv in a new temp directory:\n\"1\"     0.11\n\"2\"     0.23\n\"3\"     0.35\n\"4\"     0.47"
  },
  {
    "objectID": "quickstart/index.html#whats-next",
    "href": "quickstart/index.html#whats-next",
    "title": "Quickstart",
    "section": "What’s next?",
    "text": "What’s next?\nNow that you’ve had a taste of what Viash can do for you, take a look at our Guide and Reference pages to learn more about how to use Viash. If you want to start simple, we suggest to take a look at the Native component creation guide."
  },
  {
    "objectID": "guide/component/create-component.html",
    "href": "guide/component/create-component.html",
    "title": "Create a new component",
    "section": "",
    "text": "A Viash component can be translated into one or more platforms: Native, Docker, Nextflow. Each of these platforms result in a different artifact:\nBelow we will create our first Viash component using any of the languages natively supported by Viash."
  },
  {
    "objectID": "guide/component/create-component.html#create-a-script",
    "href": "guide/component/create-component.html#create-a-script",
    "title": "Create a new component",
    "section": "Create a script",
    "text": "Create a script\nWhen creating a new Viash component, you can write a new script or use a pre-existing script. Below is a script that simply copies an input file to an output destination.\n\nBashC#JavaScriptPythonRScala\n\n\nCreate a new file named script.sh and copy the following content inside of it. This script will copy an input file to an output destination.\n#!/bin/bash\n\n## VIASH START\npar_input=path/to/file.txt\npar_output=output.txt\n## VIASH END\n\n# copy file\necho \"Copying '$par_input' to '$par_output'.\"\ncp -r \"$par_input\" \"$par_output\"\n\n\nCreate a new file named script.csx and copy the following content inside of it. This script will copy an input file to an output destination.\nusing System.IO;\n\n// VIASH START\nvar par = new {\n  input = \"path/to/file.txt\",\n  output = \"output.txt\"\n};\n// VIASH END\n\n// copy file\nConsole.WriteLine($\"Copying '{par.input}' to '{par.output}'.\");\nFile.Copy(par.input, par.output, true);\n\n\nCreate a new file named script.js and copy the following content inside of it. This script will copy an input file to an output destination.\nconst fs = require('fs');\n\n// VIASH START\nlet par = {\n  'input': 'path/to/file.txt',\n  'output': 'output.txt'\n};\n// VIASH END\n\n// copy file\nconsole.log(`Copying '${par['input']}' to '${par['output']}'`)\nfs.copyFile(par['input'], par['output'], (err) => {\n  if (err) throw err;\n});\n\n\nCreate a new file named script.py and copy the following content inside of it. This script will copy an input file to an output destination.\nimport shutil\n\n## VIASH START\npar = {\n  'input': 'file.txt',\n  'output': 'output.txt'\n}\n## VIASH END\n\n# copy file\nprint(f\"Copying '{par['input']}' to '{par['output']}'.\")\nshutil.copyfile(par['input'], par['output'])\n\n\nCreate a new file named script.R and copy the following content inside of it. This script will copy an input file to an output destination.\n## VIASH START\npar <- list(\n  \"input\" = 'file.txt',\n  \"output\" = 'output.txt'\n)\n## VIASH END\n\n# copy file\ncat(\"Copying '\", par$input, \"' to '\", par$output, \"'.\\n\", sep = \"\")\nfile.copy(par$input, par$output)\n\n\nCreate a new file named script.scala and copy the following content inside of it. This script will copy an input file to an output destination.\nimport java.nio.file.StandardCopyOption.REPLACE_EXISTING\nimport java.nio.file.Files\nimport java.nio.file.Paths\n\n// VIASH START\ncase class ViashPar(input: String, output: String)\nval par = ViashPar(\n  \"path/to/file.txt\",\n  \"output.txt\"\n)\n// VIASH END\n\n// copy file\nprintln(s\"Copying '${par.input}' to '${par.output}'.\")\nval fileIn = Paths.get(par.input)\nval fileOut = Paths.get(par.output)\nFiles.copy(fileIn, fileOut, REPLACE_EXISTING)\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe par variable(s) appear to be hard coded, but they’re not! When running this script with Viash, Viash will strip away the section between VIASH START and VIASH END, and replace it with parameter values at runtime. The values included in this script are thus entirely for development and debugging purposes. More information on how this works will be given in Variables and meta-variables.\n\n\n\nCreate a config\nA Viash config file is a YAML file that describes the functionality of a component and the platform(s) it targets.\n\nBashC#JavaScriptPythonRScala\n\n\nCreate a file named config.vsh.yaml and add the contents below based on your chosen scripting language.\nfunctionality:\n  name: example_bash\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: bash_script\n      path: script.sh\nplatforms:\n  - type: docker\n    image: \"bash:4.0\"\n  - type: native\n  - type: nextflow\n\n\nCreate a file named config.vsh.yaml and add the contents below based on your chosen scripting language.\nfunctionality:\n  name: example_csharp\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: csharp_script\n      path: script.csx\nplatforms:\n  - type: docker\n    image: \"ghcr.io/data-intuitive/dotnet-script:1.3.1\"\n  - type: native\n  - type: nextflow\n\n\nCreate a file named config.vsh.yaml and add the contents below based on your chosen scripting language.\nfunctionality:\n  name: example_js\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: javascript_script\n      path: script.js\nplatforms:\n  - type: docker\n    image: \"node:19-bullseye\"\n  - type: native\n  - type: nextflow\n\n\nCreate a file named config.vsh.yaml and add the contents below based on your chosen scripting language.\nfunctionality:\n  name: example_python\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: python_script\n      path: script.py\nplatforms:\n  - type: docker\n    image: \"python:3.10\"\n  - type: native\n  - type: nextflow\n\n\nCreate a file named config.vsh.yaml and add the contents below based on your chosen scripting language.\nfunctionality:\n  name: example_r\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: r_script\n      path: script.R\nplatforms:\n  - type: docker\n    image: \"eddelbuettel/r2u:22.04\"\n  - type: native\n  - type: nextflow\n\n\nCreate a file named config.vsh.yaml and add the contents below based on your chosen scripting language.\nfunctionality:\n  name: example_scala\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: scala_script\n      path: script.scala\nplatforms:\n  - type: docker\n    image: \"sbtscala/scala-sbt:eclipse-temurin-19_36_1.7.2_2.13.10\"\n  - type: native\n  - type: nextflow\n\n\n\nHere’s a breakdown of the different sections:\n\nfunctionality: A description of what the component does.\n\nname: The name of the component.\narguments: The input and output parameters of the script.\nresources: References to all necessary files and folders to make the component work.\n\nplatforms: Lists which platforms a component can target (i.e. Native, Docker or Nextflow)."
  },
  {
    "objectID": "guide/component/create-component.html#run-the-component",
    "href": "guide/component/create-component.html#run-the-component",
    "title": "Create a new component",
    "section": "Run the component",
    "text": "Run the component\nThat’s it! With these two steps, you created your first component. Next, you can use the viash run command to test whether it actually works as intended.\n\nBashC#JavaScriptPythonRScala\n\n\nYou can call use the component’s --help functionality to get an overview its parameters and descriptions.\n\nviash run config.vsh.yaml -- --help\n\nexample_bash\n\nA minimal example component.\n\nArguments:\n    --input\n        type: file, required parameter, file must exist\n        example: file.txt\n\n    --output\n        type: file, required parameter, output, file must exist\n        example: output.txt\n\n\nAs expected, this component has an --input and --output parameter. You can execute the component by providing values for these parameters.\n\nviash run config.vsh.yaml -- --input config.vsh.yaml --output foo.txt\n\n[notice] Checking if Docker image is available at 'example_bash:latest'\n[warning] Could not pull from 'example_bash:latest'. Docker image doesn't exist or is not accessible.\n[notice] Building container 'example_bash:latest' with Dockerfile\nCopying '/viash_automount/tmp/RtmpQUZi22/create_new_component255616ffc3b7/bash/config.vsh.yaml' to '/viash_automount/tmp/RtmpQUZi22/create_new_component255616ffc3b7/bash/foo.txt'.\n\n\n\n\nYou can call use the component’s --help functionality to get an overview its parameters and descriptions.\n\nviash run config.vsh.yaml -- --help\n\nexample_csharp\n\nA minimal example component.\n\nArguments:\n    --input\n        type: file, required parameter, file must exist\n        example: file.txt\n\n    --output\n        type: file, required parameter, output, file must exist\n        example: output.txt\n\n\nAs expected, this component has an --input and --output parameter. You can execute the component by providing values for these parameters.\n\nviash run config.vsh.yaml -- --input config.vsh.yaml --output foo.txt\n\n[notice] Checking if Docker image is available at 'example_csharp:latest'\n[warning] Could not pull from 'example_csharp:latest'. Docker image doesn't exist or is not accessible.\n[notice] Building container 'example_csharp:latest' with Dockerfile\nCopying '/viash_automount/tmp/RtmpQUZi22/create_new_component255616ffc3b7/csharp/config.vsh.yaml' to '/viash_automount/tmp/RtmpQUZi22/create_new_component255616ffc3b7/csharp/foo.txt'.\n\n\n\n\nYou can call use the component’s --help functionality to get an overview its parameters and descriptions.\n\nviash run config.vsh.yaml -- --help\n\nexample_js\n\nA minimal example component.\n\nArguments:\n    --input\n        type: file, required parameter, file must exist\n        example: file.txt\n\n    --output\n        type: file, required parameter, output, file must exist\n        example: output.txt\n\n\nAs expected, this component has an --input and --output parameter. You can execute the component by providing values for these parameters.\n\nviash run config.vsh.yaml -- --input config.vsh.yaml --output foo.txt\n\n[notice] Checking if Docker image is available at 'example_js:latest'\n[warning] Could not pull from 'example_js:latest'. Docker image doesn't exist or is not accessible.\n[notice] Building container 'example_js:latest' with Dockerfile\nCopying '/viash_automount/tmp/RtmpQUZi22/create_new_component255616ffc3b7/js/config.vsh.yaml' to '/viash_automount/tmp/RtmpQUZi22/create_new_component255616ffc3b7/js/foo.txt'\n\n\n\n\nYou can call use the component’s --help functionality to get an overview its parameters and descriptions.\n\nviash run config.vsh.yaml -- --help\n\nexample_python\n\nA minimal example component.\n\nArguments:\n    --input\n        type: file, required parameter, file must exist\n        example: file.txt\n\n    --output\n        type: file, required parameter, output, file must exist\n        example: output.txt\n\n\nAs expected, this component has an --input and --output parameter. You can execute the component by providing values for these parameters.\n\nviash run config.vsh.yaml -- --input config.vsh.yaml --output foo.txt\n\n[notice] Checking if Docker image is available at 'example_python:latest'\n[warning] Could not pull from 'example_python:latest'. Docker image doesn't exist or is not accessible.\n[notice] Building container 'example_python:latest' with Dockerfile\nCopying '/viash_automount/tmp/RtmpQUZi22/create_new_component255616ffc3b7/python/config.vsh.yaml' to '/viash_automount/tmp/RtmpQUZi22/create_new_component255616ffc3b7/python/foo.txt'.\n\n\n\n\nYou can call use the component’s --help functionality to get an overview its parameters and descriptions.\n\nviash run config.vsh.yaml -- --help\n\nexample_r\n\nA minimal example component.\n\nArguments:\n    --input\n        type: file, required parameter, file must exist\n        example: file.txt\n\n    --output\n        type: file, required parameter, output, file must exist\n        example: output.txt\n\n\nAs expected, this component has an --input and --output parameter. You can execute the component by providing values for these parameters.\n\nviash run config.vsh.yaml -- --input config.vsh.yaml --output foo.txt\n\n[notice] Checking if Docker image is available at 'example_r:latest'\n[warning] Could not pull from 'example_r:latest'. Docker image doesn't exist or is not accessible.\n[notice] Building container 'example_r:latest' with Dockerfile\nCopying '/viash_automount/tmp/RtmpQUZi22/create_new_component255616ffc3b7/r/config.vsh.yaml' to '/viash_automount/tmp/RtmpQUZi22/create_new_component255616ffc3b7/r/foo.txt'.\n[1] TRUE\n\n\n\n\nYou can call use the component’s --help functionality to get an overview its parameters and descriptions.\n\nviash run config.vsh.yaml -- --help\n\nexample_scala\n\nA minimal example component.\n\nArguments:\n    --input\n        type: file, required parameter, file must exist\n        example: file.txt\n\n    --output\n        type: file, required parameter, output, file must exist\n        example: output.txt\n\n\nAs expected, this component has an --input and --output parameter. You can execute the component by providing values for these parameters.\n\nviash run config.vsh.yaml -- --input config.vsh.yaml --output foo.txt\n\n[notice] Checking if Docker image is available at 'example_scala:latest'\n[warning] Could not pull from 'example_scala:latest'. Docker image doesn't exist or is not accessible.\n[notice] Building container 'example_scala:latest' with Dockerfile\nwarning: 1 deprecation; re-run with -deprecation for details\nCopying '/viash_automount/tmp/RtmpQUZi22/create_new_component255616ffc3b7/scala/config.vsh.yaml' to '/viash_automount/tmp/RtmpQUZi22/create_new_component255616ffc3b7/scala/foo.txt'.\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe double dash (--) between the viash command and the arguments is used to signify the end of the arguments passed to Viash and the start of those passed to the script. If you forgot to add these, you’ll get an error similar to this:\n\nviash run config.vsh.yaml \\\n  --input foo.txt \\\n  --output bar.txt\n\n[scallop] Error: Unknown option 'input'"
  },
  {
    "objectID": "guide/component/create-component.html#build-an-executable",
    "href": "guide/component/create-component.html#build-an-executable",
    "title": "Create a new component",
    "section": "Build an executable",
    "text": "Build an executable\nWe will now turn the Viash component into an executable.\n\nBashC#JavaScriptPythonRScala\n\n\nUse the viash build command to generate an executable:\n\nviash build config.vsh.yaml --output target\n\nThis will generate an executable in the target/ directory:\n\ntree\n\n.\n├── config.vsh.yaml\n├── foo.txt\n├── script.sh\n└── target\n    └── example_bash\n\n1 directory, 4 files\n\n\n\n\nUse the viash build command to generate an executable:\n\nviash build config.vsh.yaml --output target\n\nThis will generate an executable in the target/ directory:\n\ntree\n\n.\n├── config.vsh.yaml\n├── foo.txt\n├── script.csx\n└── target\n    └── example_csharp\n\n1 directory, 4 files\n\n\n\n\nUse the viash build command to generate an executable:\n\nviash build config.vsh.yaml --output target\n\nThis will generate an executable in the target/ directory:\n\ntree\n\n.\n├── config.vsh.yaml\n├── foo.txt\n├── script.js\n└── target\n    └── example_js\n\n1 directory, 4 files\n\n\n\n\nUse the viash build command to generate an executable:\n\nviash build config.vsh.yaml --output target\n\nThis will generate an executable in the target/ directory:\n\ntree\n\n.\n├── config.vsh.yaml\n├── foo.txt\n├── script.py\n└── target\n    └── example_python\n\n1 directory, 4 files\n\n\n\n\nUse the viash build command to generate an executable:\n\nviash build config.vsh.yaml --output target\n\nThis will generate an executable in the target/ directory:\n\ntree\n\n.\n├── config.vsh.yaml\n├── foo.txt\n├── script.R\n└── target\n    └── example_r\n\n1 directory, 4 files\n\n\n\n\nUse the viash build command to generate an executable:\n\nviash build config.vsh.yaml --output target\n\nThis will generate an executable in the target/ directory:\n\ntree\n\n.\n├── config.vsh.yaml\n├── foo.txt\n├── script.scala\n└── target\n    └── example_scala\n\n1 directory, 4 files"
  },
  {
    "objectID": "guide/component/create-component.html#displaying-the-help-text",
    "href": "guide/component/create-component.html#displaying-the-help-text",
    "title": "Create a new component",
    "section": "Displaying the help text",
    "text": "Displaying the help text\nIt’s often useful to know what arguments an executable expects before trying to run it.\n\nBashC#JavaScriptPythonRScala\n\n\nTo display its documentation, run the executable with just the --help argument:\n\ntarget/example_bash --help\n\nexample_bash\n\nA minimal example component.\n\nArguments:\n    --input\n        type: file, required parameter, file must exist\n        example: file.txt\n\n    --output\n        type: file, required parameter, output, file must exist\n        example: output.txt\n\n\n\n\nTo display its documentation, run the executable with just the --help argument:\n\ntarget/example_csharp --help\n\nexample_csharp\n\nA minimal example component.\n\nArguments:\n    --input\n        type: file, required parameter, file must exist\n        example: file.txt\n\n    --output\n        type: file, required parameter, output, file must exist\n        example: output.txt\n\n\n\n\nTo display its documentation, run the executable with just the --help argument:\n\ntarget/example_js --help\n\nexample_js\n\nA minimal example component.\n\nArguments:\n    --input\n        type: file, required parameter, file must exist\n        example: file.txt\n\n    --output\n        type: file, required parameter, output, file must exist\n        example: output.txt\n\n\n\n\nTo display its documentation, run the executable with just the --help argument:\n\ntarget/example_python --help\n\nexample_python\n\nA minimal example component.\n\nArguments:\n    --input\n        type: file, required parameter, file must exist\n        example: file.txt\n\n    --output\n        type: file, required parameter, output, file must exist\n        example: output.txt\n\n\n\n\nTo display its documentation, run the executable with just the --help argument:\n\ntarget/example_r --help\n\nexample_r\n\nA minimal example component.\n\nArguments:\n    --input\n        type: file, required parameter, file must exist\n        example: file.txt\n\n    --output\n        type: file, required parameter, output, file must exist\n        example: output.txt\n\n\n\n\nTo display its documentation, run the executable with just the --help argument:\n\ntarget/example_scala --help\n\nexample_scala\n\nA minimal example component.\n\nArguments:\n    --input\n        type: file, required parameter, file must exist\n        example: file.txt\n\n    --output\n        type: file, required parameter, output, file must exist\n        example: output.txt\n\n\n\n\n\nThis executable takes a file as input and will create an output file."
  },
  {
    "objectID": "guide/component/create-component.html#running-the-executable",
    "href": "guide/component/create-component.html#running-the-executable",
    "title": "Create a new component",
    "section": "Running the executable",
    "text": "Running the executable\nRunning an executable is the same as any other executable on your system.\n\nBashC#JavaScriptPythonRScala\n\n\nYou can run the executable by providing a value for --input and --output:\n\ntarget/example_bash --input config.vsh.yaml --output output.txt\n\nCopying '/viash_automount/tmp/RtmpQUZi22/create_new_component255616ffc3b7/bash/config.vsh.yaml' to '/viash_automount/tmp/RtmpQUZi22/create_new_component255616ffc3b7/bash/output.txt'.\n\n\nThis results in the following output:\n\nls -l\n\ntotal 20\n-rw-r--r-- 1 runner docker  428 Feb 27 08:05 config.vsh.yaml\n-rw-r--r-- 1 runner docker  428 Feb 27 08:06 foo.txt\n-rw-r--r-- 1 runner docker  428 Feb 27 08:08 output.txt\n-rwxr-xr-x 1 runner docker  181 Feb 27 08:05 script.sh\ndrwxr-xr-x 2 runner docker 4096 Feb 27 08:08 target\n\n\n\n\nYou can run the executable by providing a value for --input and --output:\n\ntarget/example_csharp --input config.vsh.yaml --output output.txt\n\nCopying '/viash_automount/tmp/RtmpQUZi22/create_new_component255616ffc3b7/csharp/config.vsh.yaml' to '/viash_automount/tmp/RtmpQUZi22/create_new_component255616ffc3b7/csharp/output.txt'.\n\n\nThis results in the following output:\n\nls -l\n\ntotal 20\n-rw-r--r-- 1 runner docker  467 Feb 27 08:05 config.vsh.yaml\n-rw-r--r-- 1 runner docker  467 Feb 27 08:05 foo.txt\n-rw-r--r-- 1 runner docker  467 Feb 27 08:05 output.txt\n-rw-r--r-- 1 runner docker  237 Feb 27 08:05 script.csx\ndrwxr-xr-x 2 runner docker 4096 Feb 27 08:08 target\n\n\n\n\nYou can run the executable by providing a value for --input and --output:\n\ntarget/example_js --input config.vsh.yaml --output output.txt\n\nCopying '/viash_automount/tmp/RtmpQUZi22/create_new_component255616ffc3b7/js/config.vsh.yaml' to '/viash_automount/tmp/RtmpQUZi22/create_new_component255616ffc3b7/js/output.txt'\n\n\nThis results in the following output:\n\nls -l\n\ntotal 20\n-rw-r--r-- 1 runner docker  440 Feb 27 08:05 config.vsh.yaml\n-rw-r--r-- 1 runner docker  440 Feb 27 08:06 foo.txt\n-rw-r--r-- 1 runner docker  440 Feb 27 08:09 output.txt\n-rwxr-xr-x 1 runner docker  282 Feb 27 08:05 script.js\ndrwxr-xr-x 2 runner docker 4096 Feb 27 08:08 target\n\n\n\n\nYou can run the executable by providing a value for --input and --output:\n\ntarget/example_python --input config.vsh.yaml --output output.txt\n\nCopying '/viash_automount/tmp/RtmpQUZi22/create_new_component255616ffc3b7/python/config.vsh.yaml' to '/viash_automount/tmp/RtmpQUZi22/create_new_component255616ffc3b7/python/output.txt'.\n\n\nThis results in the following output:\n\nls -l\n\ntotal 20\n-rw-r--r-- 1 runner docker  435 Feb 27 08:05 config.vsh.yaml\n-rw-r--r-- 1 runner docker  435 Feb 27 08:07 foo.txt\n-rw-r--r-- 1 runner docker  435 Feb 27 08:09 output.txt\n-rwxr-xr-x 1 runner docker  216 Feb 27 08:05 script.py\ndrwxr-xr-x 2 runner docker 4096 Feb 27 08:08 target\n\n\n\n\nYou can run the executable by providing a value for --input and --output:\n\ntarget/example_r --input config.vsh.yaml --output output.txt\n\nCopying '/viash_automount/tmp/RtmpQUZi22/create_new_component255616ffc3b7/r/config.vsh.yaml' to '/viash_automount/tmp/RtmpQUZi22/create_new_component255616ffc3b7/r/output.txt'.\n[1] TRUE\n\n\nThis results in the following output:\n\nls -l\n\ntotal 20\n-rw-r--r-- 1 runner docker  435 Feb 27 08:05 config.vsh.yaml\n-rw-r--r-- 1 runner docker  435 Feb 27 08:07 foo.txt\n-rw-r--r-- 1 runner docker  435 Feb 27 08:09 output.txt\n-rwxr-xr-x 1 runner docker  207 Feb 27 08:05 script.R\ndrwxr-xr-x 2 runner docker 4096 Feb 27 08:08 target\n\n\n\n\nYou can run the executable by providing a value for --input and --output:\n\ntarget/example_scala --input config.vsh.yaml --output output.txt\n\nwarning: 1 deprecation; re-run with -deprecation for details\nCopying '/viash_automount/tmp/RtmpQUZi22/create_new_component255616ffc3b7/scala/config.vsh.yaml' to '/viash_automount/tmp/RtmpQUZi22/create_new_component255616ffc3b7/scala/output.txt'.\n\n\nThis results in the following output:\n\nls -l\n\ntotal 20\n-rw-r--r-- 1 runner docker  479 Feb 27 08:05 config.vsh.yaml\n-rw-r--r-- 1 runner docker  479 Feb 27 08:08 foo.txt\n-rw-r--r-- 1 runner docker  479 Feb 27 08:09 output.txt\n-rw-r--r-- 1 runner docker  435 Feb 27 08:05 script.scala\ndrwxr-xr-x 2 runner docker 4096 Feb 27 08:08 target"
  },
  {
    "objectID": "guide/component/use-helper-functions.html",
    "href": "guide/component/use-helper-functions.html",
    "title": "Use helper functions",
    "section": "",
    "text": "This documentation will walk you through the process of importing and using functions defined in an external file in your Viash component.\nThis can be useful for organizing and reusing code across multiple components or even within a single component.\nWe’ll cover the steps to set up the external file, import the functions, and use them within your Viash component. By the end of this guide, you’ll have a better understanding of how to leverage external files to improve your Viash development workflow."
  },
  {
    "objectID": "guide/component/use-helper-functions.html#create-helper-script",
    "href": "guide/component/use-helper-functions.html#create-helper-script",
    "title": "Use helper functions",
    "section": "Create helper script",
    "text": "Create helper script\nWhen you want to reuse a function multiple times, it might make sense to store them in a separate file. For example, your helper file could contain the following helper function:\n\nBashC#JavaScriptPythonRScala\n\n\nfunction copy_file {\n  echo \"Copying '$1' to '$2'.\"\n  cp -r \"$1\" \"$2\"\n}\n\n\n// No example available yet.\n\n\nconst fs = require('fs');\n\nfunction copy_file(source, dest) {\n  console.log(`Copying '${source}' to '${dest}'`)\n  fs.copyFile(source, dest, (err) => {\n    if (err) throw err;\n  });\n}\n\nmodule.exports = {\n  copy_file\n}\n\n\nimport shutil\n\ndef copy_file(source, dest):\n  print(f\"Copying '{source}' to '{dest}'.\")\n  shutil.copyfile(source, dest)\n\n\ncopy_file <- function(source, dest) {\n  cat(\"Copying '\", source, \"' to '\", dest, \"'.\\n\", sep = \"\")\n  file.copy(source, dest)\n}\n\n\n// No example available yet."
  },
  {
    "objectID": "guide/component/use-helper-functions.html#add-resource-to-component",
    "href": "guide/component/use-helper-functions.html#add-resource-to-component",
    "title": "Use helper functions",
    "section": "Add resource to component",
    "text": "Add resource to component\nTo add a helper script as an external resource in a Viash component, you can use the resources section of the component’s config file. Not only does your resources section contain the main script, but it’s also used to specify external resources such as helper scripts and other files that the component needs to function.\nHere is an example of what the config file might look after adding the helper script:\n\nBashC#JavaScriptPythonRScala\n\n\nfunctionality:\n  name: example_bash\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: bash_script\n      path: script.sh\n    - path: helper.sh\nplatforms:\n  - type: docker\n    image: bash:4.0\n  - type: native\n  - type: nextflow\n\n\nfunctionality:\n  name: example_csharp\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: csharp_script\n      path: script.csx\n    - path: helper.csx\nplatforms:\n  - type: docker\n    image: ghcr.io/data-intuitive/dotnet-script:1.3.1\n  - type: native\n  - type: nextflow\n\n\nfunctionality:\n  name: example_js\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: javascript_script\n      path: script.js\n    - path: helper.js\nplatforms:\n  - type: docker\n    image: node:19-bullseye\n  - type: native\n  - type: nextflow\n\n\nfunctionality:\n  name: example_python\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: python_script\n      path: script.py\n    - path: helper.py\nplatforms:\n  - type: docker\n    image: python:3.10\n  - type: native\n  - type: nextflow\n\n\nfunctionality:\n  name: example_r\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: r_script\n      path: script.R\n    - path: helper.R\nplatforms:\n  - type: docker\n    image: eddelbuettel/r2u:22.04\n  - type: native\n  - type: nextflow\n\n\nfunctionality:\n  name: example_scala\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: scala_script\n      path: script.scala\n    - path: helper.scala\nplatforms:\n  - type: docker\n    image: sbtscala/scala-sbt:eclipse-temurin-19_36_1.7.2_2.13.10\n  - type: native\n  - type: nextflow"
  },
  {
    "objectID": "guide/component/use-helper-functions.html#import-helper-functions",
    "href": "guide/component/use-helper-functions.html#import-helper-functions",
    "title": "Use helper functions",
    "section": "Import helper functions",
    "text": "Import helper functions\nFinally, you need to import the helper functions in your script. The procedure will differ depending on the scripting language used. Below is an example of what the main script might look like after importing the helper file.\n\nBashC#JavaScriptPythonRScala\n\n\n#!/bin/bash\n\n## VIASH START\npar_input=path/to/file.txt\npar_output=output.txt\n## VIASH END\n\n# view resource file\nsource \"$meta_resources_dir/helper.sh\"\n\n# copy file\ncopy_file \"$par_input\" \"$par_output\"\n\n\n// No example available yet.\n\n\n// VIASH START\nlet par = {\n  'input': 'path/to/file.txt',\n  'output': 'output.txt'\n};\n// VIASH END\n\n// import helper function\nconst helper = require(`${meta['resources_dir']}/helper.js`);\n\n// copy file\nhelper.copy_file(par['input'], par['output'])\n\n\nimport sys\n\n## VIASH START\npar = {\n  'input': 'file.txt',\n  'output': 'output.txt'\n}\n## VIASH END\n\n# import helper function\nsys.path.append(meta['resources_dir'])\nfrom helper import copy_file\n\n# copy file\ncopy_file(par['input'], par['output'])\n\n\n## VIASH START\npar <- list(\n  \"input\" = \"file.txt\",\n  \"output\" = \"output.txt\"\n)\n## VIASH END\n\n# import helper function\nsource(paste0(meta$resources_dir, \"/helper.R\"))\n\n# copy file\ncopy_file(par$input, par$output)\n\n\n// No example available yet."
  },
  {
    "objectID": "guide/component/add-dependencies.html",
    "href": "guide/component/add-dependencies.html",
    "title": "Add dependencies",
    "section": "",
    "text": "In the previous section, reproducibility of our Viash component was ensured by a predefined Docker image such as bash:4.0 and python:3.10. However, your script might require other software dependencies, such as command-line tools or Python and R packages.\nBy default, Viash will build component-specific Docker images. This means that every Viash component can have its own set of dependencies."
  },
  {
    "objectID": "guide/component/add-dependencies.html#extended-example",
    "href": "guide/component/add-dependencies.html#extended-example",
    "title": "Add dependencies",
    "section": "Extended example",
    "text": "Extended example\nBelow is an example where additional software is added to a base Docker image using the setup section of a Docker platform.\n\nBashC#JavaScriptPythonRScala\n\n\nfunctionality:\n  name: example_bash_with_setup\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: bash_script\n      path: script.sh\nplatforms:\n  - type: docker\n    image: bash:4.0\n    setup:\n      - type: apk\n        packages:\n          - curl\n          - wget\n  - type: native\n  - type: nextflow\n\n\nfunctionality:\n  name: example_csharp_with_setup\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: csharp_script\n      path: script.csx\nplatforms:\n  - type: docker\n    image: ghcr.io/data-intuitive/dotnet-script:1.3.1\n    setup:\n      - type: apk\n        packages:\n          - curl\n          - wget\n  - type: native\n  - type: nextflow\n\n\nfunctionality:\n  name: example_js_with_setup\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: javascript_script\n      path: script.js\nplatforms:\n  - type: docker\n    image: node:19-bullseye\n    setup:\n      - type: apt\n        packages:\n          - curl\n          - wget\n  - type: native\n  - type: nextflow\n\n\nfunctionality:\n  name: example_python_with_setup\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: python_script\n      path: script.py\nplatforms:\n  - type: docker\n    image: python:3.10\n    setup:\n      - type: apt\n        packages:\n          - curl\n          - wget\n      - type: python\n        packages: anndata\n  - type: native\n  - type: nextflow\n\n\nfunctionality:\n  name: example_r_with_setup\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: r_script\n      path: script.R\nplatforms:\n  - type: docker\n    image: eddelbuettel/r2u:22.04\n    setup:\n      - type: apt\n        packages:\n          - curl\n          - wget\n      - type: r\n        packages: tidyverse\n  - type: native\n  - type: nextflow\n\n\nfunctionality:\n  name: example_scala_with_setup\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: scala_script\n      path: script.scala\nplatforms:\n  - type: docker\n    image: sbtscala/scala-sbt:eclipse-temurin-19_36_1.7.2_2.13.10\n    setup:\n      - type: apt\n        packages:\n          - curl\n          - wget\n  - type: native\n  - type: nextflow\n\n\n\nYou can (re)build a component’s Docker image by passing the ---setup flag to the executable:\n\nBashC#JavaScriptPythonRScala\n\n\nBuild the executable:\n\nviash build config.vsh.yaml --platform docker --output target\n\nBuild the Docker image:\n\ntarget/example_bash_with_setup ---setup cachedbuild\n\n[notice] Building container 'example_bash_with_setup:latest' with Dockerfile\n\n\n\n\nBuild the executable:\n\nviash build config.vsh.yaml --platform docker --output target\n\nBuild the Docker image:\n\ntarget/example_csharp_with_setup ---setup cachedbuild\n\n[notice] Building container 'example_csharp_with_setup:latest' with Dockerfile\n\n\n\n\nBuild the executable:\n\nviash build config.vsh.yaml --platform docker --output target\n\nBuild the Docker image:\n\ntarget/example_js_with_setup ---setup cachedbuild\n\n[notice] Building container 'example_js_with_setup:latest' with Dockerfile\n\n\n\n\nBuild the executable:\n\nviash build config.vsh.yaml --platform docker --output target\n\nBuild the Docker image:\n\ntarget/example_python_with_setup ---setup cachedbuild\n\n[notice] Building container 'example_python_with_setup:latest' with Dockerfile\n\n\n\n\nBuild the executable:\n\nviash build config.vsh.yaml --platform docker --output target\n\nBuild the Docker image:\n\ntarget/example_r_with_setup ---setup cachedbuild\n\n[notice] Building container 'example_r_with_setup:latest' with Dockerfile\n\n\n\n\nBuild the executable:\n\nviash build config.vsh.yaml --platform docker --output target\n\nBuild the Docker image:\n\ntarget/example_scala_with_setup ---setup cachedbuild\n\n[notice] Building container 'example_scala_with_setup:latest' with Dockerfile\n\n\n\n\n\nAlternatively, you can also build the executable and it’s corresponding Docker image in one go:\n\nBashC#JavaScriptPythonRScala\n\n\nviash build config.vsh.yaml --platform docker --output target --setup cachedbuild\n\n\nviash build config.vsh.yaml --platform docker --output target --setup cachedbuild\n\n\nviash build config.vsh.yaml --platform docker --output target --setup cachedbuild\n\n\nviash build config.vsh.yaml --platform docker --output target --setup cachedbuild\n\n\nviash build config.vsh.yaml --platform docker --output target --setup cachedbuild\n\n\nviash build config.vsh.yaml --platform docker --output target --setup cachedbuild"
  },
  {
    "objectID": "guide/component/add-dependencies.html#steps-for-creating-a-custom-docker-platform",
    "href": "guide/component/add-dependencies.html#steps-for-creating-a-custom-docker-platform",
    "title": "Add dependencies",
    "section": "Steps for creating a custom Docker platform",
    "text": "Steps for creating a custom Docker platform\nHere is a series of steps you can follow to add a Docker platform to your Viash component from scratch.\n\nStep 1: Choose a base image\nTo start off, you’ll need to choose a base Docker image to start working with. In deciding which base image to use, it’s important to consider the size of the image and how trustworthy the source image is.\n\n\n\n\n\n\nTip\n\n\n\nIf the container does not have Bash installed, don’t forget to install this in Step 2.\n\n\nHere is a list of base images we commonly use:\n\nBash: bash, ubuntu\nC#: ghcr.io/data-intuitive/dotnet-script\nJavaScript: node\nPython: python, nvcr.io/nvidia/pytorch\nR: eddelbuettel/r2u, rocker/tidyverse\nScala: sbtscala/scala-sbt\n\nSee the section on ‘minimum requirements’ when building a custom base image.\n\n\nStep 2: Installing additional dependencies\nYou can use the setup section to many different types of layers. Here are some examples:\n\nApk requirements:\nsetup:\n  - type: apk\n    packages: [ curl ]\nApt requirements:\nsetup:\n  - type: apk\n    packages: [ curl ]\nDocker requirements:\nsetup:\n  - type: docker\n    build_args: \"R_VERSION=hello_world\"\n    run: |\n      echo 'Run a custom command'\n      echo 'Foo' > /path/to/file.txt\nJavascript requirements:\nsetup:\n  - type: javascript\n    packages: [ express ]\n    github: [ \"expressjs/express\" ]\nPython requirements:\nsetup:\n  - type: python\n    packages: [ anndata ]\n  github: [ jkbr/httpie ]\nR requirements:\nsetup:\n  - type: r\n    packages: [ anndata ]\n    bioc: [ AnnotationDbi, SingleCellExperiment ]\n    github: rcannood/SCORPIUS\nRuby requirements:\nsetup:\n  - type: ruby\n    packages: [ pry ]\nYum requirements:\nsetup:\n  - type: ruby\n    packages: [ pry ]\n    github: [ \"pry/pry\" ]\n\nFor more information on the possible setup entries, check out the reference documentation.\n\n\n\n\n\n\nImportant\n\n\n\nDon’t forget to rebuild the Docker image after making changes to the setup section of your Docker platform (see next step).\n\n\n\n\nStep 3: Rebuild Docker image\nAfter adding additional setup entries, it’s important to rerun ``---setup cachedbuild to rebuild the Docker image, as Viash will not rebuild the Docker image when it already exists.\n\nBashC#JavaScriptPythonRScala\n\n\nviash build config.vsh.yaml \n  --platform docker \n  --output target \n  --setup cachedbuild\n\n\nviash build config.vsh.yaml \n  --platform docker \n  --output target \n  --setup cachedbuild\n\n\nviash build config.vsh.yaml \n  --platform docker \n  --output target \n  --setup cachedbuild\n\n\nviash build config.vsh.yaml \n  --platform docker \n  --output target \n  --setup cachedbuild\n\n\nviash build config.vsh.yaml \n  --platform docker \n  --output target \n  --setup cachedbuild\n\n\nviash build config.vsh.yaml \n  --platform docker \n  --output target \n  --setup cachedbuild\n\n\n\nYou can choose what strategy to build an executable with when using a Docker backend by passing the --setup option followed by one of the strategies below.\nBuilding an image:\n\nalwaysbuild / build / b: Always build the image from the dockerfile. This is the default setup strategy.\nalwayscachedbuild / cachedbuild / cb: Always build the image from the dockerfile, with caching enabled.\nifneedbebuild: Build the image if it does not exist locally.\nifneedbecachedbuild: Build the image with caching enabled if it does not exist locally.\n\nPulling an image:\n\nalwayspull / pull / p: Try to pull the container from Docker Hub or the specified docker registry.\nalwayspullelsebuild / pullelsebuild: Try to pull the image from a registry and build it if it doesn’t exist.\nalwayspullelsecachedbuild / pullelsecachedbuild: Try to pull the image from a registry and build it with caching if it doesn’t exist.\nifneedbepull: If the image does not exist locally, pull the image.\nifneedbepullelsebuild If the image does not exist locally, pull the image. If the image does exist, build it.\nifneedbepullelsecachedbuild: If the image does not exist locally, pull the image. If the image does exist, build it with caching enabled.\n\nPushing an image:\n\npush: Push the container to Docker Hub or the specified docker registry.\npushifnotpresent Push the container to Docker Hub or the specified docker registry if the specified tag does not exist yet.\n\nDoing nothing:\n\ndonothing / meh: Do not build or pull anything."
  },
  {
    "objectID": "guide/component/add-dependencies.html#troubleshooting",
    "href": "guide/component/add-dependencies.html#troubleshooting",
    "title": "Add dependencies",
    "section": "Troubleshooting",
    "text": "Troubleshooting\nBelow are several steps that might help you troubleshoot the image when the setup fails.\n\nView Dockerfile\nYou can view the actual Dockerfile used by Viash by passing the ---dockerfile flag:\n\nBashC#JavaScriptPythonRScala\n\n\n\ntarget/example_bash_with_setup ---dockerfile\n\nFROM bash:4.0\n\nRUN apk add --no-cache curl wget\n\nLABEL org.opencontainers.image.description=\"Companion container for running component example_bash_with_setup\"\nLABEL org.opencontainers.image.created=\"2023-02-27T08:09:49Z\"\n\n\n\n\n\ntarget/example_csharp_with_setup ---dockerfile\n\nFROM ghcr.io/data-intuitive/dotnet-script:1.3.1\n\nRUN apk add --no-cache curl wget\n\nLABEL org.opencontainers.image.description=\"Companion container for running component example_csharp_with_setup\"\nLABEL org.opencontainers.image.created=\"2023-02-27T08:09:58Z\"\n\n\n\n\n\ntarget/example_js_with_setup ---dockerfile\n\nFROM node:19-bullseye\n\nRUN apt-get update && \\\n  DEBIAN_FRONTEND=noninteractive apt-get install -y curl wget && \\\n  rm -rf /var/lib/apt/lists/*\n\nLABEL org.opencontainers.image.description=\"Companion container for running component example_js_with_setup\"\nLABEL org.opencontainers.image.created=\"2023-02-27T08:10:07Z\"\n\n\n\n\n\ntarget/example_python_with_setup ---dockerfile\n\nFROM python:3.10\n\nRUN apt-get update && \\\n  DEBIAN_FRONTEND=noninteractive apt-get install -y curl wget && \\\n  rm -rf /var/lib/apt/lists/*\n\nRUN pip install --upgrade pip && \\\n  pip install --upgrade --no-cache-dir \"anndata\"\n\nLABEL org.opencontainers.image.description=\"Companion container for running component example_python_with_setup\"\nLABEL org.opencontainers.image.created=\"2023-02-27T08:10:20Z\"\n\n\n\n\n\ntarget/example_r_with_setup ---dockerfile\n\nFROM eddelbuettel/r2u:22.04\n\nRUN apt-get update && \\\n  DEBIAN_FRONTEND=noninteractive apt-get install -y curl wget && \\\n  rm -rf /var/lib/apt/lists/*\n\nRUN Rscript -e 'if (!requireNamespace(\"remotes\", quietly = TRUE)) install.packages(\"remotes\")' && \\\n  Rscript -e 'remotes::install_cran(c(\"tidyverse\"), repos = \"https://cran.rstudio.com\")'\n\nLABEL org.opencontainers.image.description=\"Companion container for running component example_r_with_setup\"\nLABEL org.opencontainers.image.created=\"2023-02-27T08:10:53Z\"\n\n\n\n\n\ntarget/example_scala_with_setup ---dockerfile\n\nFROM sbtscala/scala-sbt:eclipse-temurin-19_36_1.7.2_2.13.10\n\nRUN apt-get update && \\\n  DEBIAN_FRONTEND=noninteractive apt-get install -y curl wget && \\\n  rm -rf /var/lib/apt/lists/*\n\nLABEL org.opencontainers.image.description=\"Companion container for running component example_scala_with_setup\"\nLABEL org.opencontainers.image.created=\"2023-02-27T08:11:40Z\"\n\n\n\n\n\n\n\nEnter debugging session\nYou can also hop in a Bash session inside the Docker image using the ---debug flag:\n\nBashC#JavaScriptPythonRScala\n\n\ntarget/example_bash_with_setup ---debug\n[notice] + docker run --entrypoint=bash -i --rm -v `pwd`:/pwd --workdir /pwd -t 'example_bash_with_setup:latest'\nroot@93c38006a124:/pwd#\n\n\ntarget/example_csharp_with_setup ---debug\n[notice] + docker run --entrypoint=bash -i --rm -v `pwd`:/pwd --workdir /pwd -t 'example_csharp_with_setup:latest'\nroot@93c38006a124:/pwd#\n\n\ntarget/example_js_with_setup ---debug\n[notice] + docker run --entrypoint=bash -i --rm -v `pwd`:/pwd --workdir /pwd -t 'example_js_with_setup:latest'\nroot@93c38006a124:/pwd#\n\n\ntarget/example_python_with_setup ---debug\n[notice] + docker run --entrypoint=bash -i --rm -v `pwd`:/pwd --workdir /pwd -t 'example_python_with_setup:latest'\nroot@93c38006a124:/pwd#\n\n\ntarget/example_r_with_setup ---debug\n[notice] + docker run --entrypoint=bash -i --rm -v `pwd`:/pwd --workdir /pwd -t 'example_r_with_setup:latest'\nroot@93c38006a124:/pwd#\n\n\ntarget/example_scala_with_setup ---debug\n[notice] + docker run --entrypoint=bash -i --rm -v `pwd`:/pwd --workdir /pwd -t 'example_scala_with_setup:latest'\nroot@93c38006a124:/pwd#\n\n\n\nThis is useful for interactively debugging issues inside the container. For example, for figuring out whether you need to use apk, apt or yum to install software and to search for the exact name of packages like libcurl4-openssl-dev."
  },
  {
    "objectID": "guide/component/add-dependencies.html#alternative-solutions",
    "href": "guide/component/add-dependencies.html#alternative-solutions",
    "title": "Add dependencies",
    "section": "Alternative solutions",
    "text": "Alternative solutions\nThere are multiple ways you might try to find a Docker image which contains the right set of dependencies for your component:\n\nBrowse Docker Hub: Look a Docker image on Docker Hub or other Docker registries which has the right set of dependencies.\n\nThis is generally not recommended because it might take a long time to find a pre-existing image with the right set of dependencies\nPoses a serious security risk.\n\nWrite a custom Dockerfile: You can write a custom Dockerfile to build your own Docker image and store it in a Docker registry, effectively creating a new ‘trusted’ base image.\n\nRequires manual bookkeeping of which Docker images are used in which components.\nNot difficult but requires more know-how on how to build custom Docker images.\n\nUse Viash setup to build component-specific images: The methodology described above.\n\nEasier to add / change dependencies to one component without breaking another\nStore images in a centralized container registry"
  },
  {
    "objectID": "guide/component/add-dependencies.html#behind-the-scenes",
    "href": "guide/component/add-dependencies.html#behind-the-scenes",
    "title": "Add dependencies",
    "section": "Behind the scenes",
    "text": "Behind the scenes\n\nAuto-mount\nAny executable built by Viash with a Docker platform will automatically mount the directories of files passed to the executable as arguments. For example, when running:\n./my_executable --input /foo/bar/file.txt --output /dest/path\nThe executable will automatically mount the /foo/bar and /dest folder to /viash_automount/foo/bar/ and /viash_automount/dest inside the Docker container.\n\n\nAuto-chown\nBy default, files created and modified by a Docker container are owned by root. By default, Viash automatically changes the owner of any files defined in the config file to the user running the executable. This behaviour can be overridden by setting the chown setting to false in your config file.\nExample with standard Docker:\ndocker run -v `pwd`:/pwd bash:4.0 touch /pwd/file.txt\nls -l\n-rw-r--r--. 1 root     root         0 Jan 26 16:03 file.txt\nExample with a Viash executable:\n/my_executable --output file.txt\n-rw-r--r--. 1 myuser   myuser        Jan 26 16:03 file.txt\n\n\nMinimum requirements for custom Docker images\nViash components only require a minimal set of dependencies which need to be available inside the Docker image:\n\nBash: bash.\nC#: bash and dotnet-script.\nJavaScript: bash and node (Node.js).\nPython: bash, python and pip.\nR: bash and R.\nScala: bash, openjdk-devel and sbt.\n\n:::"
  },
  {
    "objectID": "guide/component/variables.html",
    "href": "guide/component/variables.html",
    "title": "Par and meta variables",
    "section": "",
    "text": "When running a Viash component with viash run, Viash will wrap your script into a Bash executable. In doing so, it strips away the “Viash placeholder” code block and replaces it by a bit of code to your script for reading any parameter values at runtime."
  },
  {
    "objectID": "guide/component/variables.html#recognizing-the-viash-placeholder-code-block",
    "href": "guide/component/variables.html#recognizing-the-viash-placeholder-code-block",
    "title": "Par and meta variables",
    "section": "Recognizing the Viash placeholder code block",
    "text": "Recognizing the Viash placeholder code block\nRecall what the script of the previous example looks like:\n\nBashC#JavaScriptPythonRScala\n\n\n\n#!/bin/bash\n\n## VIASH START\npar_input=path/to/file.txt\npar_output=output.txt\n## VIASH END\n\n# copy file\necho \"Copying '$par_input' to '$par_output'.\"\ncp -r \"$par_input\" \"$par_output\"\n\n\n\n\nusing System.IO;\n\n// VIASH START\nvar par = new {\n  input = \"path/to/file.txt\",\n  output = \"output.txt\"\n};\n// VIASH END\n\n// copy file\nConsole.WriteLine($\"Copying '{par.input}' to '{par.output}'.\");\nFile.Copy(par.input, par.output, true);\n\n\n\n\nconst fs = require('fs');\n\n// VIASH START\nlet par = {\n  'input': 'path/to/file.txt',\n  'output': 'output.txt'\n};\n// VIASH END\n\n// copy file\nconsole.log(`Copying '${par['input']}' to '${par['output']}'`)\nfs.copyFile(par['input'], par['output'], (err) => {\n  if (err) throw err;\n});\n\n\n\n\nimport shutil\n\n## VIASH START\npar = {\n  'input': 'file.txt',\n  'output': 'output.txt'\n}\n## VIASH END\n\n# copy file\nprint(f\"Copying '{par['input']}' to '{par['output']}'.\")\nshutil.copyfile(par['input'], par['output'])\n\n\n\n\n## VIASH START\npar <- list(\n  \"input\" = 'file.txt',\n  \"output\" = 'output.txt'\n)\n## VIASH END\n\n# copy file\ncat(\"Copying '\", par$input, \"' to '\", par$output, \"'.\\n\", sep = \"\")\nfile.copy(par$input, par$output)\n\n\n\n\nimport java.nio.file.StandardCopyOption.REPLACE_EXISTING\nimport java.nio.file.Files\nimport java.nio.file.Paths\n\n// VIASH START\ncase class ViashPar(input: String, output: String)\nval par = ViashPar(\n  \"path/to/file.txt\",\n  \"output.txt\"\n)\n// VIASH END\n\n// copy file\nprintln(s\"Copying '${par.input}' to '${par.output}'.\")\nval fileIn = Paths.get(par.input)\nval fileOut = Paths.get(par.output)\nFiles.copy(fileIn, fileOut, REPLACE_EXISTING)\n\n\n\n\nA “Viash placeholder” code block is the section between the VIASH START and VIASH END comments."
  },
  {
    "objectID": "guide/component/variables.html#what-happens-at-runtime",
    "href": "guide/component/variables.html#what-happens-at-runtime",
    "title": "Par and meta variables",
    "section": "What happens at runtime",
    "text": "What happens at runtime\nBy passing arguments to the component, Viash will add your parameter values to your script by replacing the Viash placeholder code block. If no such code block exists yet, the parameters are inserted at the top of the file.\nThe resulting code block will contain two maps (or dictionaries): par and meta. The par map contains the parameter values specified by the user, and meta contains additional information on the current runtime environment. Note that for Bash scripts, the par and meta maps are flattened into separate environment variables."
  },
  {
    "objectID": "guide/component/variables.html#previewing-the-par-and-meta-objects",
    "href": "guide/component/variables.html#previewing-the-par-and-meta-objects",
    "title": "Par and meta variables",
    "section": "Previewing the par and meta objects",
    "text": "Previewing the par and meta objects\nTo get insight into how par and meta are defined, you can run viash config inject to replace the current parameter placeholder with an auto-generated parameter placeholder.\n\n\n\n\n\n\nWarning\n\n\n\nThis will change the contents of your script!\n\n\n\nBashC#JavaScriptPythonRScala\n\n\nRunning viash config inject effectively changes the contents of the script.\n\nviash config inject config.vsh.yaml\n\nThe updated script.sh now contains the following code:\n\n\n#!/bin/bash\n\n## VIASH START\n# The following code has been auto-generated by Viash.\npar_input='file.txt'\npar_output='output.txt'\nmeta_functionality_name='example_bash'\nmeta_resources_dir='/tmp/viash_inject_example_bash10775606330937480613'\nmeta_executable='/tmp/viash_inject_example_bash10775606330937480613/example_bash'\nmeta_config='/tmp/viash_inject_example_bash10775606330937480613/.config.vsh.yaml'\nmeta_temp_dir='/tmp'\nmeta_cpus='123'\nmeta_memory_b='123'\nmeta_memory_kb='123'\nmeta_memory_mb='123'\nmeta_memory_gb='123'\nmeta_memory_tb='123'\nmeta_memory_pb='123'\n\n## VIASH END\n\n# copy file\necho \"Copying '$par_input' to '$par_output'.\"\ncp -r \"$par_input\" \"$par_output\"\n\n\n\nRunning viash config inject effectively changes the contents of the script.\n\nviash config inject config.vsh.yaml\n\nThe updated script.csx now contains the following code:\n\n\nusing System.IO;\n\n// VIASH START\n// The following code has been auto-generated by Viash.\nvar par = new {\n  input = @\"file.txt\",\n  output = @\"output.txt\"\n};\nvar meta = new {\n  functionality_name = @\"example_csharp\",\n  resources_dir = @\"/tmp/viash_inject_example_csharp17500646433757960722\",\n  executable = @\"/tmp/viash_inject_example_csharp17500646433757960722/example_csharp\",\n  config = @\"/tmp/viash_inject_example_csharp17500646433757960722/.config.vsh.yaml\",\n  temp_dir = @\"/tmp\",\n  cpus = Convert.ToInt32(@\"123\"),\n  memory_b = Convert.ToInt64(@\"123\"),\n  memory_kb = Convert.ToInt64(@\"123\"),\n  memory_mb = Convert.ToInt64(@\"123\"),\n  memory_gb = Convert.ToInt64(@\"123\"),\n  memory_tb = Convert.ToInt64(@\"123\"),\n  memory_pb = Convert.ToInt64(@\"123\")\n};\n\n// VIASH END\n\n// copy file\nConsole.WriteLine($\"Copying '{par.input}' to '{par.output}'.\");\nFile.Copy(par.input, par.output, true);\n\n\n\nRunning viash config inject effectively changes the contents of the script.\n\nviash config inject config.vsh.yaml\n\nThe updated script.js now contains the following code:\n\n\nconst fs = require('fs');\n\n// VIASH START\n// The following code has been auto-generated by Viash.\nlet par = {\n  'input': String.raw`file.txt`,\n  'output': String.raw`output.txt`\n};\nlet meta = {\n  'functionality_name': String.raw`example_js`,\n  'resources_dir': String.raw`/tmp/viash_inject_example_js3863114924390663847`,\n  'executable': String.raw`/tmp/viash_inject_example_js3863114924390663847/example_js`,\n  'config': String.raw`/tmp/viash_inject_example_js3863114924390663847/.config.vsh.yaml`,\n  'temp_dir': String.raw`/tmp`,\n  'cpus': parseInt(String.raw`123`),\n  'memory_b': parseInt(String.raw`123`),\n  'memory_kb': parseInt(String.raw`123`),\n  'memory_mb': parseInt(String.raw`123`),\n  'memory_gb': parseInt(String.raw`123`),\n  'memory_tb': parseInt(String.raw`123`),\n  'memory_pb': parseInt(String.raw`123`)\n};\n\n// VIASH END\n\n// copy file\nconsole.log(`Copying '${par['input']}' to '${par['output']}'`)\nfs.copyFile(par['input'], par['output'], (err) => {\n  if (err) throw err;\n});\n\n\n\nRunning viash config inject effectively changes the contents of the script.\n\nviash config inject config.vsh.yaml\n\nThe updated script.py now contains the following code:\n\n\nimport shutil\n\n## VIASH START\n# The following code has been auto-generated by Viash.\npar = {\n  'input': r'file.txt',\n  'output': r'output.txt'\n}\nmeta = {\n  'functionality_name': r'example_python',\n  'resources_dir': r'/tmp/viash_inject_example_python4034182122965712177',\n  'executable': r'/tmp/viash_inject_example_python4034182122965712177/example_python',\n  'config': r'/tmp/viash_inject_example_python4034182122965712177/.config.vsh.yaml',\n  'temp_dir': r'/tmp',\n  'cpus': int(r'123'),\n  'memory_b': int(r'123'),\n  'memory_kb': int(r'123'),\n  'memory_mb': int(r'123'),\n  'memory_gb': int(r'123'),\n  'memory_tb': int(r'123'),\n  'memory_pb': int(r'123')\n}\n\n## VIASH END\n\n# copy file\nprint(f\"Copying '{par['input']}' to '{par['output']}'.\")\nshutil.copyfile(par['input'], par['output'])\n\n\n\nRunning viash config inject effectively changes the contents of the script.\n\nviash config inject config.vsh.yaml\n\nThe updated script.R now contains the following code:\n\n\n## VIASH START\n# The following code has been auto-generated by Viash.\n# treat warnings as errors\n.viash_orig_warn <- options(warn = 2)\n\npar <- list(\n  \"input\" = 'file.txt',\n  \"output\" = 'output.txt'\n)\nmeta <- list(\n  \"functionality_name\" = 'example_r',\n  \"resources_dir\" = '/tmp/viash_inject_example_r13111980614538520419',\n  \"executable\" = '/tmp/viash_inject_example_r13111980614538520419/example_r',\n  \"config\" = '/tmp/viash_inject_example_r13111980614538520419/.config.vsh.yaml',\n  \"temp_dir\" = '/tmp',\n  \"cpus\" = as.integer('123'),\n  \"memory_b\" = bit64::as.integer64('123'),\n  \"memory_kb\" = bit64::as.integer64('123'),\n  \"memory_mb\" = bit64::as.integer64('123'),\n  \"memory_gb\" = bit64::as.integer64('123'),\n  \"memory_tb\" = bit64::as.integer64('123'),\n  \"memory_pb\" = bit64::as.integer64('123')\n)\n\n\n# restore original warn setting\noptions(.viash_orig_warn)\nrm(.viash_orig_warn)\n\n## VIASH END\n\n# copy file\ncat(\"Copying '\", par$input, \"' to '\", par$output, \"'.\\n\", sep = \"\")\nfile.copy(par$input, par$output)\n\n\n\nRunning viash config inject effectively changes the contents of the script.\n\nviash config inject config.vsh.yaml\n\nThe updated script.scala now contains the following code:\n\n\nimport java.nio.file.StandardCopyOption.REPLACE_EXISTING\nimport java.nio.file.Files\nimport java.nio.file.Paths\n\n// VIASH START\n// The following code has been auto-generated by Viash.\ncase class ViashPar(\n  input: Option[String],\n  output: Option[String]\n)\nval par = ViashPar(\n  Some(\"\"\"file.txt\"\"\"),\n  Some(\"\"\"output.txt\"\"\")\n)\ncase class ViashMeta(\n  functionality_name: Option[String],\n  resources_dir: Option[String],\n  executable: Option[String],\n  config: Option[String],\n  temp_dir: Option[String],\n  cpus: Option[Int],\n  memory_b: Option[Long],\n  memory_kb: Option[Long],\n  memory_mb: Option[Long],\n  memory_gb: Option[Long],\n  memory_tb: Option[Long],\n  memory_pb: Option[Long]\n)\nval meta = ViashMeta(\n  Some(\"\"\"example_scala\"\"\"),\n  Some(\"\"\"/tmp/viash_inject_example_scala1492153645110897133\"\"\"),\n  Some(\"\"\"/tmp/viash_inject_example_scala1492153645110897133/example_scala\"\"\"),\n  Some(\"\"\"/tmp/viash_inject_example_scala1492153645110897133/.config.vsh.yaml\"\"\"),\n  Some(\"\"\"/tmp\"\"\"),\n  Some(\"\"\"123\"\"\".toInt),\n  Some(\"\"\"123\"\"\".toLong),\n  Some(\"\"\"123\"\"\".toLong),\n  Some(\"\"\"123\"\"\".toLong),\n  Some(\"\"\"123\"\"\".toLong),\n  Some(\"\"\"123\"\"\".toLong),\n  Some(\"\"\"123\"\"\".toLong)\n)\n\n// VIASH END\n\n// copy file\nprintln(s\"Copying '${par.input}' to '${par.output}'.\")\nval fileIn = Paths.get(par.input)\nval fileOut = Paths.get(par.output)\nFiles.copy(fileIn, fileOut, REPLACE_EXISTING)"
  },
  {
    "objectID": "guide/component/variables.html#runtime-parameters-in-par",
    "href": "guide/component/variables.html#runtime-parameters-in-par",
    "title": "Par and meta variables",
    "section": "Runtime parameters in par",
    "text": "Runtime parameters in par\nThe par object (or par_ environment variables in Bash) will contain argument values passed at runtime. For example, passing --input foo.txt will result in a par[\"input\"] being equal to \"foo.txt\".\n\n\n\n\n\n\nTip\n\n\n\nTry adding more arguments with different file types to see what effect this has on the resulting placeholder."
  },
  {
    "objectID": "guide/component/variables.html#meta-variables-in-meta",
    "href": "guide/component/variables.html#meta-variables-in-meta",
    "title": "Par and meta variables",
    "section": "Meta variables in meta",
    "text": "Meta variables in meta\nMeta-variables offer information on the runtime environment which you can use from within your script.\n\ncpus (integer): The maximum number of (logical) cpus a component is allowed to use. By default, this value will be undefined.\nconfig (string): Path to the processed Viash config YAML. This file is usually called .config.vsh.yaml and resides next to the wrapped executable (see below). This YAML file is useful for doing some runtime introspection of the component for writing generic unit tests.\nexecutable (string): The executable being used at runtime; that is, the wrapped script. This variable is used in unit tests.\nfunctionality_name (string): The name of the component, useful for logging.\nmemory_* (long): The maximum amount of memory a component is allowed to allocate. The following denominations are provided: memory_b, memory_kb, memory_mb, memory_gb, memory_tb, memory_pb. By default, this value will be undefined.\nresources_dir (string): Path to where the resources are stored. See the previous section on how to define resources.\ntemp_dir (string): A temporary directory in which your script is allowed to create new temporary files / directories. By default, this will be set to the VIASH_TEMP environment variable. When the VIASH_TEMP variable is undefined, /tmp is used instead.\n\n\n\ncpus (integer)\nThis field specifies the maximum number of (logical) cpus a component is allowed to use. This is useful when parallellizing your component in such a way that integrates very nicely with pipeline frameworks such as Nextflow. Below is an example usage of the cpus meta-variable.\n\nBashC#JavaScriptPythonRScala\n\n\n#!/bin/bash\n\n## VIASH START\npar_input=\"path/to/file.txt\"\npar_output=\"output.txt\"\nmeta_cpus=10\n## VIASH END\n\n# Pass number of cores to the popular_software_tool. Set the default to 1.\n./popular_software_tool --ncores ${meta_cpus:-1}\n\n\nNo example available yet.\n\n\nNo example available yet.\n\n\nfrom multiprocessing import Pool\n\n## VIASH START\npar = {}\nmeta = {\"cpus\": 1}\n## VIASH END\n\ndef my_fun(x):\n    return x + \"!\"\nmy_data = [\"hello\", \"world\"]\n\nwith Pool(processes=meta.get(\"cpus\", 1)) as pool:\n    out = pool.map(my_fun, my_data)\n\n\nlibrary(furrr)\n\n## VIASH START\npar <- list()\nmeta <- list(\n  cpus = 1L\n)\n## VIASH END\n\nif (is.null(meta$cpus)) meta$cpus <- 1\nplan(multisession, workers = meta$cpus)\n\nmy_data <- c(\"hello\", \"world\")\nout = future_map(\n  my_data, \n  function(x) {\n    paste0(x, \"!\")\n  }\n)\n\n\nimport scala.collection.parallel._\nimport java.util.concurrent.ForkJoinPool\n\n// VIASH START\n// ...\n// VIASH END\n\nval pc = mutable.ParArray(1, 2, 3)\nval numCores = meta.cores.getOrElse(1)\npc.tasksupport = new ForkJoinTaskSupport(new ForkJoinPool(numCores))\npc map { _ + 1 }\n\n\n\nYou can set the number of cores in your component using any of the following approaches:\n# as a parameter of viash run\nviash run config.vsh.yaml --cpus 10 -- <my component arguments>\n\n# as a parameter of viash test\nviash test config.vsh.yaml --cpus 10\n\n# or as a parameter of the executable\nviash build config.vsh.yaml -o output\noutput/my_executable ---cpus 10\n#                     ↑ notice the triple dash"
  },
  {
    "objectID": "guide/component/add-resources.html",
    "href": "guide/component/add-resources.html",
    "title": "Add resources",
    "section": "",
    "text": "If a script needs access to an external file, it needs to be added as a resource in the config.\nFirst, create a file called my_file.txt.\n\nBashC#JavaScriptPythonRScala\n\n\n\necho 'Here are the contents of my_file.txt' > my_file.txt\n\n\n\n\necho 'Here are the contents of my_file.txt' > my_file.txt\n\n\n\n\necho 'Here are the contents of my_file.txt' > my_file.txt\n\n\n\n\necho 'Here are the contents of my_file.txt' > my_file.txt\n\n\n\n\necho 'Here are the contents of my_file.txt' > my_file.txt\n\n\n\n\necho 'Here are the contents of my_file.txt' > my_file.txt\n\n\n\n\nNext, the file needs to be added to the config as a resource. This will let Viash know to copy the new file inside a component’s resource directory.\n\nBashC#JavaScriptPythonRScala\n\n\nfunctionality:\n  name: example_bash\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: bash_script\n      path: script.sh\n    - path: my_file.txt\nplatforms:\n  - type: docker\n    image: bash:4.0\n  - type: native\n  - type: nextflow\n\n\nfunctionality:\n  name: example_csharp\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: csharp_script\n      path: script.csx\n    - path: my_file.txt\nplatforms:\n  - type: docker\n    image: ghcr.io/data-intuitive/dotnet-script:1.3.1\n  - type: native\n  - type: nextflow\n\n\nfunctionality:\n  name: example_js\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: javascript_script\n      path: script.js\n    - path: my_file.txt\nplatforms:\n  - type: docker\n    image: node:19-bullseye\n  - type: native\n  - type: nextflow\n\n\nfunctionality:\n  name: example_python\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: python_script\n      path: script.py\n    - path: my_file.txt\nplatforms:\n  - type: docker\n    image: python:3.10\n  - type: native\n  - type: nextflow\n\n\nfunctionality:\n  name: example_r\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: r_script\n      path: script.R\n    - path: my_file.txt\nplatforms:\n  - type: docker\n    image: eddelbuettel/r2u:22.04\n  - type: native\n  - type: nextflow\n\n\nfunctionality:\n  name: example_scala\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: scala_script\n      path: script.scala\n    - path: my_file.txt\nplatforms:\n  - type: docker\n    image: sbtscala/scala-sbt:eclipse-temurin-19_36_1.7.2_2.13.10\n  - type: native\n  - type: nextflow\n\n\n\nLastly, to access a resource from within the script, use the resources_dir meta-variable:\n\nBashC#JavaScriptPythonRScala\n\n\n#!/bin/bash\n\n## VIASH START\npar_input=path/to/file.txt\npar_output=output.txt\n## VIASH END\n\n# view resource file\ncat \"$meta_resources_dir/my_file.txt\"\n\n# copy file\necho \"Copying '$par_input' to '$par_output'.\"\ncp -r \"$par_input\" \"$par_output\"\n\n\nusing System.IO;\n\n// VIASH START\nvar par = new {\n  input = \"path/to/file.txt\",\n  output = \"output.txt\"\n};\n// VIASH END\n\n// view resource file\nstring myFile = $\"{meta.resources_dir}/my_file.txt\";\nstring text = File.ReadAllText(myFile);\nConsole.WriteLine(text);\n\n// copy file\nConsole.WriteLine($\"Copying '{par.input}' to '{par.output}'.\");\nFile.Copy(par.input, par.output, true);\n\n\nconst fs = require('fs');\n\n// VIASH START\nlet par = {\n  'input': 'path/to/file.txt',\n  'output': 'output.txt'\n};\n// VIASH END\n\n// view resource file\nconst my_file = `${meta['resources_dir']}/my_file.txt`\nfs.readFile(my_file, 'utf8', (err, data) => {\n  if (err) throw err;\n  console.log(data);\n});\n\n// copy file\nconsole.log(`Copying '${par['input']}' to '${par['output']}'`)\nfs.copyFile(par['input'], par['output'], (err) => {\n  if (err) throw err;\n});\n\n\nimport shutil\n\n## VIASH START\npar = {\n  'input': 'file.txt',\n  'output': 'output.txt'\n}\n## VIASH END\n\n# view resource file\nmy_file = f\"{meta['resources_dir']}/my_file.txt\"\nwith open(my_file, \"r\") as f:\n  print(f.read())\n\n# copy file\nprint(f\"Copying '{par['input']}' to '{par['output']}'.\")\nshutil.copyfile(par['input'], par['output'])\n\n\n## VIASH START\npar <- list(\n  \"input\" = 'file.txt',\n  \"output\" = 'output.txt'\n)\n## VIASH END\n\n# view resource file\nlines <- readLines(paste0(meta$resources_dir, \"/my_file.txt\"))\ncat(lines, sep = \"\\n\")\n\n# copy file\ncat(\"Copying '\", par$input, \"' to '\", par$output, \"'.\\n\", sep = \"\")\nfile.copy(par$input, par$output)\n\n\nimport java.nio.file.StandardCopyOption.REPLACE_EXISTING\nimport java.nio.file.Files\nimport java.nio.file.Paths\n\n// VIASH START\ncase class ViashPar(input: String, output: String)\nval par = ViashPar(\n  \"path/to/file.txt\",\n  \"output.txt\"\n)\n// VIASH END\n\n// view resource file\nval myFile = s\"${meta.resources_dir}/my_file.txt\"\nval src = scala.io.Source.fromFile(myFile)\nsrc.getLines.foreach(println)\n\n// copy file\nprintln(s\"Copying '${par.input}' to '${par.output}'.\")\nval fileIn = Paths.get(par.input)\nval fileOut = Paths.get(par.output)\nFiles.copy(fileIn, fileOut, REPLACE_EXISTING)\n\n\n\nNow we can run the component as follows:\n\nBashC#JavaScriptPythonRScala\n\n\n\nviash run config.vsh.yaml -- --input config.vsh.yaml --output foo.txt\n\n[notice] Checking if Docker image is available at 'example_bash:latest'\n[warning] Could not pull from 'example_bash:latest'. Docker image doesn't exist or is not accessible.\n[notice] Building container 'example_bash:latest' with Dockerfile\nHere are the contents of my_file.txt\nCopying '/viash_automount/tmp/RtmpJFovuO/add-dependencies61b66b439aa7/bash/config.vsh.yaml' to '/viash_automount/tmp/RtmpJFovuO/add-dependencies61b66b439aa7/bash/foo.txt'.\n\n\n\n\n\nviash run config.vsh.yaml -- --input config.vsh.yaml --output foo.txt\n\n[notice] Checking if Docker image is available at 'example_csharp:latest'\n[warning] Could not pull from 'example_csharp:latest'. Docker image doesn't exist or is not accessible.\n[notice] Building container 'example_csharp:latest' with Dockerfile\nHere are the contents of my_file.txt\n\nCopying '/viash_automount/tmp/RtmpJFovuO/add-dependencies61b66b439aa7/csharp/config.vsh.yaml' to '/viash_automount/tmp/RtmpJFovuO/add-dependencies61b66b439aa7/csharp/foo.txt'.\n\n\n\n\n\nviash run config.vsh.yaml -- --input config.vsh.yaml --output foo.txt\n\n[notice] Checking if Docker image is available at 'example_js:latest'\n[warning] Could not pull from 'example_js:latest'. Docker image doesn't exist or is not accessible.\n[notice] Building container 'example_js:latest' with Dockerfile\nCopying '/viash_automount/tmp/RtmpJFovuO/add-dependencies61b66b439aa7/js/config.vsh.yaml' to '/viash_automount/tmp/RtmpJFovuO/add-dependencies61b66b439aa7/js/foo.txt'\nHere are the contents of my_file.txt\n\n\n\n\n\nviash run config.vsh.yaml -- --input config.vsh.yaml --output foo.txt\n\n[notice] Checking if Docker image is available at 'example_python:latest'\n[warning] Could not pull from 'example_python:latest'. Docker image doesn't exist or is not accessible.\n[notice] Building container 'example_python:latest' with Dockerfile\nHere are the contents of my_file.txt\n\nCopying '/viash_automount/tmp/RtmpJFovuO/add-dependencies61b66b439aa7/python/config.vsh.yaml' to '/viash_automount/tmp/RtmpJFovuO/add-dependencies61b66b439aa7/python/foo.txt'.\n\n\n\n\n\nviash run config.vsh.yaml -- --input config.vsh.yaml --output foo.txt\n\n[notice] Checking if Docker image is available at 'example_r:latest'\n[warning] Could not pull from 'example_r:latest'. Docker image doesn't exist or is not accessible.\n[notice] Building container 'example_r:latest' with Dockerfile\nHere are the contents of my_file.txt\nCopying '/viash_automount/tmp/RtmpJFovuO/add-dependencies61b66b439aa7/r/config.vsh.yaml' to '/viash_automount/tmp/RtmpJFovuO/add-dependencies61b66b439aa7/r/foo.txt'.\n[1] TRUE\n\n\n\n\n\nviash run config.vsh.yaml -- --input config.vsh.yaml --output foo.txt\n\n[notice] Checking if Docker image is available at 'example_scala:latest'\n[warning] Could not pull from 'example_scala:latest'. Docker image doesn't exist or is not accessible.\n[notice] Building container 'example_scala:latest' with Dockerfile\nwarning: 1 deprecation\nwarning: 1 deprecation (since 2.13.3)\nwarning: 2 deprecations in total; re-run with -deprecation for details\nHere are the contents of my_file.txt\nCopying '/viash_automount/tmp/RtmpJFovuO/add-dependencies61b66b439aa7/scala/config.vsh.yaml' to '/viash_automount/tmp/RtmpJFovuO/add-dependencies61b66b439aa7/scala/foo.txt'."
  },
  {
    "objectID": "guide/component/unit-testing.html",
    "href": "guide/component/unit-testing.html",
    "title": "Unit testing",
    "section": "",
    "text": "We recommend adding unit tests to all of your components in a project as soon as possible. Implementing unit tests not only ensures that your component works, but it also makes the project more maintainable in the long run as you will be notified when a component breaks.\nThis page describes how to add a unit test to your component."
  },
  {
    "objectID": "guide/component/unit-testing.html#create-unit-test",
    "href": "guide/component/unit-testing.html#create-unit-test",
    "title": "Unit testing",
    "section": "Create unit test",
    "text": "Create unit test\nBelow is an example of how to add a unit test to a Viash component.\n\nBashC#JavaScriptPythonRScala\n\n\n#!/bin/bash\n\n## VIASH START\nmeta_executable=\"target/example_bash\"\n## VIASH END\n\necho \">>> Create input test file\"\necho \"foo\" > foo.txt\n\necho \">>> Run executable\"\n$meta_executable --input foo.txt --output bar.txt\n\necho \">>> Check whether output file exists\"\n[[ -f bar.txt ]] (echo \"Output file could not be found!\" && exit 1)\n\necho \">>> Check whether input and output file are the same\"\ncmp foo.txt bar.tx (echo \"Input and output files are different!\" && exit 1)\n\necho \">>> Test finished successfully\"\n\n\nusing System;\nusing System.IO;\nusing System.Diagnostics;\n\n// VIASH START\nvar meta = new {\n  executable = \"target/example_csharp\"\n};\n// VIASH END\n\nstring inputPath = \"foo.txt\";\nstring outputPath = \"bar.txt\";\nstring content = \"hello\\nthere\\n\";\n\nConsole.WriteLine(\">>> Create input test file\");\nFile.WriteAllText(inputPath, content);\n\nConsole.WriteLine(\">>> Run executable\");\n\nvar startInfo = new ProcessStartInfo(meta.executable)\n{\n    Arguments = $\"--input {inputPath} --output {outputPath}\",\n    UseShellExecute = false,\n    RedirectStandardOutput = true,\n    CreateNoWindow = true\n};\nusing(var cmd = Process.Start(startInfo))\n{\n    cmd.WaitForExit();\n}\n\n\nConsole.WriteLine(\">>> Check whether output file exists\");\nif (!File.Exists(outputPath)) {\n    Console.WriteLine(\"Output file was not found\");\n    Environment.Exit(1);\n}\n\nConsole.WriteLine(\">>> Check whether input and output file are the same\");\nvar outputLines = File.ReadAllText(outputPath);\nif (content != outputLines) {\n    Console.WriteLine(\n        \"Input and output should be the same\\n\" +\n        $\"expected content: {content}\\n\" +\n        $\"found: {outputLines}\\n\"\n    );\n    Environment.Exit(1);\n}\n\nConsole.WriteLine(\">>> Test finished successfully\");\n\n\nconst fs = require('fs');\nconst child_process = require('child_process');\n\n// VIASH START\nlet meta = {\n  'executable': 'target/example_js'\n};\n// VIASH END\n\nconst inputPath = 'foo.txt';\nconst outputPath = 'bar.txt';\nconst content = 'hello\\nthere\\n';\n\nconsole.log('>>> Create input test file');\nfs.writeFileSync(inputPath, content, 'utf8');\n\nconsole.log('>>> Run executable');\nconst cmdArgs = [\n  '--input', inputPath,\n  '--output', outputPath\n];\nconst child = child_process.spawnSync(meta[\"executable\"], cmdArgs);\nif (child.error) {\n  console.error(`Error: ${child.error}`);\n  process.exit(1);\n}\n\nconsole.log('>>> Check whether output file exists');\nif (!fs.existsSync(outputPath)) {\n  console.error('Output file was not found');\n  process.exit(1);\n}\n\nconsole.log('>>> Check whether input and output file are the same');\nconst outputLines = fs.readFileSync(outputPath, 'utf8');\nif (content !== outputLines) {\n  console.error(\n    `Input and output should be the same\\n` +\n    `expected content: ${content}\\n` +\n    `found: ${outputLines}\\n`\n  );\n  process.exit(1);\n}\n\nconsole.log('>>> Test finished successfully');\n\n\nimport subprocess\nimport os\n\ninput_path = \"foo.txt\"\noutput_path = \"bar.txt\"\ncontent = \"hello\\nthere\\n\"\n\n## VIASH START\nmeta = {\n  \"executable\": \"target/example_python\"\n}\n## VIASH END\n\nprint(\">>> Create input test file\")\nwith open(input_path, \"w\") as file:\n  file.write(content)\n\nprint(\">>> Run executable\")\ncmd_args = [\n  meta[\"executable\"],\n  \"--input\", input_path,\n  \"--output\", output_path\n]\nsubprocess.run(cmd_args, check=True)\n\nprint(\">>> Check whether output file exists\")\nassert os.path.exists(output_path), \"Output file was not found\"\n\nprint(\">>> Check whether input and output file are the same\")\nwith open(output_path, \"r\", encoding=\"utf8\") as file:\n  output_lines = file.read()\n\nassert content == output_lines, \\\n  \"Input and output should be the same\" \\\n  f\"expected content: {content}\" \\\n  f\"found: {output_lines}\"\n\nprint(\">>> Test finished successfully\")\n\n\n## VIASH START\nmeta <- list(\n  \"target/example_r\"\n)\n## VIASH END\n\ninput_path <- \"foo.txt\"\noutput_path <- \"bar.txt\"\ncontent <- c(\"hello\", \"there\")\n\ncat(\">>> Create input test file\\n\")\nwriteLines(content, input_path)\n\ncat(\">>> Run executable\\n\")\nsystem2(\n  meta$executable,\n  c(\n    \"--input\", input_path,\n    \"--output\", output_path\n  )\n)\n\ncat(\">>> Check whether output file exists\\n\")\nif (!file.exists(output_path)) {\n  stop(\"Output file was not found\")\n}\n\ncat(\">>> Check whether input and output file are the same\\n\")\noutput_lines <- readLines(output_path)\n\nif (!identical(content, output_lines)) {\n  stop(paste0(\n    \"Input and output should be the same\\n\",\n    \"expected content: \", content, \"\\n\",\n    \"found: \", output_lines, \"\\n\"\n  ))\n}\n\ncat(\">>> Test finished successfully\\n\")\n\n\nimport scala.sys.process._\nimport java.nio.file.{Files, Paths}\nimport scala.io.Source\n\n// VIASH START\ncase class ViashMeta(executable: String)\nval meta = ViashMeta(\n  \"target/example_scala\"\n)\n// VIASH END\nval inputPath = Paths.get(\"foo.txt\")\nval outputPath = Paths.get(\"bar.txt\")\nval content = \"hello\\nthere\"\n\nprintln(\">>> Create input test file\")\nFiles.write(inputPath, content.getBytes(\"UTF-8\"))\n\nprintln(\">>> Run executable\")\ns\"${meta.executable} --input $inputPath --output $outputPath\".!\n\nprintln(\">>> Check whether output file exists\")\nassert(Files.exists(outputPath), \"Output file not found\")\n\nprintln(\">>> Check whether input and output file are the same\")\nval outputLines = Source.fromFile(outputPath.toFile()).getLines.mkString(\"\\n\")\nassert(\n  content == outputLines, \n  s\"\"\"Output not the same\nexpected: '$content'\nfound: '$outputLines'\n\"\"\".stripMargin\n)\n\nprintln(\">>> Test finished successfully\")\n\n\n\n\nCreate an input file “foo.txt” with some sample content.\nRun an executable file specified in the “meta” dictionary with the arguments “–input foo.txt” and “–output bar.txt”.\nCheck whether the output file “bar.txt” exists.\nCheck whether the content of the output file is the same as the content of the input file.\nIf both checks pass, the script prints “Test finished successfully”.\n\n\n\n\n\n\n\nImportant\n\n\n\nA test script doesn’t need to be written in the same scripting language as the main script, as long as all of the required dependencies are available. This means the main script could be written in R, but the unit test could be written in Bash."
  },
  {
    "objectID": "guide/component/unit-testing.html#add-test-to-config",
    "href": "guide/component/unit-testing.html#add-test-to-config",
    "title": "Unit testing",
    "section": "Add test to config",
    "text": "Add test to config\nNext, we need to add the unit test to the test_resources section in the Viash config.\n\nBashC#JavaScriptPythonRScala\n\n\nfunctionality:\n  name: example_bash\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: bash_script\n      path: script.sh\n  test_resources:\n    - type: bash_script\n      path: test.sh\nplatforms:\n  - type: docker\n    image: bash:4.0\n  - type: native\n  - type: nextflow\n\n\nfunctionality:\n  name: example_csharp\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: csharp_script\n      path: script.csx\n  test_resources:\n    - type: csharp_script\n      path: test.csx\nplatforms:\n  - type: docker\n    image: ghcr.io/data-intuitive/dotnet-script:1.3.1\n  - type: native\n  - type: nextflow\n\n\nfunctionality:\n  name: example_js\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: javascript_script\n      path: script.js\n  test_resources:\n    - type: javascript_script\n      path: test.js\nplatforms:\n  - type: docker\n    image: node:19-bullseye\n  - type: native\n  - type: nextflow\n\n\nfunctionality:\n  name: example_python\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: python_script\n      path: script.py\n  test_resources:\n    - type: python_script\n      path: test.py\nplatforms:\n  - type: docker\n    image: python:3.10\n  - type: native\n  - type: nextflow\n\n\nfunctionality:\n  name: example_r\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: r_script\n      path: script.R\n  test_resources:\n    - type: r_script\n      path: test.R\nplatforms:\n  - type: docker\n    image: eddelbuettel/r2u:22.04\n  - type: native\n  - type: nextflow\n\n\nfunctionality:\n  name: example_scala\n  description: A minimal example component.\n  arguments:\n    - type: file\n      name: --input\n      example: file.txt\n      required: true\n    - type: file\n      name: --output\n      direction: output\n      example: output.txt\n      required: true\n  resources:\n    - type: scala_script\n      path: script.scala\n  test_resources:\n    - type: scala_script\n      path: test.scala\nplatforms:\n  - type: docker\n    image: sbtscala/scala-sbt:eclipse-temurin-19_36_1.7.2_2.13.10\n  - type: native\n  - type: nextflow\n\n\n\nNote that if you can add multiple unit tests to the test_resources section, they will all be evaluated. You can also add other resources, similar to what is described in the page on adding resources."
  },
  {
    "objectID": "guide/component/unit-testing.html#run-the-unit-test",
    "href": "guide/component/unit-testing.html#run-the-unit-test",
    "title": "Unit testing",
    "section": "Run the unit test",
    "text": "Run the unit test\nYou can run the unit test as follows:\n\nBashC#JavaScriptPythonRScala\n\n\n\nviash test config.vsh.yaml\n\nRunning tests in temporary directory: '/tmp/viash_test_example_bash12837585852020236424'\n====================================================================\n+/tmp/viash_test_example_bash12837585852020236424/build_executable/example_bash ---verbosity 6 ---setup cachedbuild\n[notice] Building container 'example_bash:test_LHg2mg' with Dockerfile\n[info] Running 'docker build -t example_bash:test_LHg2mg /tmp/viash_test_example_bash12837585852020236424/build_executable -f /tmp/viash_test_example_bash12837585852020236424/build_executable/tmp/dockerbuild-example_bash-yNcJHu/Dockerfile'\nSending build context to Docker daemon  37.38kB\n\nStep 1/5 : FROM bash:4.0\n ---> 17aedd57000a\nStep 2/5 : RUN :\n ---> Running in dad550a02a93\nRemoving intermediate container dad550a02a93\n ---> 39ba3db3ecbb\nStep 3/5 : LABEL org.opencontainers.image.description=\"Companion container for running component example_bash\"\n ---> Running in c68e40eae50d\nRemoving intermediate container c68e40eae50d\n ---> 082c2a6be479\nStep 4/5 : LABEL org.opencontainers.image.created=\"2023-02-27T08:14:38Z\"\n ---> Running in 4da4d1c04929\nRemoving intermediate container 4da4d1c04929\n ---> 4ccd2223e9ac\nStep 5/5 : LABEL org.opencontainers.image.version=\"test_LHg2mg\"\n ---> Running in 008169e4a3c5\nRemoving intermediate container 008169e4a3c5\n ---> 2ef88b43f645\nSuccessfully built 2ef88b43f645\nSuccessfully tagged example_bash:test_LHg2mg\n====================================================================\n+/tmp/viash_test_example_bash12837585852020236424/test_test/test_executable\n>>> Create input test file\n>>> Run executable\nCopying 'foo.txt' to 'bar.txt'.\n>>> Check whether output file exists\n>>> Check whether input and output file are the same\n>>> Test finished successfully\n====================================================================\n\u001b[32mSUCCESS! All 1 out of 1 test scripts succeeded!\u001b[0m\nCleaning up temporary directory\n\n\n\n\n\nviash test config.vsh.yaml\n\nRunning tests in temporary directory: '/tmp/viash_test_example_csharp10564426218326143643'\n====================================================================\n+/tmp/viash_test_example_csharp10564426218326143643/build_executable/example_csharp ---verbosity 6 ---setup cachedbuild\n[notice] Building container 'example_csharp:test_A5Okpx' with Dockerfile\n[info] Running 'docker build -t example_csharp:test_A5Okpx /tmp/viash_test_example_csharp10564426218326143643/build_executable -f /tmp/viash_test_example_csharp10564426218326143643/build_executable/tmp/dockerbuild-example_csharp-9Bismo/Dockerfile'\nSending build context to Docker daemon  36.86kB\n\nStep 1/5 : FROM ghcr.io/data-intuitive/dotnet-script:1.3.1\n ---> 1102243946ae\nStep 2/5 : RUN :\n ---> Running in a4ab652c7feb\nRemoving intermediate container a4ab652c7feb\n ---> b98acc4cc0b1\nStep 3/5 : LABEL org.opencontainers.image.description=\"Companion container for running component example_csharp\"\n ---> Running in 16c75c7c48f9\nRemoving intermediate container 16c75c7c48f9\n ---> b8522d9c0a3d\nStep 4/5 : LABEL org.opencontainers.image.created=\"2023-02-27T08:14:49Z\"\n ---> Running in ad7cc34a8626\nRemoving intermediate container ad7cc34a8626\n ---> f7e4159639e5\nStep 5/5 : LABEL org.opencontainers.image.version=\"test_A5Okpx\"\n ---> Running in b6bf687c8991\nRemoving intermediate container b6bf687c8991\n ---> 196977650ce0\nSuccessfully built 196977650ce0\nSuccessfully tagged example_csharp:test_A5Okpx\n====================================================================\n+/tmp/viash_test_example_csharp10564426218326143643/test_test/test_executable\n>>> Create input test file\n>>> Run executable\n>>> Check whether output file exists\n>>> Check whether input and output file are the same\n>>> Test finished successfully\n====================================================================\n\u001b[32mSUCCESS! All 1 out of 1 test scripts succeeded!\u001b[0m\nCleaning up temporary directory\n\n\n\n\n\nviash test config.vsh.yaml\n\nRunning tests in temporary directory: '/tmp/viash_test_example_js1347705850732701736'\n====================================================================\n+/tmp/viash_test_example_js1347705850732701736/build_executable/example_js ---verbosity 6 ---setup cachedbuild\n[notice] Building container 'example_js:test_MO5i5B' with Dockerfile\n[info] Running 'docker build -t example_js:test_MO5i5B /tmp/viash_test_example_js1347705850732701736/build_executable -f /tmp/viash_test_example_js1347705850732701736/build_executable/tmp/dockerbuild-example_js-U3xhcP/Dockerfile'\nSending build context to Docker daemon  37.38kB\n\nStep 1/5 : FROM node:19-bullseye\n ---> 2201f1d2b46f\nStep 2/5 : RUN :\n ---> Running in c8c5fdc009b3\nRemoving intermediate container c8c5fdc009b3\n ---> 264651a20214\nStep 3/5 : LABEL org.opencontainers.image.description=\"Companion container for running component example_js\"\n ---> Running in 854c2ec30269\nRemoving intermediate container 854c2ec30269\n ---> bd541e86bce0\nStep 4/5 : LABEL org.opencontainers.image.created=\"2023-02-27T08:15:07Z\"\n ---> Running in d53a8cd5b5e0\nRemoving intermediate container d53a8cd5b5e0\n ---> 8cf6ebcf6fe7\nStep 5/5 : LABEL org.opencontainers.image.version=\"test_MO5i5B\"\n ---> Running in 5472f1f79a9f\nRemoving intermediate container 5472f1f79a9f\n ---> 143c02c172ea\nSuccessfully built 143c02c172ea\nSuccessfully tagged example_js:test_MO5i5B\n====================================================================\n+/tmp/viash_test_example_js1347705850732701736/test_test/test_executable\n>>> Create input test file\n>>> Run executable\n>>> Check whether output file exists\n>>> Check whether input and output file are the same\n>>> Test finished successfully\n====================================================================\n\u001b[32mSUCCESS! All 1 out of 1 test scripts succeeded!\u001b[0m\nCleaning up temporary directory\n\n\n\n\n\nviash test config.vsh.yaml\n\nRunning tests in temporary directory: '/tmp/viash_test_example_python10976851166814041322'\n====================================================================\n+/tmp/viash_test_example_python10976851166814041322/build_executable/example_python ---verbosity 6 ---setup cachedbuild\n[notice] Building container 'example_python:test_eCC0VD' with Dockerfile\n[info] Running 'docker build -t example_python:test_eCC0VD /tmp/viash_test_example_python10976851166814041322/build_executable -f /tmp/viash_test_example_python10976851166814041322/build_executable/tmp/dockerbuild-example_python-9Q5qve/Dockerfile'\nSending build context to Docker daemon  37.38kB\n\nStep 1/5 : FROM python:3.10\n ---> 45e2736b39fe\nStep 2/5 : RUN :\n ---> Running in 98fc636beaf0\nRemoving intermediate container 98fc636beaf0\n ---> 392ae412358e\nStep 3/5 : LABEL org.opencontainers.image.description=\"Companion container for running component example_python\"\n ---> Running in ff8261c9ec18\nRemoving intermediate container ff8261c9ec18\n ---> f7141f83547a\nStep 4/5 : LABEL org.opencontainers.image.created=\"2023-02-27T08:15:19Z\"\n ---> Running in e3bae1f95a3d\nRemoving intermediate container e3bae1f95a3d\n ---> 4bc2258b2ad8\nStep 5/5 : LABEL org.opencontainers.image.version=\"test_eCC0VD\"\n ---> Running in afb0397dff48\nRemoving intermediate container afb0397dff48\n ---> ba9118ca77a0\nSuccessfully built ba9118ca77a0\nSuccessfully tagged example_python:test_eCC0VD\n====================================================================\n+/tmp/viash_test_example_python10976851166814041322/test_test/test_executable\nCopying 'foo.txt' to 'bar.txt'.\n>>> Create input test file\n>>> Run executable\n>>> Check whether output file exists\n>>> Check whether input and output file are the same\n>>> Test finished successfully\n====================================================================\n\u001b[32mSUCCESS! All 1 out of 1 test scripts succeeded!\u001b[0m\nCleaning up temporary directory\n\n\n\n\n\nviash test config.vsh.yaml\n\nRunning tests in temporary directory: '/tmp/viash_test_example_r5913734992634186464'\n====================================================================\n+/tmp/viash_test_example_r5913734992634186464/build_executable/example_r ---verbosity 6 ---setup cachedbuild\n[notice] Building container 'example_r:test_n8DTj2' with Dockerfile\n[info] Running 'docker build -t example_r:test_n8DTj2 /tmp/viash_test_example_r5913734992634186464/build_executable -f /tmp/viash_test_example_r5913734992634186464/build_executable/tmp/dockerbuild-example_r-DJdnSn/Dockerfile'\nSending build context to Docker daemon  37.89kB\n\nStep 1/5 : FROM eddelbuettel/r2u:22.04\n ---> 38cb61eed28f\nStep 2/5 : RUN :\n ---> Running in 24958089bc80\nRemoving intermediate container 24958089bc80\n ---> b1ec073f6f82\nStep 3/5 : LABEL org.opencontainers.image.description=\"Companion container for running component example_r\"\n ---> Running in 39e563901f7f\nRemoving intermediate container 39e563901f7f\n ---> 766da4e5340b\nStep 4/5 : LABEL org.opencontainers.image.created=\"2023-02-27T08:15:29Z\"\n ---> Running in 8739440513e5\nRemoving intermediate container 8739440513e5\n ---> 26ae0b9ec64e\nStep 5/5 : LABEL org.opencontainers.image.version=\"test_n8DTj2\"\n ---> Running in 624d2dba6d26\nRemoving intermediate container 624d2dba6d26\n ---> 3df6c8b40f5f\nSuccessfully built 3df6c8b40f5f\nSuccessfully tagged example_r:test_n8DTj2\n====================================================================\n+/tmp/viash_test_example_r5913734992634186464/test_test/test_executable\n>>> Create input test file\n>>> Run executable\nCopying 'foo.txt' to 'bar.txt'.\n[1] TRUE\n>>> Check whether output file exists\n>>> Check whether input and output file are the same\n>>> Test finished successfully\n====================================================================\n\u001b[32mSUCCESS! All 1 out of 1 test scripts succeeded!\u001b[0m\nCleaning up temporary directory\n\n\n\n\n\nviash test config.vsh.yaml\n\nRunning tests in temporary directory: '/tmp/viash_test_example_scala6278905015387635018'\n====================================================================\n+/tmp/viash_test_example_scala6278905015387635018/build_executable/example_scala ---verbosity 6 ---setup cachedbuild\n[notice] Building container 'example_scala:test_gWe3Yp' with Dockerfile\n[info] Running 'docker build -t example_scala:test_gWe3Yp /tmp/viash_test_example_scala6278905015387635018/build_executable -f /tmp/viash_test_example_scala6278905015387635018/build_executable/tmp/dockerbuild-example_scala-KfdQGe/Dockerfile'\nSending build context to Docker daemon  37.38kB\n\nStep 1/5 : FROM sbtscala/scala-sbt:eclipse-temurin-19_36_1.7.2_2.13.10\n ---> 76808e2ea8df\nStep 2/5 : RUN :\n ---> Running in 18ba305b1650\nRemoving intermediate container 18ba305b1650\n ---> 66c3b06a3653\nStep 3/5 : LABEL org.opencontainers.image.description=\"Companion container for running component example_scala\"\n ---> Running in 68cc00ba37c1\nRemoving intermediate container 68cc00ba37c1\n ---> 1eb87d33bc64\nStep 4/5 : LABEL org.opencontainers.image.created=\"2023-02-27T08:15:40Z\"\n ---> Running in b15b36e7765f\nRemoving intermediate container b15b36e7765f\n ---> ca00d3a43ad9\nStep 5/5 : LABEL org.opencontainers.image.version=\"test_gWe3Yp\"\n ---> Running in c7e01b1e46c6\nRemoving intermediate container c7e01b1e46c6\n ---> e95f1bcd27af\nSuccessfully built e95f1bcd27af\nSuccessfully tagged example_scala:test_gWe3Yp\n====================================================================\n+/tmp/viash_test_example_scala6278905015387635018/test_test/test_executable\nwarning: 1 deprecation\nwarning: 1 deprecation (since 2.13.3)\nwarning: 2 deprecations in total; re-run with -deprecation for details\n>>> Create input test file\n>>> Run executable\nwarning: 1 deprecation; re-run with -deprecation for details\nCopying 'foo.txt' to 'bar.txt'.\n>>> Check whether output file exists\n>>> Check whether input and output file are the same\n>>> Test finished successfully\n====================================================================\n\u001b[32mSUCCESS! All 1 out of 1 test scripts succeeded!\u001b[0m\nCleaning up temporary directory\n\n\n\n\n\nWhen running viash test, Viash will follow the following steps:\n\nCreate a temporary directory\nBuild the component into the main executable\n(Re-)build the Docker image for the component\nIterate over all unit test scripts:\n\n\nBuild the unit test into an executable\nRun the unit test, passing the main executable as an argument\n\n\nReturn exit code 0 if all of the above steps succeed, otherwise 0"
  },
  {
    "objectID": "guide/component/unit-testing.html#bonus-unit-testing-all-of-the-components",
    "href": "guide/component/unit-testing.html#bonus-unit-testing-all-of-the-components",
    "title": "Unit testing",
    "section": "Bonus: unit testing all of the components",
    "text": "Bonus: unit testing all of the components\nIf you have multiple Viash components located in a directory called src/, what happens when you run the following?\nviash ns test --parallel --src src/"
  },
  {
    "objectID": "guide/nextflow_vdsl3/discussion.html",
    "href": "guide/nextflow_vdsl3/discussion.html",
    "title": "Discussion",
    "section": "",
    "text": "Nextflow is a widely-used workflow manager in computational biology and other scientific domains that offers a range of key advantages, including exemplary portability, reproducibility, and scalability.\nPortability is one of the most significant advantages of Nextflow. Once a Nextflow workflow has been implemented, it is effortless to set up a new system to run that workflow. This system can be of one of many different platforms, including laptops, desktops, HPC clusters, and dynamic cloud infrastructure. Nextflow also supports various platforms or “executors,” which are managed in a unified way.\nScalability is another advantage of Nextflow. When running a workflow on a large dataset cohort, the computations can be scaled out to multiple compute nodes automatically, depending on the chosen executor. This allows reducing the execution time significantly, from one month of execution time on a single system to just 43 minutes on a compute cluster with 1000 nodes.\nReproducibility is essential in computational biology and scientific research, and Nextflow supports full reproducibility by integrating easily with containerisation technologies such as Docker, Podman, and Singularity. This ensures that the workflow can be run multiple times with the same inputs and obtain the same or similar results."
  },
  {
    "objectID": "guide/nextflow_vdsl3/discussion.html#drawbacks-of-nextflow",
    "href": "guide/nextflow_vdsl3/discussion.html#drawbacks-of-nextflow",
    "title": "Discussion",
    "section": "Drawbacks of Nextflow",
    "text": "Drawbacks of Nextflow\nWhile Nextflow has many advantages, there are some drawbacks that can make developing a pipeline using Nextflow more challenging than expected. These drawbacks include:\nEasy to Learn, Hard to Master: While Nextflow offers a high-level syntax for writing workflows that is easy to learn, developing a pipeline that is on par with the current state of the art actually requires a significant amount of domain knowledge. This can limit collaborations between developers with varying backgrounds and pipeline development skill levels.\nLabour Intensive: Developing a new Nextflow workflow can be quite labour-intensive, as the necessary code is very verbose and contains a lot of boilerplate code. While this can be an advantage in terms of fine-grained control over the workflow, it can also be a drawback in terms of development time and code maintainability.\nLearning Curve: Nextflow has a steep learning curve, especially for developers who are new to the system. The documentation is extensive, but there is a lot to learn, and it can take time to become proficient in using Nextflow to its full potential.\nDebugging: Debugging a Nextflow pipeline can be challenging, especially when an error occurs in a complex workflow. It can be difficult to determine the cause of the error, and troubleshooting can be time-consuming."
  },
  {
    "objectID": "guide/nextflow_vdsl3/discussion.html#advantages-of-vdsl3",
    "href": "guide/nextflow_vdsl3/discussion.html#advantages-of-vdsl3",
    "title": "Discussion",
    "section": "Advantages of VDSL3",
    "text": "Advantages of VDSL3\nVDSL3 provides a solution to some of the barriers to Nextflow pipeline development. Viash can help developers wrap their code into a state-of-the-art Nextflow script called a VDSL3 module, solving the some of the labor-intensive nature of developing a Nextflow pipeline. The following are some of the key advantages of VDSL3:\nLower Barrier to Entry: Viash’s user-friendly interface simplifies Nextflow pipeline development, enabling developers with varying backgrounds and skill levels to collaborate more efficiently. Viash provides a simple and intuitive command-line interface that makes it easy for developers to create workflows.\nReusability: Viash components can not only be used as a step in a Nextflow pipeline, but also as a standalone command-line utility. This reusability allows developers to make the most of the code they write, increasing the efficiency of the development process.\nTest-Driven Development: Viash encourages test-driven development where unit tests are written before new functionality is developed. This approach helps to catch errors early, increasing the quality and reliability of the code.\nSeparation of Concerns: Viash allows developers to separate their code from Nextflow, reducing the complexity of the pipeline development process. Developers do not need any knowledge of Nextflow to start creating Viash components. Someone else can then write a Nextflow workflow consisting of the VDSL3 modules generated from the Viash components.\nContinuous Testing: Viash offers helper scripts to automatically run component tests whenever commits are pushed by one of the developers. This allows catching bugs earlier, thereby preventing costly long-term bugs."
  },
  {
    "objectID": "guide/nextflow_vdsl3/create-a-module.html",
    "href": "guide/nextflow_vdsl3/create-a-module.html",
    "title": "Create a module",
    "section": "",
    "text": "Creating a VDSL3 module is as simple as adding { type: nextflow } to the platforms section in the Viash config. Luckily, our previous example already contained such an entry:"
  },
  {
    "objectID": "guide/nextflow_vdsl3/create-a-module.html#build-the-vdsl3-module",
    "href": "guide/nextflow_vdsl3/create-a-module.html#build-the-vdsl3-module",
    "title": "Create a module",
    "section": "Build the VDSL3 module",
    "text": "Build the VDSL3 module\nWe will now turn the Viash component into a VDSL3 module. By default, the viash build command will select the first platform in the list of platforms. To select the nextflow platform, use the --platform nextflow argument, or -p nextflow for short.\n\nBash\n\n\n\nviash build config.vsh.yaml -o target -p nextflow\n\nThis will generate a Nextflow module in the target/ directory:\n\ntree target\n\ntarget\n├── main.nf\n└── nextflow.config\n\n0 directories, 2 files\n\n\n\n\n\nThis main.nf file is both a standalone Nextflow pipeline and a module which can be used as part of another pipeline.\n\n\n\n\n\n\nTip\n\n\n\nYou can also use the viash ns build command to build all of the platforms in one go. Give it a try! More information in the following section."
  },
  {
    "objectID": "guide/nextflow_vdsl3/create-a-module.html#module-as-a-standalone-pipeline",
    "href": "guide/nextflow_vdsl3/create-a-module.html#module-as-a-standalone-pipeline",
    "title": "Create a module",
    "section": "Module as a standalone pipeline",
    "text": "Module as a standalone pipeline\nWhen VDSL3 modules are used as a standalone pipeline, you need to specify the input parameters and a --publish_dir parameter, as Nextflow will automatically choose the parameter names of the output files.\nYou can run the executable by providing a value for --input and --publish_dir:\n\nnextflow run target/main.nf --input config.vsh.yaml --publish_dir output/\n\nN E X T F L O W  ~  version 22.10.6\nLaunching `target/main.nf` [nostalgic_bernard] DSL2 - revision: 5eeed39ebf\n[-        ] process > example_bash:example_bash_p... -\ninput: [run, [id:run, input:/tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/config.vsh.yaml, output:$id.$key.output.txt]]\n\nexecutor >  local (1)\n[4f/74502a] process > example_bash:example_bash_p... [100%] 1 of 1 ✔\ninput: [run, [id:run, input:/tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/config.vsh.yaml, output:$id.$key.output.txt]]\noutput: [run, /tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/work/4f/74502ace7c310291eaf9a01f0ce4ad/run.example_bash.output.txt]\n\nexecutor >  local (1)\n[4f/74502a] process > example_bash:example_bash_p... [100%] 1 of 1 ✔\ninput: [run, [id:run, input:/tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/config.vsh.yaml, output:$id.$key.output.txt]]\noutput: [run, /tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/work/4f/74502ace7c310291eaf9a01f0ce4ad/run.example_bash.output.txt]\n\n\nThis results in the following output:\n\ntree output\n\noutput\n└── run.example_bash.output.txt\n\n0 directories, 1 file\n\n\nThe pipeline help can be shown by passing the --help parameter (Output not shown).\nnextflow run target/main.nf --help"
  },
  {
    "objectID": "guide/nextflow_vdsl3/create-a-module.html#passing-a-parameter-list",
    "href": "guide/nextflow_vdsl3/create-a-module.html#passing-a-parameter-list",
    "title": "Create a module",
    "section": "Passing a parameter list",
    "text": "Passing a parameter list\nEvery VDSL3 can accept a list of parameters to populate a Nextflow channel with.\nFor example, we create a set of input files which we want to process in parallel.\n\ntouch sample1.txt sample2.txt sample3.txt sample4.txt\n\n\n\n\nNext, we create a YAML file param_list.yaml containing an id and an input value for each parameter entry.\n\n- id: sample1\n  input: /tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/sample1.txt\n- id: sample2\n  input: /tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/sample2.txt\n- id: sample3\n  input: /tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/sample3.txt\n- id: sample4\n  input: /tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/sample4.txt\n\nYou can run the pipeline on the list of parameters using the --param_list parameter.\n\nnextflow run target/main.nf --param_list param_list.yaml --publish_dir output2\n\nN E X T F L O W  ~  version 22.10.6\nLaunching `target/main.nf` [adoring_gutenberg] DSL2 - revision: 5eeed39ebf\n[-        ] process > example_bash:example_bash_p... -\ninput: [sample1, [id:sample1, input:/tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/sample1.txt, output:$id.$key.output.txt]]\ninput: [sample2, [id:sample2, input:/tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/sample2.txt, output:$id.$key.output.txt]]\ninput: [sample3, [id:sample3, input:/tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/sample3.txt, output:$id.$key.output.txt]]\ninput: [sample4, [id:sample4, input:/tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/sample4.txt, output:$id.$key.output.txt]]\n\nexecutor >  local (3)\n[1f/89037e] process > example_bash:example_bash_p... [  0%] 0 of 4\ninput: [sample1, [id:sample1, input:/tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/sample1.txt, output:$id.$key.output.txt]]\ninput: [sample2, [id:sample2, input:/tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/sample2.txt, output:$id.$key.output.txt]]\ninput: [sample3, [id:sample3, input:/tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/sample3.txt, output:$id.$key.output.txt]]\ninput: [sample4, [id:sample4, input:/tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/sample4.txt, output:$id.$key.output.txt]]\n\nexecutor >  local (4)\n[1f/89037e] process > example_bash:example_bash_p... [ 75%] 3 of 4\ninput: [sample1, [id:sample1, input:/tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/sample1.txt, output:$id.$key.output.txt]]\ninput: [sample2, [id:sample2, input:/tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/sample2.txt, output:$id.$key.output.txt]]\ninput: [sample3, [id:sample3, input:/tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/sample3.txt, output:$id.$key.output.txt]]\ninput: [sample4, [id:sample4, input:/tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/sample4.txt, output:$id.$key.output.txt]]\noutput: [sample2, /tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/work/3b/4c1cbce52c95520ecc7c2dbf89a2cf/sample2.example_bash.output.txt]\noutput: [sample1, /tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/work/ae/fd02d75e9271c8e594c3480a94dab8/sample1.example_bash.output.txt]\noutput: [sample3, /tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/work/1f/89037e398e24d53d3ce3434471c1d0/sample3.example_bash.output.txt]\n\nexecutor >  local (4)\n[95/51d783] process > example_bash:example_bash_p... [100%] 4 of 4 ✔\ninput: [sample1, [id:sample1, input:/tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/sample1.txt, output:$id.$key.output.txt]]\ninput: [sample2, [id:sample2, input:/tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/sample2.txt, output:$id.$key.output.txt]]\ninput: [sample3, [id:sample3, input:/tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/sample3.txt, output:$id.$key.output.txt]]\ninput: [sample4, [id:sample4, input:/tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/sample4.txt, output:$id.$key.output.txt]]\noutput: [sample2, /tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/work/3b/4c1cbce52c95520ecc7c2dbf89a2cf/sample2.example_bash.output.txt]\noutput: [sample1, /tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/work/ae/fd02d75e9271c8e594c3480a94dab8/sample1.example_bash.output.txt]\noutput: [sample3, /tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/work/1f/89037e398e24d53d3ce3434471c1d0/sample3.example_bash.output.txt]\noutput: [sample4, /tmp/RtmphMLJbW/create-a-module87ac74209aff/bash/work/95/51d783f2acbb5978095b201aa6ea0f/sample4.example_bash.output.txt]\n\n\nThis results in the following outputs:\n\ntree output2\n\noutput2\n├── sample1.example_bash.output.txt\n├── sample2.example_bash.output.txt\n├── sample3.example_bash.output.txt\n└── sample4.example_bash.output.txt\n\n0 directories, 4 files\n\n\n\n\n\n\n\n\nTip\n\n\n\nInstead of a YAML, you can also pass a JSON or a CSV to the --param_list parameter."
  },
  {
    "objectID": "guide/nextflow_vdsl3/create-a-module.html#module-as-part-of-a-pipeline",
    "href": "guide/nextflow_vdsl3/create-a-module.html#module-as-part-of-a-pipeline",
    "title": "Create a module",
    "section": "Module as part of a pipeline",
    "text": "Module as part of a pipeline\nThis module can also be used as part of a Nextflow pipeline. Below is a short preview of what this looks like.\nimport { example_bash } from \"target/main.nf\"\n\nChannel.fromList([\n  [\"sample1\", file(\"sample1.txt\")],\n  [\"sample2\", file(\"sample2.txt\")],\n  [\"sample3\", file(\"sample3.txt\")]\n])\n  | view { it -> \"input: $it\" }\n  | example_bash\n  | view { it -> \"output: $it\" }\nWe will discuss building pipelines with VDSL3 modules in more detail in Create a pipeline."
  },
  {
    "objectID": "guide/nextflow_vdsl3/create-a-module.html#improvements-over-standard-nextflow-modules",
    "href": "guide/nextflow_vdsl3/create-a-module.html#improvements-over-standard-nextflow-modules",
    "title": "Create a module",
    "section": "Improvements over standard Nextflow modules",
    "text": "Improvements over standard Nextflow modules\n\nNo need to write any Nextflow Groovy code, just your script and the Viash config.\nVDSL3 module are also standalone pipelines.\nHelp documentation is automatically generated.\nStandardized interface for passing parameter lists.\nAutomatically uses the Docker platform’s container."
  },
  {
    "objectID": "guide/nextflow_vdsl3/create-a-pipeline.html",
    "href": "guide/nextflow_vdsl3/create-a-pipeline.html",
    "title": "Create a pipeline",
    "section": "",
    "text": "This guide explains how to create an example pipeline that’s closer to a typical use-case of a Nextflow bioinformatics pipeline."
  },
  {
    "objectID": "guide/nextflow_vdsl3/create-a-pipeline.html#get-the-template-project",
    "href": "guide/nextflow_vdsl3/create-a-pipeline.html#get-the-template-project",
    "title": "Create a pipeline",
    "section": "Get the template project",
    "text": "Get the template project\nTo get started with building a pipeline, we provide a template project which already contains a few components. First create a new repository by clicking the “Use this template” button in the viash_project_template repository or clicking the button below.\nUse project template\nThen clone the repository using the following command.\ngit clone https://github.com/youruser/my_first_pipeline.git\nThe pipeline already contains three components with which we will build the following pipeline:\n\n\n\n\ngraph LR\n   A(file?.tsv) --> B[/remove_comments/]\n   B --> C[/take_column/]\n   C --> D[/combine_columns/]\n   D --> E(output)\n\n\n\n\n\n\n\n\n\nremove_comments is a Bash script which removes all lines starting with a # from a file.\ntake_column is a Python script which extracts one of the columns in a TSV file.\ncombine_columns is an R script which combines multiple files into a TSV."
  },
  {
    "objectID": "guide/nextflow_vdsl3/create-a-pipeline.html#build-the-vdsl3-modules",
    "href": "guide/nextflow_vdsl3/create-a-pipeline.html#build-the-vdsl3-modules",
    "title": "Create a pipeline",
    "section": "Build the VDSL3 modules",
    "text": "Build the VDSL3 modules\nFirst, we need to build the components into VDSL3 modules.\n\nviash ns build --setup cachedbuild --parallel\n\nExporting combine_columns (demo) =docker=> /home/runner/work/website/website/guide/nextflow_vdsl3/_viash_project_template/target/docker/demo/combine_columns\nExporting take_column (demo) =nextflow=> /home/runner/work/website/website/guide/nextflow_vdsl3/_viash_project_template/target/nextflow/demo/take_column\n[notice] Building container 'ghcr.io/viash-io/viash_project_template/demo_combine_columns:dev' with Dockerfile\nExporting remove_comments (demo) =docker=> /home/runner/work/website/website/guide/nextflow_vdsl3/_viash_project_template/target/docker/demo/remove_comments\n[notice] Building container 'ghcr.io/viash-io/viash_project_template/demo_remove_comments:dev' with Dockerfile\nExporting remove_comments (demo) =nextflow=> /home/runner/work/website/website/guide/nextflow_vdsl3/_viash_project_template/target/nextflow/demo/remove_comments\nExporting combine_columns (demo) =nextflow=> /home/runner/work/website/website/guide/nextflow_vdsl3/_viash_project_template/target/nextflow/demo/combine_columns\nExporting take_column (demo) =docker=> /home/runner/work/website/website/guide/nextflow_vdsl3/_viash_project_template/target/docker/demo/take_column\n[notice] Building container 'ghcr.io/viash-io/viash_project_template/demo_take_column:dev' with Dockerfile\n\u001b[32mAll 6 configs built successfully\u001b[0m\n\n\nOnce everything is built, a new target directory has been created containing the executables and modules grouped per platform:\n\ntree target\n\ntarget\n├── docker\n│   └── demo\n│       ├── combine_columns\n│       │   └── combine_columns\n│       ├── remove_comments\n│       │   └── remove_comments\n│       └── take_column\n│           └── take_column\n└── nextflow\n    └── demo\n        ├── combine_columns\n        │   ├── main.nf\n        │   └── nextflow.config\n        ├── remove_comments\n        │   ├── main.nf\n        │   └── nextflow.config\n        └── take_column\n            ├── main.nf\n            └── nextflow.config\n\n10 directories, 9 files"
  },
  {
    "objectID": "guide/nextflow_vdsl3/create-a-pipeline.html#create-a-pipeline",
    "href": "guide/nextflow_vdsl3/create-a-pipeline.html#create-a-pipeline",
    "title": "Create a pipeline",
    "section": "Create a pipeline",
    "text": "Create a pipeline\nBelow is a first Nextflow pipeline which uses just one VDSL3 module and with hard-coded input parameters (file1 and file2).\n\nnextflow.enable.dsl=2\n\ninclude { remove_comments } from \"./target/nextflow/demo/remove_comments/main.nf\"\n\nworkflow {\n  // Create a channel with two events\n  // Each event contains a string (an identifier) and a file (input)\n  Channel.fromList([\n    [\"file1\", file(\"resources_test/file1.tsv\")],\n    [\"file2\", file(\"resources_test/file2.tsv\")]\n  ])\n\n    // View channel contents\n    | view { tup -> \"Input: $tup\" }\n    \n    // Process the input file using the 'remove_comments' module.\n    // This removes comment lines from the input TSV.\n    | remove_comments.run(\n      directives: [\n        publishDir: \"output/\"\n      ]\n    )\n\n    // View channel contents\n    | view { tup -> \"Output: $tup\" }\n}"
  },
  {
    "objectID": "guide/nextflow_vdsl3/create-a-pipeline.html#vdsl3-module-interface",
    "href": "guide/nextflow_vdsl3/create-a-pipeline.html#vdsl3-module-interface",
    "title": "Create a pipeline",
    "section": "VDSL3 module interface",
    "text": "VDSL3 module interface\nIt’s important to note what the interface of every VDSL3 module is. A VDSL3 module expects an input to be a tuple with the following elements:\n\nid (String): A unique identifier used for tracking data objects and for ensuring output filenames are unique.\ndata (Map[String, Any] or File): A named map (or dictionary) used to pass the module’s input arguments. If the module only has a single input file, the file itself can simply be passed.\n... (Any*): Any other elements in the tuple simply pass through the module without being altered in any way. For this reason, it is often referred to as the “passthrough” objects.\n\nIn turn, a VDSL3 module will return a tuple with the same interface, except that the input data object has been replaced with the output data:\n\nid (String): The identifier from the input tuple.\ndata (Map[String, Any] or File): A named map (or dictionary) containing the module’s output files. Important: If the module only has a single output file, the file itself will be returned.\n... (Any*): The passthrough objects from the input tuple (if any)."
  },
  {
    "objectID": "guide/nextflow_vdsl3/create-a-pipeline.html#what-is-.run",
    "href": "guide/nextflow_vdsl3/create-a-pipeline.html#what-is-.run",
    "title": "Create a pipeline",
    "section": "What is .run()?",
    "text": "What is .run()?\nUsually, Nextflow processes are quite static objects. For example, changing its directives can be quite tricky.\nThe run() function is a unique feature for every VDSL3 module which allows dynamically altering the behaviour of a module from within the pipeline. In this case, we use it to set the publishDir directive to \"output/\" so the output of that step in the pipeline will be stored as output."
  },
  {
    "objectID": "guide/nextflow_vdsl3/create-a-pipeline.html#run-the-pipeline",
    "href": "guide/nextflow_vdsl3/create-a-pipeline.html#run-the-pipeline",
    "title": "Create a pipeline",
    "section": "Run the pipeline",
    "text": "Run the pipeline\nNow run the pipeline with Nextflow:\n\nnextflow run . \\\n  -main-script main.nf\n\nN E X T F L O W  ~  version 22.10.6\nLaunching `main.nf` [cheeky_albattani] DSL2 - revision: 111508427e\n[-        ] process > remove_comments:remove_comm... -\nInput: [file1, /home/runner/work/website/website/guide/nextflow_vdsl3/_viash_project_template/resources_test/file1.tsv]\nInput: [file2, /home/runner/work/website/website/guide/nextflow_vdsl3/_viash_project_template/resources_test/file2.tsv]\n\nexecutor >  local (2)\n[c5/df74d4] process > remove_comments:remove_comm... [ 50%] 1 of 2\nInput: [file1, /home/runner/work/website/website/guide/nextflow_vdsl3/_viash_project_template/resources_test/file1.tsv]\nInput: [file2, /home/runner/work/website/website/guide/nextflow_vdsl3/_viash_project_template/resources_test/file2.tsv]\nOutput: [file1, /home/runner/work/website/website/guide/nextflow_vdsl3/_viash_project_template/work/c5/df74d478d676017c1204fff5b5dac2/file1.remove_comments.output.tsv]\n\nexecutor >  local (2)\n[b4/d1701d] process > remove_comments:remove_comm... [100%] 2 of 2 ✔\nInput: [file1, /home/runner/work/website/website/guide/nextflow_vdsl3/_viash_project_template/resources_test/file1.tsv]\nInput: [file2, /home/runner/work/website/website/guide/nextflow_vdsl3/_viash_project_template/resources_test/file2.tsv]\nOutput: [file1, /home/runner/work/website/website/guide/nextflow_vdsl3/_viash_project_template/work/c5/df74d478d676017c1204fff5b5dac2/file1.remove_comments.output.tsv]\nOutput: [file2, /home/runner/work/website/website/guide/nextflow_vdsl3/_viash_project_template/work/b4/d1701d8ebfd39dc0d38ba84d71ea10/file2.remove_comments.output.tsv]\n\n\n\ntree output\n\noutput\n├── file1.remove_comments.output.tsv -> /home/runner/work/website/website/guide/nextflow_vdsl3/_viash_project_template/work/c5/df74d478d676017c1204fff5b5dac2/file1.remove_comments.output.tsv\n└── file2.remove_comments.output.tsv -> /home/runner/work/website/website/guide/nextflow_vdsl3/_viash_project_template/work/b4/d1701d8ebfd39dc0d38ba84d71ea10/file2.remove_comments.output.tsv\n\n0 directories, 2 files\n\n\n\ncat output/*\n\none 0.11    123\ntwo 0.23    456\nthree   0.35    789\nfour    0.47    123\neins    0.111   234\nzwei    0.222   234\ndrei    0.333   123\nvier    0.444   123"
  },
  {
    "objectID": "guide/nextflow_vdsl3/create-a-pipeline.html#discussion",
    "href": "guide/nextflow_vdsl3/create-a-pipeline.html#discussion",
    "title": "Create a pipeline",
    "section": "Discussion",
    "text": "Discussion\nThe above example pipeline serves as the backbone for creating more advanced pipelines. However, for the sake of simplicity it contained several hardcoded elements:\n\nInput parameters\nOutput directory\nVDSL3 module directory"
  },
  {
    "objectID": "guide/nextflow_vdsl3/advanced-pipeline.html",
    "href": "guide/nextflow_vdsl3/advanced-pipeline.html",
    "title": "Advanced pipeline",
    "section": "",
    "text": "The sections below describe how to create the VDSL3 modules in preparation for creating the pipeline.\n\n\ncreate a new folder named advanced pipeline, add src folder with a nextflow_module folder inside. Now create three folders inside nextflow_module folder, one per component needed for the pipeline:\n\ncombine_columns\nremove_comments\ntake_columns\n\nThe folder structure should look like this now:\nadvanced_pipeline\n└── src\n    └── nextflow_modules\n        ├── combine_columns\n        ├── remove_comments\n        └── take_column\n\nTarget directory where the modules are located\nInclude the modules from the target directory\nCreate a channel based on the input parameter’s path\nAssign a unique ID to each event using map{}\nRun remove_comments to remove the comments from the TSV\nExtract a single column from TSV by running take_column\nCombine all events into a single List event using toList()\nAdd unique ID to the tuple\nConcatenate the TSVs into one by running the combine_columns module with auto publishing enabled using the auto directive\nView the channel contents bu printing it to the console using view()"
  },
  {
    "objectID": "guide/nextflow_vdsl3/advanced-pipeline.html#running-the-pipeline",
    "href": "guide/nextflow_vdsl3/advanced-pipeline.html#running-the-pipeline",
    "title": "Advanced pipeline",
    "section": "Running the pipeline",
    "text": "Running the pipeline\nBefore being able to run the pipeline, you’ll need some TSV files to work with. Download the files below and place them in a new directory named data in the root of advanced_pipeline.\nNow run the following command to run the pipeline using Nextflow:\nnextflow run main.nf --input \"data/file?.tsv\" --publishDir output\nYou should get an output similar to this:\nN E X T F L O W  ~  version 22.04.3\nLaunching `workflows/310-realistic_pipeline/main.nf` [stupefied_saha] DSL2 - revision: 6669aefc6c\n[93/232aba] Submitted process > remove_comments:remove_comments_process (2)\n[ef/a28e89] Submitted process > remove_comments:remove_comments_process (1)\n[63/279f98] Submitted process > take_column:take_column_process (1)\n[50/2a17ef] Submitted process > take_column:take_column_process (2)\n[8d/6eeff5] Submitted process > combine_columns:combine_columns_process\nOutput: [combined, /home/runner/work/viash_nxf_course/viash_nxf_course/work/8d/6eeff571e9ff2c5389851c6ab3001c/combined.combine_columns.output]\nYou can find the final TSV in the output directory:\n# this is a header      \n# this is also a header     \none     0.11    123\ntwo     0.23    456\nthree   0.35    789\nfour    0.47    123"
  },
  {
    "objectID": "guide/nextflow_vdsl3/advanced-pipeline.html#todo-add",
    "href": "guide/nextflow_vdsl3/advanced-pipeline.html#todo-add",
    "title": "Advanced pipeline",
    "section": "Todo: add",
    "text": "Todo: add\n\nCopy guide/data-workflow/nextflow-pipeline/pipeline-advanced.qmd\nUse template repository instead of download buttons\nNew content:\n\nHow to use a module in a pipeline.\nSpecify that we assume the user knows how to write a Nextflow pipeline\nDynamic behaviour (.run()): dynamic directives and auto helper.\nNextflow Viash config\nShowcase pre-existing pipeline, e.g. guide/data-workflow/nextflow-pipeline/pipeline-advanced.qmd\nTodo: update to latest VDSL3 practices. Let the targetDir use the rootDir. Use the newer WorkflowHelper helper functions."
  },
  {
    "objectID": "guide/nextflow_vdsl3/introduction.html",
    "href": "guide/nextflow_vdsl3/introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "Nextflow is a highly popular and widely-used workflow manager in computational biology, featuring outstanding portability, reproducibility and scalability. However, while Nextflow’s advantages are impressive, developing a Nextflow pipeline can be challenging, requiring significant domain knowledge and verbose code that is labour-intensive. Fortunately, Viash provides a solution to the barriers of Nextflow pipeline development.\nViash can help developers wrap their code into a state-of-the-art Nextflow script called a VDSL3 module. As we will demonstrate in the remainder of this guide, VDSL3 is effectively a separate DSL layer on top of Nextflow enabled by Viash, hence it is called Viash + Nextflow DSL 3, or VDSL3 for short. VDSL3’s benefits extend beyond Nextflow pipeline development, including reusability, test-driven development, separation of concerns, and continuous testing (See Discussion).\nIn the following sections, we’ll show how to use build Nextflow modules from Viash components and how to put them together in a pipeline."
  },
  {
    "objectID": "guide/project/batch-processing.html",
    "href": "guide/project/batch-processing.html",
    "title": "Batch processing *",
    "section": "",
    "text": "Building many components: Copy guide/component/namespaces.qmd section “Using the viash ns subcommands”\nTest many components\nListing components"
  },
  {
    "objectID": "guide/project/create-a-new-project.html",
    "href": "guide/project/create-a-new-project.html",
    "title": "Create a new project *",
    "section": "",
    "text": "Clone from the project template (copy from quickstart)\nProject structure - Copy guide/component/namespaces.qmd section “Adding components to a namespace”"
  },
  {
    "objectID": "help/terminology.html",
    "href": "help/terminology.html",
    "title": "Terminology",
    "section": "",
    "text": "The reference below serves as a reference for the terms used throughout the guides and other pages.\n\n\n\n\n\n\n\nTerm\nDescription\n\n\n\n\nViash\nA script code wrapper for building modular software components that serve as building blocks to develop (Nextflow) data pipelines.\n\n\nComponent\nAt minimum, the combination of a script and a config file. This can also include any needed resources and unit tests.\n\n\nViash config\nA YAML based file that holds all of the parameters needed to create a component.\n\n\nResources\nTools, helper scripts, templates and other files the component depends on to work.\n\n\nUnit test\nA small block of code to test a component.\n\n\nBuild target\nAn executable or a VDSL3 module that’s generated by Viash.\n\n\n(VDSL3) Module\nA Nextflow module generated by Viash.\n\n\n(Viash) Executable\nAn executable script generated for the Native or Docker platform.\n\n\n(Docker) Image\nA standard unit of software that packages up the OS, code and its dependencies so the application runs quickly and reliably from one computing environment to another.\n\n\n(Docker) Container\nAn instance of a Docker image.\n\n\nPlatform\nThe platform(s) targeted by a component. We currently support Native, Docker and Nextflow."
  }
]