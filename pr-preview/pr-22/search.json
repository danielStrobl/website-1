[
  {
    "objectID": "help/terminology.html",
    "href": "help/terminology.html",
    "title": "Terminology",
    "section": "",
    "text": "The reference below serves as a reference for the terms used throughout the guides and other pages.\n\n\n\n\n\n\n\nTerm\nDescription\n\n\n\n\nViash\nA script code wrapper for building modular software components that serve as building blocks to develop (Nextflow) data pipelines.\n\n\nComponent\nAt minimum, the combination of a script and a config file. This can also include any needed resources and unit tests.\n\n\nViash config\nA YAML based file that holds all of the parameters needed to create a component.\n\n\nResources\nTools, helper scripts, templates and other files the component depends on to work.\n\n\nUnit test\nA small block of code to test a component.\n\n\nBuild target\nAn executable or a VDSL3 module that’s generated by Viash.\n\n\n(VDSL3) Module\nA Nextflow module generated by Viash.\n\n\n(Viash) Executable\nAn executable script generated for the Native or Docker platform.\n\n\n(Docker) Image\nA standard unit of software that packages up the OS, code and its dependencies so the application runs quickly and reliably from one computing environment to another.\n\n\n(Docker) Container\nAn instance of a Docker image.\n\n\nPlatform\nThe platform(s) targeted by a component. We currently support Native, Docker and Nextflow."
  },
  {
    "objectID": "reference/config/index.html",
    "href": "reference/config/index.html",
    "title": "Overview",
    "section": "",
    "text": "A Viash configuration is a YAML file which contains metadata to describe the behaviour and build target(s) of a component.\nWe commonly name this file config.vsh.yaml in our examples, but you can name it however you choose.\nHere’s an example of a config file:\nEvery Viash config consists of two main sections: functionality and platforms."
  },
  {
    "objectID": "reference/config/index.html#functionality",
    "href": "reference/config/index.html#functionality",
    "title": "Overview",
    "section": "Functionality",
    "text": "Functionality\nThe functionality section describes the behaviour of the component. This includes a name, a description and the arguments and resources the component needs to function.\nCheck out our Arguments section on the left to find out more about the supported arguments. The External Resources guide contains information on how to add resources and use them."
  },
  {
    "objectID": "reference/config/index.html#platforms",
    "href": "reference/config/index.html#platforms",
    "title": "Overview",
    "section": "Platforms",
    "text": "Platforms\nThe platforms section specifies what platforms are supported as build targets for a component and their requirements. We support native, Docker and Nextflow. If no platforms are specified, the native platform is used by default."
  },
  {
    "objectID": "reference/config/arguments/boolean_true.html",
    "href": "reference/config/arguments/boolean_true.html",
    "title": "boolean_true",
    "section": "",
    "text": "An argument of the boolean_true type acts like a boolean flag with a default value of false. When called as an argument it sets the boolean to true.\nExample:"
  },
  {
    "objectID": "reference/config/arguments/boolean_true.html#alternatives",
    "href": "reference/config/arguments/boolean_true.html#alternatives",
    "title": "boolean_true",
    "section": "alternatives",
    "text": "alternatives\nType: String / List of String\nList of alternative format variations for this argument."
  },
  {
    "objectID": "reference/config/arguments/boolean_true.html#description",
    "href": "reference/config/arguments/boolean_true.html#description",
    "title": "boolean_true",
    "section": "description",
    "text": "description\nType: String\nA description of the argument. This will be displayed with --help."
  },
  {
    "objectID": "reference/config/arguments/boolean_true.html#info",
    "href": "reference/config/arguments/boolean_true.html#info",
    "title": "boolean_true",
    "section": "info",
    "text": "info\nType: Json\nStructured information. Can be any shape: a string, vector, map or even nested map.\nExample:\ninfo:\n  category: cat1\n  labels: [one, two, three]"
  },
  {
    "objectID": "reference/config/arguments/boolean_true.html#name",
    "href": "reference/config/arguments/boolean_true.html#name",
    "title": "boolean_true",
    "section": "name",
    "text": "name\nType: String\nThe name of the argument. Can be in the formats --silent, -s or silent. The number of dashes determines how values can be passed:\n\n--silent is a long option, which can be passed with executable_name --silent\n-s is a short option, which can be passed with executable_name -s\nsilent is an argument, which can be passed with executable_name silent"
  },
  {
    "objectID": "reference/config/arguments/boolean_true.html#type",
    "href": "reference/config/arguments/boolean_true.html#type",
    "title": "boolean_true",
    "section": "type",
    "text": "type\nType: String\nSpecifies the type of the argument."
  },
  {
    "objectID": "reference/config/arguments/string.html",
    "href": "reference/config/arguments/string.html",
    "title": "string",
    "section": "",
    "text": "A string type argument has a value made up of an ordered sequences of characters, like “Hello” or “I’m a string”.\nExample:"
  },
  {
    "objectID": "reference/config/arguments/string.html#alternatives",
    "href": "reference/config/arguments/string.html#alternatives",
    "title": "string",
    "section": "alternatives",
    "text": "alternatives\nType: String / List of String\nList of alternative format variations for this argument."
  },
  {
    "objectID": "reference/config/arguments/string.html#choices",
    "href": "reference/config/arguments/string.html#choices",
    "title": "string",
    "section": "choices",
    "text": "choices\nType: List of String\nLimit the amount of valid values for this argument to those set in this list. When set and a value not present in the list is provided, an error will be produced.\nExample:\n- name: --language\n  type: string\n  choices: [\"python\", \"r\", \"javascript\"]"
  },
  {
    "objectID": "reference/config/arguments/string.html#default",
    "href": "reference/config/arguments/string.html#default",
    "title": "string",
    "section": "default",
    "text": "default\nType: String / List of String\nThe default value when no argument value is provided. This will not work if the required property is enabled.\nExample:\n- name: --my_string\n  type: string\n  default: \"The answer is 42\""
  },
  {
    "objectID": "reference/config/arguments/string.html#description",
    "href": "reference/config/arguments/string.html#description",
    "title": "string",
    "section": "description",
    "text": "description\nType: String\nA description of the argument. This will be displayed with --help."
  },
  {
    "objectID": "reference/config/arguments/string.html#example",
    "href": "reference/config/arguments/string.html#example",
    "title": "string",
    "section": "example",
    "text": "example\nType: String / List of String\nAn example value for this argument. If no default property was specified, this will be used for that purpose.\nExample:\n- name: --my_string\n  type: string\n  example: \"Hello World\""
  },
  {
    "objectID": "reference/config/arguments/string.html#info",
    "href": "reference/config/arguments/string.html#info",
    "title": "string",
    "section": "info",
    "text": "info\nType: Json\nStructured information. Can be any shape: a string, vector, map or even nested map.\nExample:\ninfo:\n  category: cat1\n  labels: [one, two, three]"
  },
  {
    "objectID": "reference/config/arguments/string.html#multiple",
    "href": "reference/config/arguments/string.html#multiple",
    "title": "string",
    "section": "multiple",
    "text": "multiple\nType: Boolean\nTreat the argument value as an array. Arrays can be passed using the delimiter --foo=1:2:3 or by providing the same argument multiple times --foo 1 --foo 2. You can use a custom delimiter by using the multiple_sep property. false by default.\nExample:\n- name: --my_string\n  type: string\n  multiple: true\nHere’s an example of how to use this:\nmy_component --my_string=Marc:Susan:Paul"
  },
  {
    "objectID": "reference/config/arguments/string.html#multiple_sep",
    "href": "reference/config/arguments/string.html#multiple_sep",
    "title": "string",
    "section": "multiple_sep",
    "text": "multiple_sep\nType: String\nThe delimiter character for providing multiple values. : by default.\nExample:\n- name: --my_string\n  type: string\n  multiple: true\n  multiple_sep: \",\"\nHere’s an example of how to use this:\nmy_component --my_string=Marc,Susan,Paul"
  },
  {
    "objectID": "reference/config/arguments/string.html#name",
    "href": "reference/config/arguments/string.html#name",
    "title": "string",
    "section": "name",
    "text": "name\nType: String\nThe name of the argument. Can be in the formats --foo, -f or foo. The number of dashes determines how values can be passed:\n\n--foo is a long option, which can be passed with executable_name --foo=value or executable_name --foo value\n-f is a short option, which can be passed with executable_name -f value\nfoo is an argument, which can be passed with executable_name value"
  },
  {
    "objectID": "reference/config/arguments/string.html#required",
    "href": "reference/config/arguments/string.html#required",
    "title": "string",
    "section": "required",
    "text": "required\nType: Boolean\nMake the value for this argument required. If set to true, an error will be produced if no value was provided. false by default.\nExample:\n- name: --my_string\n  type: string\n  required: true"
  },
  {
    "objectID": "reference/config/arguments/string.html#type",
    "href": "reference/config/arguments/string.html#type",
    "title": "string",
    "section": "type",
    "text": "type\nType: String\nSpecifies the type of the argument."
  },
  {
    "objectID": "reference/config/arguments/integer.html",
    "href": "reference/config/arguments/integer.html",
    "title": "integer",
    "section": "",
    "text": "An integer type argument has a numeric value without decimal points.\nExample:"
  },
  {
    "objectID": "reference/config/arguments/integer.html#alternatives",
    "href": "reference/config/arguments/integer.html#alternatives",
    "title": "integer",
    "section": "alternatives",
    "text": "alternatives\nType: String / List of String\nList of alternative format variations for this argument."
  },
  {
    "objectID": "reference/config/arguments/integer.html#choices",
    "href": "reference/config/arguments/integer.html#choices",
    "title": "integer",
    "section": "choices",
    "text": "choices\nType: List of Int\nLimit the amount of valid values for this argument to those set in this list. When set and a value not present in the list is provided, an error will be produced.\nExample:\n- name: --values\n  type: integer\n  choices: [1024, 2048, 4096]"
  },
  {
    "objectID": "reference/config/arguments/integer.html#default",
    "href": "reference/config/arguments/integer.html#default",
    "title": "integer",
    "section": "default",
    "text": "default\nType: Int / List of Int\nThe default value when no argument value is provided. This will not work if the required property is enabled.\nExample:\n- name: --my_integer\n  type: integer\n  default: 100"
  },
  {
    "objectID": "reference/config/arguments/integer.html#description",
    "href": "reference/config/arguments/integer.html#description",
    "title": "integer",
    "section": "description",
    "text": "description\nType: String\nA description of the argument. This will be displayed with --help."
  },
  {
    "objectID": "reference/config/arguments/integer.html#example",
    "href": "reference/config/arguments/integer.html#example",
    "title": "integer",
    "section": "example",
    "text": "example\nType: Int / List of Int\nAn example value for this argument. If no default property was specified, this will be used for that purpose.\nExample:\n- name: --my_integer\n  type: integer\n  example: 100"
  },
  {
    "objectID": "reference/config/arguments/integer.html#info",
    "href": "reference/config/arguments/integer.html#info",
    "title": "integer",
    "section": "info",
    "text": "info\nType: Json\nStructured information. Can be any shape: a string, vector, map or even nested map.\nExample:\ninfo:\n  category: cat1\n  labels: [one, two, three]"
  },
  {
    "objectID": "reference/config/arguments/integer.html#max",
    "href": "reference/config/arguments/integer.html#max",
    "title": "integer",
    "section": "max",
    "text": "max\nType: Int\nMaximum allowed value for this argument. If set and the provided value is higher than the maximum, an error will be produced. Can be combined with min to clamp values.\nExample:\n- name: --my_integer\n  type: integer\n  max: 150"
  },
  {
    "objectID": "reference/config/arguments/integer.html#min",
    "href": "reference/config/arguments/integer.html#min",
    "title": "integer",
    "section": "min",
    "text": "min\nType: Int\nMinimum allowed value for this argument. If set and the provided value is lower than the minimum, an error will be produced. Can be combined with max to clamp values.\nExample:\n- name: --my_integer\n  type: integer\n  min: 50"
  },
  {
    "objectID": "reference/config/arguments/integer.html#multiple",
    "href": "reference/config/arguments/integer.html#multiple",
    "title": "integer",
    "section": "multiple",
    "text": "multiple\nType: Boolean\nTreat the argument value as an array. Arrays can be passed using the delimiter --foo=1:2:3 or by providing the same argument multiple times --foo 1 --foo 2. You can use a custom delimiter by using the multiple_sep property. false by default.\nExample:\n- name: --my_integer\n  type: integer\n  multiple: true\nHere’s an example of how to use this:\nmy_component --my_integer=10:80:152"
  },
  {
    "objectID": "reference/config/arguments/integer.html#multiple_sep",
    "href": "reference/config/arguments/integer.html#multiple_sep",
    "title": "integer",
    "section": "multiple_sep",
    "text": "multiple_sep\nType: String\nThe delimiter character for providing multiple values. : by default.\nExample:\n- name: --my_integer\n  type: integer\n  multiple: true\n  multiple_sep: \",\"\nHere’s an example of how to use this:\nmy_component --my_integer=10:80:152"
  },
  {
    "objectID": "reference/config/arguments/integer.html#name",
    "href": "reference/config/arguments/integer.html#name",
    "title": "integer",
    "section": "name",
    "text": "name\nType: String\nThe name of the argument. Can be in the formats --foo, -f or foo. The number of dashes determines how values can be passed:\n\n--foo is a long option, which can be passed with executable_name --foo=value or executable_name --foo value\n-f is a short option, which can be passed with executable_name -f value\nfoo is an argument, which can be passed with executable_name value"
  },
  {
    "objectID": "reference/config/arguments/integer.html#required",
    "href": "reference/config/arguments/integer.html#required",
    "title": "integer",
    "section": "required",
    "text": "required\nType: Boolean\nMake the value for this argument required. If set to true, an error will be produced if no value was provided. false by default.\nExample:\n- name: --my_integer\n  type: integer\n  required: true"
  },
  {
    "objectID": "reference/config/arguments/integer.html#type",
    "href": "reference/config/arguments/integer.html#type",
    "title": "integer",
    "section": "type",
    "text": "type\nType: String\nSpecifies the type of the argument."
  },
  {
    "objectID": "reference/config/arguments/double.html",
    "href": "reference/config/arguments/double.html",
    "title": "double",
    "section": "",
    "text": "A double type argument has a numeric value with decimal points\nExample:"
  },
  {
    "objectID": "reference/config/arguments/double.html#alternatives",
    "href": "reference/config/arguments/double.html#alternatives",
    "title": "double",
    "section": "alternatives",
    "text": "alternatives\nType: String / List of String\nList of alternative format variations for this argument."
  },
  {
    "objectID": "reference/config/arguments/double.html#default",
    "href": "reference/config/arguments/double.html#default",
    "title": "double",
    "section": "default",
    "text": "default\nType: Double / List of Double\nThe default value when no argument value is provided. This will not work if the required property is enabled.\nExample:\n- name: --my_double\n  type: double\n  default: 5.8"
  },
  {
    "objectID": "reference/config/arguments/double.html#description",
    "href": "reference/config/arguments/double.html#description",
    "title": "double",
    "section": "description",
    "text": "description\nType: String\nA description of the argument. This will be displayed with --help."
  },
  {
    "objectID": "reference/config/arguments/double.html#example",
    "href": "reference/config/arguments/double.html#example",
    "title": "double",
    "section": "example",
    "text": "example\nType: Double / List of Double\nAn example value for this argument. If no default property was specified, this will be used for that purpose.\nExample:\n- name: --my_double\n  type: double\n  example: 5.8"
  },
  {
    "objectID": "reference/config/arguments/double.html#info",
    "href": "reference/config/arguments/double.html#info",
    "title": "double",
    "section": "info",
    "text": "info\nType: Json\nStructured information. Can be any shape: a string, vector, map or even nested map.\nExample:\ninfo:\n  category: cat1\n  labels: [one, two, three]"
  },
  {
    "objectID": "reference/config/arguments/double.html#max",
    "href": "reference/config/arguments/double.html#max",
    "title": "double",
    "section": "max",
    "text": "max\nType: Double\nMaximum allowed value for this argument. If set and the provided value is higher than the maximum, an error will be produced. Can be combined with min to clamp values.\nExample:\n- name: --my_double\n  type: double\n  max: 80.4"
  },
  {
    "objectID": "reference/config/arguments/double.html#min",
    "href": "reference/config/arguments/double.html#min",
    "title": "double",
    "section": "min",
    "text": "min\nType: Double\nMinimum allowed value for this argument. If set and the provided value is lower than the minimum, an error will be produced. Can be combined with max to clamp values.\nExample:\n- name: --my_double\n  type: double\n  min: 25.5"
  },
  {
    "objectID": "reference/config/arguments/double.html#multiple",
    "href": "reference/config/arguments/double.html#multiple",
    "title": "double",
    "section": "multiple",
    "text": "multiple\nType: Boolean\nTreat the argument value as an array. Arrays can be passed using the delimiter --foo=1:2:3 or by providing the same argument multiple times --foo 1 --foo 2. You can use a custom delimiter by using the multiple_sep property. false by default.\nExample:\n- name: --my_double\n  type: double\n  multiple: true\nHere’s an example of how to use this:\nmy_component --my_double=5.8:22.6:200.4"
  },
  {
    "objectID": "reference/config/arguments/double.html#multiple_sep",
    "href": "reference/config/arguments/double.html#multiple_sep",
    "title": "double",
    "section": "multiple_sep",
    "text": "multiple_sep\nType: String\nThe delimiter character for providing multiple values. : by default.\nExample:\n- name: --my_double\n  type: double\n  multiple: true\n  multiple_sep: \",\"\nHere’s an example of how to use this:\nmy_component --my_double=5.8,22.6,200.4"
  },
  {
    "objectID": "reference/config/arguments/double.html#name",
    "href": "reference/config/arguments/double.html#name",
    "title": "double",
    "section": "name",
    "text": "name\nType: String\nThe name of the argument. Can be in the formats --foo, -f or foo. The number of dashes determines how values can be passed:\n\n--foo is a long option, which can be passed with executable_name --foo=value or executable_name --foo value\n-f is a short option, which can be passed with executable_name -f value\nfoo is an argument, which can be passed with executable_name value"
  },
  {
    "objectID": "reference/config/arguments/double.html#required",
    "href": "reference/config/arguments/double.html#required",
    "title": "double",
    "section": "required",
    "text": "required\nType: Boolean\nMake the value for this argument required. If set to true, an error will be produced if no value was provided. false by default.\nExample:\n- name: --my_double\n  type: double\n  required: true"
  },
  {
    "objectID": "reference/config/arguments/double.html#type",
    "href": "reference/config/arguments/double.html#type",
    "title": "double",
    "section": "type",
    "text": "type\nType: String\nSpecifies the type of the argument."
  },
  {
    "objectID": "reference/config/arguments/boolean.html",
    "href": "reference/config/arguments/boolean.html",
    "title": "boolean",
    "section": "",
    "text": "A boolean type argument has two possible values: true or false.\nExample:"
  },
  {
    "objectID": "reference/config/arguments/boolean.html#alternatives",
    "href": "reference/config/arguments/boolean.html#alternatives",
    "title": "boolean",
    "section": "alternatives",
    "text": "alternatives\nType: String / List of String\nList of alternative format variations for this argument."
  },
  {
    "objectID": "reference/config/arguments/boolean.html#default",
    "href": "reference/config/arguments/boolean.html#default",
    "title": "boolean",
    "section": "default",
    "text": "default\nType: Boolean / List of Boolean\nThe default value when no argument value is provided. This will not work if the required property is enabled.\nExample:\n- name: --my_boolean\n  type: boolean\n  default: true"
  },
  {
    "objectID": "reference/config/arguments/boolean.html#description",
    "href": "reference/config/arguments/boolean.html#description",
    "title": "boolean",
    "section": "description",
    "text": "description\nType: String\nA description of the argument. This will be displayed with --help."
  },
  {
    "objectID": "reference/config/arguments/boolean.html#example",
    "href": "reference/config/arguments/boolean.html#example",
    "title": "boolean",
    "section": "example",
    "text": "example\nType: Boolean / List of Boolean\nAn example value for this argument. If no default property was specified, this will be used for that purpose.\nExample:\n- name: --my_boolean\n  type: boolean\n  example: true"
  },
  {
    "objectID": "reference/config/arguments/boolean.html#info",
    "href": "reference/config/arguments/boolean.html#info",
    "title": "boolean",
    "section": "info",
    "text": "info\nType: Json\nStructured information. Can be any shape: a string, vector, map or even nested map.\nExample:\ninfo:\n  category: cat1\n  labels: [one, two, three]"
  },
  {
    "objectID": "reference/config/arguments/boolean.html#multiple",
    "href": "reference/config/arguments/boolean.html#multiple",
    "title": "boolean",
    "section": "multiple",
    "text": "multiple\nType: Boolean\nTreat the argument value as an array. Arrays can be passed using the delimiter --foo=1:2:3 or by providing the same argument multiple times --foo 1 --foo 2. You can use a custom delimiter by using the multiple_sep property. false by default.\nExample:\n- name: --my_boolean\n  type: boolean\n  multiple: true\nHere’s an example of how to use this:\nmy_component --my_boolean=true:true:false"
  },
  {
    "objectID": "reference/config/arguments/boolean.html#multiple_sep",
    "href": "reference/config/arguments/boolean.html#multiple_sep",
    "title": "boolean",
    "section": "multiple_sep",
    "text": "multiple_sep\nType: String\nThe delimiter character for providing multiple values. : by default.\nExample:\n- name: --my_boolean\n  type: boolean\n  multiple: true\n  multiple_sep: \",\"\nHere’s an example of how to use this:\nmy_component --my_boolean=true,true,false"
  },
  {
    "objectID": "reference/config/arguments/boolean.html#name",
    "href": "reference/config/arguments/boolean.html#name",
    "title": "boolean",
    "section": "name",
    "text": "name\nType: String\nThe name of the argument. Can be in the formats --trim, -t or trim. The number of dashes determines how values can be passed:\n\n--trim is a long option, which can be passed with executable_name --trim\n-t is a short option, which can be passed with executable_name -t\ntrim is an argument, which can be passed with executable_name trim"
  },
  {
    "objectID": "reference/config/arguments/boolean.html#required",
    "href": "reference/config/arguments/boolean.html#required",
    "title": "boolean",
    "section": "required",
    "text": "required\nType: Boolean\nMake the value for this argument required. If set to true, an error will be produced if no value was provided. false by default.\nExample:\n- name: --my_boolean\n  type: boolean\n  required: true"
  },
  {
    "objectID": "reference/config/arguments/boolean.html#type",
    "href": "reference/config/arguments/boolean.html#type",
    "title": "boolean",
    "section": "type",
    "text": "type\nType: String\nSpecifies the type of the argument."
  },
  {
    "objectID": "reference/config/arguments/long.html",
    "href": "reference/config/arguments/long.html",
    "title": "long",
    "section": "",
    "text": "An long type argument has a numeric value without decimal points.\nExample:"
  },
  {
    "objectID": "reference/config/arguments/long.html#alternatives",
    "href": "reference/config/arguments/long.html#alternatives",
    "title": "long",
    "section": "alternatives",
    "text": "alternatives\nType: String / List of String\nList of alternative format variations for this argument."
  },
  {
    "objectID": "reference/config/arguments/long.html#choices",
    "href": "reference/config/arguments/long.html#choices",
    "title": "long",
    "section": "choices",
    "text": "choices\nType: List of Long\nLimit the amount of valid values for this argument to those set in this list. When set and a value not present in the list is provided, an error will be produced.\nExample:\n- name: --values\n  type: long\n  choices: [1024, 2048, 4096]"
  },
  {
    "objectID": "reference/config/arguments/long.html#default",
    "href": "reference/config/arguments/long.html#default",
    "title": "long",
    "section": "default",
    "text": "default\nType: Long / List of Long\nThe default value when no argument value is provided. This will not work if the required property is enabled.\nExample:\n- name: --my_long\n  type: long\n  default: 100"
  },
  {
    "objectID": "reference/config/arguments/long.html#description",
    "href": "reference/config/arguments/long.html#description",
    "title": "long",
    "section": "description",
    "text": "description\nType: String\nA description of the argument. This will be displayed with --help."
  },
  {
    "objectID": "reference/config/arguments/long.html#example",
    "href": "reference/config/arguments/long.html#example",
    "title": "long",
    "section": "example",
    "text": "example\nType: Long / List of Long\nAn example value for this argument. If no default property was specified, this will be used for that purpose.\nExample:\n- name: --my_long\n  type: long\n  example: 100"
  },
  {
    "objectID": "reference/config/arguments/long.html#info",
    "href": "reference/config/arguments/long.html#info",
    "title": "long",
    "section": "info",
    "text": "info\nType: Json\nStructured information. Can be any shape: a string, vector, map or even nested map.\nExample:\ninfo:\n  category: cat1\n  labels: [one, two, three]"
  },
  {
    "objectID": "reference/config/arguments/long.html#max",
    "href": "reference/config/arguments/long.html#max",
    "title": "long",
    "section": "max",
    "text": "max\nType: Long\nMaximum allowed value for this argument. If set and the provided value is higher than the maximum, an error will be produced. Can be combined with min to clamp values.\nExample:\n- name: --my_long\n  type: long\n  max: 150"
  },
  {
    "objectID": "reference/config/arguments/long.html#min",
    "href": "reference/config/arguments/long.html#min",
    "title": "long",
    "section": "min",
    "text": "min\nType: Long\nMinimum allowed value for this argument. If set and the provided value is lower than the minimum, an error will be produced. Can be combined with max to clamp values.\nExample:\n- name: --my_long\n  type: long\n  min: 50"
  },
  {
    "objectID": "reference/config/arguments/long.html#multiple",
    "href": "reference/config/arguments/long.html#multiple",
    "title": "long",
    "section": "multiple",
    "text": "multiple\nType: Boolean\nTreat the argument value as an array. Arrays can be passed using the delimiter --foo=1:2:3 or by providing the same argument multiple times --foo 1 --foo 2. You can use a custom delimiter by using the multiple_sep property. false by default.\nExample:\n- name: --my_long\n  type: long\n  multiple: true\nHere’s an example of how to use this:\nmy_component --my_long=10:80:152"
  },
  {
    "objectID": "reference/config/arguments/long.html#multiple_sep",
    "href": "reference/config/arguments/long.html#multiple_sep",
    "title": "long",
    "section": "multiple_sep",
    "text": "multiple_sep\nType: String\nThe delimiter character for providing multiple values. : by default.\nExample:\n- name: --my_long\n  type: long\n  multiple: true\n  multiple_sep: \",\"\nHere’s an example of how to use this:\nmy_component --my_long=10:80:152"
  },
  {
    "objectID": "reference/config/arguments/long.html#name",
    "href": "reference/config/arguments/long.html#name",
    "title": "long",
    "section": "name",
    "text": "name\nType: String\nThe name of the argument. Can be in the formats --foo, -f or foo. The number of dashes determines how values can be passed:\n\n--foo is a long option, which can be passed with executable_name --foo=value or executable_name --foo value\n-f is a short option, which can be passed with executable_name -f value\nfoo is an argument, which can be passed with executable_name value"
  },
  {
    "objectID": "reference/config/arguments/long.html#required",
    "href": "reference/config/arguments/long.html#required",
    "title": "long",
    "section": "required",
    "text": "required\nType: Boolean\nMake the value for this argument required. If set to true, an error will be produced if no value was provided. false by default.\nExample:\n- name: --my_long\n  type: long\n  required: true"
  },
  {
    "objectID": "reference/config/arguments/long.html#type",
    "href": "reference/config/arguments/long.html#type",
    "title": "long",
    "section": "type",
    "text": "type\nType: String\nSpecifies the type of the argument."
  },
  {
    "objectID": "reference/config/arguments/boolean_false.html",
    "href": "reference/config/arguments/boolean_false.html",
    "title": "boolean_false",
    "section": "",
    "text": "An argument of the boolean_false type acts like an inverted boolean flag with a default value of true. When called as an argument it sets the boolean to false.\nExample:"
  },
  {
    "objectID": "reference/config/arguments/boolean_false.html#alternatives",
    "href": "reference/config/arguments/boolean_false.html#alternatives",
    "title": "boolean_false",
    "section": "alternatives",
    "text": "alternatives\nType: String / List of String\nList of alternative format variations for this argument."
  },
  {
    "objectID": "reference/config/arguments/boolean_false.html#description",
    "href": "reference/config/arguments/boolean_false.html#description",
    "title": "boolean_false",
    "section": "description",
    "text": "description\nType: String\nA description of the argument. This will be displayed with --help."
  },
  {
    "objectID": "reference/config/arguments/boolean_false.html#info",
    "href": "reference/config/arguments/boolean_false.html#info",
    "title": "boolean_false",
    "section": "info",
    "text": "info\nType: Json\nStructured information. Can be any shape: a string, vector, map or even nested map.\nExample:\ninfo:\n  category: cat1\n  labels: [one, two, three]"
  },
  {
    "objectID": "reference/config/arguments/boolean_false.html#name",
    "href": "reference/config/arguments/boolean_false.html#name",
    "title": "boolean_false",
    "section": "name",
    "text": "name\nType: String\nThe name of the argument. Can be in the formats --no-log, -n or no-log. The number of dashes determines how values can be passed:\n\n--no-log is a long option, which can be passed with executable_name --no-log\n-n is a short option, which can be passed with executable_name -n\nno-log is an argument, which can be passed with executable_name no-log"
  },
  {
    "objectID": "reference/config/arguments/boolean_false.html#type",
    "href": "reference/config/arguments/boolean_false.html#type",
    "title": "boolean_false",
    "section": "type",
    "text": "type\nType: String\nSpecifies the type of the argument."
  },
  {
    "objectID": "reference/config/arguments/file.html",
    "href": "reference/config/arguments/file.html",
    "title": "file",
    "section": "",
    "text": "A file type argument has a string value that points to a file or folder path.\nExample:"
  },
  {
    "objectID": "reference/config/arguments/file.html#alternatives",
    "href": "reference/config/arguments/file.html#alternatives",
    "title": "file",
    "section": "alternatives",
    "text": "alternatives\nType: String / List of String\nList of alternative format variations for this argument."
  },
  {
    "objectID": "reference/config/arguments/file.html#default",
    "href": "reference/config/arguments/file.html#default",
    "title": "file",
    "section": "default",
    "text": "default\nType: Path / List of Path\nThe default value when no argument value is provided. This will not work if the required property is enabled.\nExample:\n- name: --my_file\n  type: file\n  default: data.csv"
  },
  {
    "objectID": "reference/config/arguments/file.html#description",
    "href": "reference/config/arguments/file.html#description",
    "title": "file",
    "section": "description",
    "text": "description\nType: String\nA description of the argument. This will be displayed with --help."
  },
  {
    "objectID": "reference/config/arguments/file.html#direction",
    "href": "reference/config/arguments/file.html#direction",
    "title": "file",
    "section": "direction",
    "text": "direction\nType: Direction\nMakes this argument an input or an output, as in does the file/folder needs to be read or written. input by default.\nExample:\n- name: --my_output_file\n  type: file\n  direction: output"
  },
  {
    "objectID": "reference/config/arguments/file.html#example",
    "href": "reference/config/arguments/file.html#example",
    "title": "file",
    "section": "example",
    "text": "example\nType: Path / List of Path\nAn example value for this argument. If no default property was specified, this will be used for that purpose.\nExample:\n- name: --my_file\n  type: file\n  example: data.csv"
  },
  {
    "objectID": "reference/config/arguments/file.html#info",
    "href": "reference/config/arguments/file.html#info",
    "title": "file",
    "section": "info",
    "text": "info\nType: Json\nStructured information. Can be any shape: a string, vector, map or even nested map.\nExample:\ninfo:\n  category: cat1\n  labels: [one, two, three]"
  },
  {
    "objectID": "reference/config/arguments/file.html#multiple",
    "href": "reference/config/arguments/file.html#multiple",
    "title": "file",
    "section": "multiple",
    "text": "multiple\nType: Boolean\nTreat the argument value as an array. Arrays can be passed using the delimiter --foo=1:2:3 or by providing the same argument multiple times --foo 1 --foo 2. You can use a custom delimiter by using the multiple_sep property. false by default.\nExample:\n- name: --my_files\n  type: file\n  multiple: true\nHere’s an example of how to use this:\nmy_component --my_files=firstFile.csv:anotherFile.csv:yetAnother.csv"
  },
  {
    "objectID": "reference/config/arguments/file.html#multiple_sep",
    "href": "reference/config/arguments/file.html#multiple_sep",
    "title": "file",
    "section": "multiple_sep",
    "text": "multiple_sep\nType: String\nThe delimiter character for providing multiple values. : by default.\nExample:\n- name: --my_files\n  type: file\n  multiple: true\n  multiple_sep: \",\"\nHere’s an example of how to use this:\nmy_component --my_files=firstFile.csv,anotherFile.csv,yetAnother.csv"
  },
  {
    "objectID": "reference/config/arguments/file.html#must_exist",
    "href": "reference/config/arguments/file.html#must_exist",
    "title": "file",
    "section": "must_exist",
    "text": "must_exist\nType: Boolean\nThe file or folder should exist before the start of execution. If set to true, an error will be produced if the file or folder wasn’t found.\nExample:\n- name: --my_file\n  type: file\n  must_exist: true"
  },
  {
    "objectID": "reference/config/arguments/file.html#name",
    "href": "reference/config/arguments/file.html#name",
    "title": "file",
    "section": "name",
    "text": "name\nType: String\nThe name of the argument. Can be in the formats --foo, -f or foo. The number of dashes determines how values can be passed:\n\n--foo is a long option, which can be passed with executable_name --foo=value or executable_name --foo value\n-f is a short option, which can be passed with executable_name -f value\nfoo is an argument, which can be passed with executable_name value"
  },
  {
    "objectID": "reference/config/arguments/file.html#required",
    "href": "reference/config/arguments/file.html#required",
    "title": "file",
    "section": "required",
    "text": "required\nType: Boolean\nMake the value for this argument required. If set to true, an error will be produced if no value was provided. false by default.\nExample:\n- name: --my_file\n  type: file\n  required: true"
  },
  {
    "objectID": "reference/config/arguments/file.html#type",
    "href": "reference/config/arguments/file.html#type",
    "title": "file",
    "section": "type",
    "text": "type\nType: String\nSpecifies the type of the argument."
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html",
    "title": "Nextflow Legacy Platform",
    "section": "",
    "text": "Run a Viash component as a Nextflow module."
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#executor",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#executor",
    "title": "Nextflow Legacy Platform",
    "section": "executor",
    "text": "executor\nType: String\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.6.3. Undocumented & stale value"
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#id",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#id",
    "title": "Nextflow Legacy Platform",
    "section": "id",
    "text": "id\nType: String\nEvery platform can be given a specific id that can later be referred to explicitly when running or building the Viash component."
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#image",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#image",
    "title": "Nextflow Legacy Platform",
    "section": "image",
    "text": "image\nType: String\nIf no image attributes are configured, Viash will use the auto-generated image name from the Docker platform:\n[<namespace>/]<name>:<version>\nIt’s possible to specify the container image explicitly with which to run the module in different ways:\nimage: dataintuitive/viash:0.4.0\nExactly the same can be obtained with\nimage: dataintuitive/viash\nregistry: index.docker.io/v1/\ntag: 0.4.0\nSpecifying the attribute(s) like this will use the container dataintuitive/viash:0.4.0 from Docker hub (registry).\nIf no tag is specified Viash will use functionality.version as the tag.\nIf no registry is specified, Viash (and NextFlow) will assume the image is available locally or on Docker Hub. In other words, the registry: ... attribute above is superfluous. No other registry is checked automatically due to a limitation from Docker itself."
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#label",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#label",
    "title": "Nextflow Legacy Platform",
    "section": "label",
    "text": "label\nType: String\nWhen running the module in a cluster context and depending on the cluster type, NextFlow allows for attaching labels to the process that can later be used as selectors for associating resources to this process.\nIn order to attach one label to a process/component, one can use the label: ... attribute, multiple labels can be added using labels: [ ..., ... ] and the two can even be mixed.\nIn the main nextflow.config, one can now use this label:\nprocess { … withLabel: bigmem { maxForks = 5 … } }\nExample:\nlabel: highmem labels: [ highmem, highcpu ]"
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#labels",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#labels",
    "title": "Nextflow Legacy Platform",
    "section": "labels",
    "text": "labels\nType: String / List of String\nWhen running the module in a cluster context and depending on the cluster type, NextFlow allows for attaching labels to the process that can later be used as selectors for associating resources to this process.\nIn order to attach one label to a process/component, one can use the label: ... attribute, multiple labels can be added using labels: [ ..., ... ] and the two can even be mixed.\nIn the main nextflow.config, one can now use this label:\nprocess { … withLabel: bigmem { maxForks = 5 … } }\nExample:\nlabel: highmem labels: [ highmem, highcpu ]"
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#namespace_separator",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#namespace_separator",
    "title": "Nextflow Legacy Platform",
    "section": "namespace_separator",
    "text": "namespace_separator\nType: String\nThe default namespace separator is “_“.\nExample:\nnamespace_separator: \"+\""
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#organization",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#organization",
    "title": "Nextflow Legacy Platform",
    "section": "organization",
    "text": "organization\nType: String\nName of a container’s organization.\nExample:\norganization: viash-io"
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#path",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#path",
    "title": "Nextflow Legacy Platform",
    "section": "path",
    "text": "path\nType: String\nWhen publish: true, this attribute defines where the output is written relative to the params.publishDir setting. For example, path: processed in combination with --output s3://some_bucket/ will store the output of this component under\ns3://some_bucket/processed/\nThis attribute gives control over the directory structure of the output. For example:\npath: raw_data\nOr even:\npath: raw_data/bcl\nPlease note that per_id and path can be combined."
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#per_id",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#per_id",
    "title": "Nextflow Legacy Platform",
    "section": "per_id",
    "text": "per_id\nType: Boolean\nBy default, a subdirectory is created corresponding to the unique ID that is passed in the triplet. Let us illustrate this with an example. The following code snippet uses the value of --input as an input of a workflow. The input can include a wildcard so that multiple samples can run in parallel. We use the parent directory name (.getParent().baseName) as an identifier for the sample. We pass this as the first entry of the triplet:\nChannel.fromPath(params.input) \\\n    | map{ it -> [ it.getParent().baseName , it ] } \\\n    | map{ it -> [ it[0] , it[1], params ] }\n    | ...\nSay the resulting sample names are SAMPLE1 and SAMPLE2. The next step in the pipeline will be published (at least by default) under:\n<publishDir>/SAMPLE1/\n<publishDir>/SAMPLE2/\nThese per-ID subdirectories can be avoided by setting:\nper_id: false"
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#publish",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#publish",
    "title": "Nextflow Legacy Platform",
    "section": "publish",
    "text": "publish\nType: Boolean\nNextFlow uses the autogenerated work dirs to manage process IO under the hood. In order effectively output something one can publish the results a module or step in the pipeline. In order to do this, add publish: true to the config:\n\npublish is optional\nDefault value is false\n\nThis attribute simply defines if output of a component should be published yes or no. The output location has to be provided at pipeline launch by means of the option --publishDir ... or as params.publishDir in nextflow.config:\nparams.publishDir = \"...\""
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#registry",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#registry",
    "title": "Nextflow Legacy Platform",
    "section": "registry",
    "text": "registry\nType: String\nThe URL to the a custom Docker registry.\nExample:\nregistry: https://my-docker-registry.org"
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#separate_multiple_outputs",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#separate_multiple_outputs",
    "title": "Nextflow Legacy Platform",
    "section": "separate_multiple_outputs",
    "text": "separate_multiple_outputs\nType: Boolean\nSeparates the outputs generated by a Nextflow component with multiple outputs as separate events on the channel. Default value: true.\nExample:\nseparate_multiple_outputs: false"
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#stageinmode",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#stageinmode",
    "title": "Nextflow Legacy Platform",
    "section": "stageInMode",
    "text": "stageInMode\nType: String\nBy default NextFlow will create a symbolic link to the inputs for a process/module and run the tool at hand using those symbolic links. Some applications do not cope well with this strategy, in that case the files should effectively be copied rather than linked to. This can be achieved by using stageInMode: copy. This attribute is optional, the default is symlink.\nExample:\nstageInMode: copy"
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#tag",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#tag",
    "title": "Nextflow Legacy Platform",
    "section": "tag",
    "text": "tag\nType: String\nSpecify a Docker image based on its tag.\nExample:\ntag: 4.0"
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#type",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#type",
    "title": "Nextflow Legacy Platform",
    "section": "type",
    "text": "type\nType: String\nSpecifies the type of the platform."
  },
  {
    "objectID": "reference/config/platforms/NextflowLegacyPlatform.html#version",
    "href": "reference/config/platforms/NextflowLegacyPlatform.html#version",
    "title": "Nextflow Legacy Platform",
    "section": "version",
    "text": "version\nType: String\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.4.0. nextflow platform: attribute ‘version’ is deprecated and should be left empty."
  },
  {
    "objectID": "reference/config/platforms/NextflowVdsl3Platform.html",
    "href": "reference/config/platforms/NextflowVdsl3Platform.html",
    "title": "Nextflow Vdsl3 Platform",
    "section": "",
    "text": "Next-gen platform for generating NextFlow VDSL3 modules."
  },
  {
    "objectID": "reference/config/platforms/NextflowVdsl3Platform.html#auto",
    "href": "reference/config/platforms/NextflowVdsl3Platform.html#auto",
    "title": "Nextflow Vdsl3 Platform",
    "section": "auto",
    "text": "auto\nType: NextflowAuto\nAutomated processing flags which can be toggled on or off:\n\n\n\n\n\n\n\n\nFlag\nDescription\nDefault\n\n\n\n\nsimplifyInput\nIf true, an input tuple only containing only a single File (e.g. [\"foo\", file(\"in.h5ad\")]) is automatically transformed to a map (i.e. [\"foo\", [ input: file(\"in.h5ad\") ] ]).\ntrue\n\n\nsimplifyOutput\nIf true, an output tuple containing a map with a File (e.g. [\"foo\", [ output: file(\"out.h5ad\") ] ]) is automatically transformed to a map (i.e. [\"foo\", file(\"out.h5ad\")]).\ntrue\n\n\ntranscript\nIf true, the module’s transcripts from work/ are automatically published to params.transcriptDir. If not defined, params.publishDir + \"/_transcripts\" will be used. Will throw an error if neither are defined.\nfalse\n\n\npublish\nIf true, the module’s outputs are automatically published to params.publishDir. Will throw an error if params.publishDir is not defined.\nfalse\n\n\n\nExample:\nauto:\n    publish: true"
  },
  {
    "objectID": "reference/config/platforms/NextflowVdsl3Platform.html#container",
    "href": "reference/config/platforms/NextflowVdsl3Platform.html#container",
    "title": "Nextflow Vdsl3 Platform",
    "section": "container",
    "text": "container\nType: String\nSpecifies the Docker platform id to be used to run Nextflow."
  },
  {
    "objectID": "reference/config/platforms/NextflowVdsl3Platform.html#debug",
    "href": "reference/config/platforms/NextflowVdsl3Platform.html#debug",
    "title": "Nextflow Vdsl3 Platform",
    "section": "debug",
    "text": "debug\nType: Boolean\nWhether or not to print debug messages."
  },
  {
    "objectID": "reference/config/platforms/NextflowVdsl3Platform.html#directives",
    "href": "reference/config/platforms/NextflowVdsl3Platform.html#directives",
    "title": "Nextflow Vdsl3 Platform",
    "section": "directives",
    "text": "directives\nType: NextflowDirectives\nDirectives are optional settings that affect the execution of the process. These mostly match up with the Nextflow counterparts that are linked below:\n\naccelerator\nafterScript\nbeforeScript\ncache\nconda\ncontainer\ncontainerOptions\ncpus\ndisk\necho\nerrorStrategy\nexecutor\nmachineType\nmaxErrors\nmaxForks\nmaxRetries\nmemory\nmodule\npenv\npublishDir\nqueue\nscratch\nstoreDir\nstageInMode\nstageOutMode\ntag\ntime\n\nExample:\ndirectives:\n    container: rocker/r-ver:4.1\n    label: highcpu\n    cpus: 4\n    memory: 16 GB"
  },
  {
    "objectID": "reference/config/platforms/NextflowVdsl3Platform.html#id",
    "href": "reference/config/platforms/NextflowVdsl3Platform.html#id",
    "title": "Nextflow Vdsl3 Platform",
    "section": "id",
    "text": "id\nType: String\nEvery platform can be given a specific id that can later be referred to explicitly when running or building the Viash component.\nExample:\nid: foo"
  },
  {
    "objectID": "reference/config/platforms/NextflowVdsl3Platform.html#type",
    "href": "reference/config/platforms/NextflowVdsl3Platform.html#type",
    "title": "Nextflow Vdsl3 Platform",
    "section": "type",
    "text": "type\nType: String\nSpecifies the type of the platform."
  },
  {
    "objectID": "reference/config/platforms/NativePlatform.html",
    "href": "reference/config/platforms/NativePlatform.html",
    "title": "Native Platform",
    "section": "",
    "text": "Running a Viash component on a native platform means that the script will be executed in your current environment. Any dependencies are assumed to have been installed by the user, so the native platform is meant for developers (who know what they’re doing) or for simple bash scripts (which have no extra dependencies)."
  },
  {
    "objectID": "reference/config/platforms/NativePlatform.html#id",
    "href": "reference/config/platforms/NativePlatform.html#id",
    "title": "Native Platform",
    "section": "id",
    "text": "id\nType: String\nAs with all platforms, you can give a platform a different name. By specifying id: foo, you can target this platform (only) by specifying -p foo in any of the Viash commands.\nExample:\nid: foo"
  },
  {
    "objectID": "reference/config/platforms/NativePlatform.html#type",
    "href": "reference/config/platforms/NativePlatform.html#type",
    "title": "Native Platform",
    "section": "type",
    "text": "type\nType: String\nSpecifies the type of the platform."
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html",
    "href": "reference/config/platforms/DockerPlatform.html",
    "title": "Docker Platform",
    "section": "",
    "text": "Run a Viash component on a Docker backend platform. By specifying which dependencies your component needs, users will be able to build a docker container from scratch using the setup flag, or pull it from a docker repository."
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#apk",
    "href": "reference/config/platforms/DockerPlatform.html#apk",
    "title": "Docker Platform",
    "section": "apk",
    "text": "apk\nType: ApkRequirements\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.5.15. Use setup instead.\n\n\nSpecify which apk packages should be available in order to run the component.\nExample:\nsetup:\n  - type: apk\n    packages: [ sl ]"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#apt",
    "href": "reference/config/platforms/DockerPlatform.html#apt",
    "title": "Docker Platform",
    "section": "apt",
    "text": "apt\nType: AptRequirements\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.5.15. Use setup instead.\n\n\nSpecify which apt packages should be available in order to run the component.\nExample:\nsetup:\n  - type: apt\n    packages: [ sl ]"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#chown",
    "href": "reference/config/platforms/DockerPlatform.html#chown",
    "title": "Docker Platform",
    "section": "chown",
    "text": "chown\nType: Boolean\nIn Linux, files created by a Docker container will be owned by root. With chown: true, Viash will automatically change the ownership of output files (arguments with type: file and direction: output) to the user running the Viash command after execution of the component. Default value: true.\nExample:\nchown: false"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#docker",
    "href": "reference/config/platforms/DockerPlatform.html#docker",
    "title": "Docker Platform",
    "section": "docker",
    "text": "docker\nType: DockerRequirements\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.5.15. Use setup instead.\n\n\nSpecify which Docker commands should be run during setup.\nExample:\nsetup:\n  - type: docker\n    build_args: [ GITHUB_PAT=hello_world ]\n    run: [ git clone ... ]\n    add: [ \"http://foo.bar .\" ]\n    copy: [ \"http://foo.bar .\" ]\n    resources: \n      - resource.txt /path/to/resource.txt"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#id",
    "href": "reference/config/platforms/DockerPlatform.html#id",
    "title": "Docker Platform",
    "section": "id",
    "text": "id\nType: String\nAs with all platforms, you can give a platform a different name. By specifying id: foo, you can target this platform (only) by specifying -p foo in any of the Viash commands.\nExample:\nid: foo"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#image",
    "href": "reference/config/platforms/DockerPlatform.html#image",
    "title": "Docker Platform",
    "section": "image",
    "text": "image\nType: String\nThe base container to start from. You can also add the tag here if you wish.\nExample:\nimage: \"bash:4.0\""
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#namespace_separator",
    "href": "reference/config/platforms/DockerPlatform.html#namespace_separator",
    "title": "Docker Platform",
    "section": "namespace_separator",
    "text": "namespace_separator\nType: String\nThe default namespace separator is “_“.\nExample:\nnamespace_separator: \"+\""
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#organization",
    "href": "reference/config/platforms/DockerPlatform.html#organization",
    "title": "Docker Platform",
    "section": "organization",
    "text": "organization\nType: String\nName of a container’s organization."
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#port",
    "href": "reference/config/platforms/DockerPlatform.html#port",
    "title": "Docker Platform",
    "section": "port",
    "text": "port\nType: String / List of String\nA list of enabled ports. This doesn’t change the Dockerfile but gets added as a command-line argument at runtime.\nExample:\nport:\n  - 80\n  - 8080"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#privileged",
    "href": "reference/config/platforms/DockerPlatform.html#privileged",
    "title": "Docker Platform",
    "section": "privileged",
    "text": "privileged\nType: Boolean\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.6.3. Add a privileged flag in run_args instead.\n\n\nAdds a privileged flag to the docker run."
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#python",
    "href": "reference/config/platforms/DockerPlatform.html#python",
    "title": "Docker Platform",
    "section": "python",
    "text": "python\nType: PythonRequirements\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.5.15. Use setup instead.\n\n\nSpecify which Python packages should be available in order to run the component.\nExample:\nsetup:\n  - type: python\n    pip: [ numpy ]\n    git: [ https://some.git.repository/org/repo ]\n    github: [ jkbr/httpie ]\n    gitlab: [ foo/bar ]\n    mercurial: [ http://... ]\n    svn: [ http://...]\n    bazaar: [ http://... ]\n    url: [ http://... ]"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#r",
    "href": "reference/config/platforms/DockerPlatform.html#r",
    "title": "Docker Platform",
    "section": "r",
    "text": "r\nType: RRequirements\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.5.15. Use setup instead.\n\n\nSpecify which R packages should be available in order to run the component.\nExample:\nsetup: \n  - type: r\n    cran: [ dynutils ]\n    bioc: [ AnnotationDbi ]\n    git: [ https://some.git.repository/org/repo ]\n    github: [ rcannood/SCORPIUS ]\n    gitlab: [ org/package ]\n    svn: [ https://path.to.svn/group/repo ]\n    url: [ https://github.com/hadley/stringr/archive/HEAD.zip ]\n    script: [ 'devtools::install(\".\")' ]"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#registry",
    "href": "reference/config/platforms/DockerPlatform.html#registry",
    "title": "Docker Platform",
    "section": "registry",
    "text": "registry\nType: String\nThe URL to the a custom Docker registry\nExample:\nregistry: https://my-docker-registry.org"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#resolve_volume",
    "href": "reference/config/platforms/DockerPlatform.html#resolve_volume",
    "title": "Docker Platform",
    "section": "resolve_volume",
    "text": "resolve_volume\nType: DockerResolveVolume\nEnables or disables automatic volume mapping. Enabled when set to Automatic or disabled when set to Manual. Default: Automatic"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#run_args",
    "href": "reference/config/platforms/DockerPlatform.html#run_args",
    "title": "Docker Platform",
    "section": "run_args",
    "text": "run_args\nType: String / List of String\nAdd docker run arguments."
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#setup",
    "href": "reference/config/platforms/DockerPlatform.html#setup",
    "title": "Docker Platform",
    "section": "setup",
    "text": "setup\nType: List of Requirements\nA list of requirements for installing the following types of packages:\n\napt\napk\nDocker setup instructions\nJavaScript\nPython\nR\nRuby\nyum\n\nThe order in which these dependencies are specified determines the order in which they will be installed."
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#setup_strategy",
    "href": "reference/config/platforms/DockerPlatform.html#setup_strategy",
    "title": "Docker Platform",
    "section": "setup_strategy",
    "text": "setup_strategy\nType: DockerSetupStrategy\nThe Docker setup strategy to use when building a container.\n\n\n\nStrategy\nDescription\n\n\n\n\nalwaysbuild / build / b\nAlways build the image from the dockerfile. This is the default setup strategy.\n\n\nalwayscachedbuild / cachedbuild / cb\nAlways build the image from the dockerfile, with caching enabled.\n\n\nifneedbebuild\nBuild the image if it does not exist locally.\n\n\nifneedbecachedbuild\nBuild the image with caching enabled if it does not exist locally, with caching enabled.\n\n\nalwayspull / pull / p\nTry to pull the container from Docker Hub or the specified docker registry.\n\n\nalwayspullelsebuild / pullelsebuild\nTry to pull the image from a registry and build it if it doesn’t exist.\n\n\nalwayspullelsecachedbuild / pullelsecachedbuild\nTry to pull the image from a registry and build it with caching if it doesn’t exist.\n\n\nifneedbepull\nIf the image does not exist locally, pull the image.\n\n\nifneedbepullelsebuild\nIf the image does not exist locally, pull the image. If the image does exist, build it.\n\n\nifneedbepullelsecachedbuild\nIf the image does not exist locally, pull the image. If the image does exist, build it with caching enabled.\n\n\npush\nPush the container to Docker Hub or the specified docker registry.\n\n\npushifnotpresent\nPush the container to Docker Hub or the specified docker registry if the tag does not exist yet.\n\n\ndonothing / meh\nDo not build or pull anything.\n\n\n\nExample:\nsetup_strategy: alwaysbuild"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#tag",
    "href": "reference/config/platforms/DockerPlatform.html#tag",
    "title": "Docker Platform",
    "section": "tag",
    "text": "tag\nType: String\nSpecify a Docker image based on its tag.\nExample:\ntag: 4.0"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#target_image",
    "href": "reference/config/platforms/DockerPlatform.html#target_image",
    "title": "Docker Platform",
    "section": "target_image",
    "text": "target_image\nType: String\nIf anything is specified in the setup section, running the ---setup will result in an image with the name of <target_image>:<version>. If nothing is specified in the setup section, simply image will be used. Advanced usage only.\nExample:\ntarget_image: myfoo"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#target_image_source",
    "href": "reference/config/platforms/DockerPlatform.html#target_image_source",
    "title": "Docker Platform",
    "section": "target_image_source",
    "text": "target_image_source\nType: String\nThe source of the target image. This is used for defining labels in the dockerfile.\nExample:\ntarget_image_source: https://github.com/foo/bar"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#target_organization",
    "href": "reference/config/platforms/DockerPlatform.html#target_organization",
    "title": "Docker Platform",
    "section": "target_organization",
    "text": "target_organization\nType: String\nThe organization set in the resulting image. Advanced usage only.\nExample:\ntarget_organization: viash-io"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#target_registry",
    "href": "reference/config/platforms/DockerPlatform.html#target_registry",
    "title": "Docker Platform",
    "section": "target_registry",
    "text": "target_registry\nType: String\nThe URL where the resulting image will be pushed to. Advanced usage only.\nExample:\ntarget_registry: https://my-docker-registry.org"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#target_tag",
    "href": "reference/config/platforms/DockerPlatform.html#target_tag",
    "title": "Docker Platform",
    "section": "target_tag",
    "text": "target_tag\nType: String\nThe tag the resulting image gets. Advanced usage only.\nExample:\ntarget_tag: 0.5.0"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#test_setup",
    "href": "reference/config/platforms/DockerPlatform.html#test_setup",
    "title": "Docker Platform",
    "section": "test_setup",
    "text": "test_setup\nType: List of Requirements\nAdditional requirements specific for running unit tests."
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#type",
    "href": "reference/config/platforms/DockerPlatform.html#type",
    "title": "Docker Platform",
    "section": "type",
    "text": "type\nType: String\nSpecifies the type of the platform."
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#workdir",
    "href": "reference/config/platforms/DockerPlatform.html#workdir",
    "title": "Docker Platform",
    "section": "workdir",
    "text": "workdir\nType: String\nThe working directory when starting the container. This doesn’t change the Dockerfile but gets added as a command-line argument at runtime.\nExample:\nworkdir: /home/user"
  },
  {
    "objectID": "reference/config/platforms/DockerPlatform.html#yum",
    "href": "reference/config/platforms/DockerPlatform.html#yum",
    "title": "Docker Platform",
    "section": "yum",
    "text": "yum\nType: YumRequirements\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.5.15. Use setup instead.\n\n\nSpecify which yum packages should be available in order to run the component.\nExample:\nsetup:\n  - type: yum\n    packages: [ sl ]"
  },
  {
    "objectID": "reference/config/functionality.html",
    "href": "reference/config/functionality.html",
    "title": "Functionality",
    "section": "",
    "text": "The functionality-part of the config file describes the behaviour of the script in terms of arguments and resources. By specifying a few restrictions (e.g. mandatory arguments) and adding some descriptions, Viash will automatically generate a stylish command-line interface for you."
  },
  {
    "objectID": "reference/config/functionality.html#add_resources_to_path",
    "href": "reference/config/functionality.html#add_resources_to_path",
    "title": "Functionality",
    "section": "add_resources_to_path",
    "text": "add_resources_to_path\nType: Boolean\n\n\n\n\n\n\nWarning\n\n\n\nRemoved since Viash 0.5.11. Extending the PATH turned out to be not desirable.\n\n\nAdds the resources directory to the PATH variable when set to true. This is set to false by default."
  },
  {
    "objectID": "reference/config/functionality.html#argument_groups",
    "href": "reference/config/functionality.html#argument_groups",
    "title": "Functionality",
    "section": "argument_groups",
    "text": "argument_groups\nType: List of ArgumentGroup\nA grouping of the arguments, used to display the help message.\n\nname: foo, the name of the argument group.\ndescription: Description of foo, a description of the argument group. Multiline descriptions are supported.\narguments: [arg1, arg2, ...], list of the arguments names.\n\nExample:\nargument_groups:\n  - name: \"Input\"\n    arguments:\n      - name: \"--id\"\n        type: string\n        required: true\n      - name: \"--input\"\n        type: file\n        required: true\n  - name: \"Output\"\n    arguments:\n      - name: \"--output\"\n        type: file\n        direction: output\n        required: true\n      - name: \"--output_optional\"\n        type: file\n        direction: output\nThis results in the following output when calling the component with the --help argument:\ncomponent_name\n\n  Input:\n      --id\n          type: string\n\n      --input\n          type: file\n\n  Output:\n      --output\n          type: file\n\n      --optional_output\n          type: file"
  },
  {
    "objectID": "reference/config/functionality.html#arguments",
    "href": "reference/config/functionality.html#arguments",
    "title": "Functionality",
    "section": "arguments",
    "text": "arguments\nType: List of Argument\nA list of arguments for this component. For each argument, a type and a name must be specified. Depending on the type of argument, different properties can be set. See these reference pages per type for more information:\n\nstring\nfile\ninteger\ndouble\nboolean\nboolean_true\nboolean_false\n\nExample:\narguments:\n   - name: --foo\n    type: file\n    alternatives: [-f]\n    description: Description of foo\n    default: \"/foo/bar\"\n    must_exist: true\n    direction: output\n    required: false\n    multiple: true\n    multiple_sep: \",\"\n   - name: --bar\n    type: string"
  },
  {
    "objectID": "reference/config/functionality.html#authors",
    "href": "reference/config/functionality.html#authors",
    "title": "Functionality",
    "section": "authors",
    "text": "authors\nType: List of Author\nA list of authors. An author must at least have a name, but can also have a list of roles, an e-mail address, and a map of custom properties.\nSuggested values for roles are:\n\n\n\n\n\n\n\n\nRole\nAbbrev.\nDescription\n\n\n\n\nmaintainer\nmnt\nfor the maintainer of the code. Ideally, exactly one maintainer is specified.\n\n\nauthor\naut\nfor persons who have made substantial contributions to the software.\n\n\ncontributor\nctb\nfor persons who have made smaller contributions (such as code patches).\n\n\ndatacontributor\ndtc\nfor persons or organisations that contributed data sets for the software\n\n\ncopyrightholder\ncph\nfor all copyright holders. This is a legal concept so should use the legal name of an institution or corporate body.\n\n\nfunder\nfnd\nfor persons or organizations that furnished financial support for the development of the software\n\n\n\nThe full list of roles is extremely comprehensive.\nExample:\nauthors:\n  - name: Bob Cando\n    roles: [maintainer, author]\n    email: bob@can.do\n    props: {github: bobcando, orcid: 0000-0001-0002-0003}\n  - name: Tim Farbe\n    roles: [author]\n    email: tim@far.be"
  },
  {
    "objectID": "reference/config/functionality.html#description",
    "href": "reference/config/functionality.html#description",
    "title": "Functionality",
    "section": "description",
    "text": "description\nType: String\nA description of the component. This will be displayed with --help.\nExample:\ndescription: |\n  This component performs function Y and Z.\n  It is possible to make this a multiline string."
  },
  {
    "objectID": "reference/config/functionality.html#enabled",
    "href": "reference/config/functionality.html#enabled",
    "title": "Functionality",
    "section": "enabled",
    "text": "enabled\nType: Boolean\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.6.0. Use status instead.\n\n\nSetting this to false with disable this component when using namespaces."
  },
  {
    "objectID": "reference/config/functionality.html#info",
    "href": "reference/config/functionality.html#info",
    "title": "Functionality",
    "section": "info",
    "text": "info\nType: Json\nStructured information. Can be any shape: a string, vector, map or even nested map.\nExample:\ninfo:\n  twitter: wizzkid\n  classes: [ one, two, three ]"
  },
  {
    "objectID": "reference/config/functionality.html#inputs",
    "href": "reference/config/functionality.html#inputs",
    "title": "Functionality",
    "section": "inputs",
    "text": "inputs\nType: List of Argument\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.6.0. Use arguments instead.\n\n\nA list of input arguments in addition to the arguments list. Any arguments specified here will have their type set to file and the direction set to input by default.\nExample:\ninputs:\n  - name: input_file\n  - name: another_input\nThis results in the following output when calling the component with the --help argument:\ncomponent_with_inputs\n  \n  Inputs:\n      input_file\n          type: file\n  \n      another_input\n          type: file"
  },
  {
    "objectID": "reference/config/functionality.html#name",
    "href": "reference/config/functionality.html#name",
    "title": "Functionality",
    "section": "name",
    "text": "name\nType: String\nName of the component and the filename of the executable when built with viash build.\nExample:\nname: this_is_my_component"
  },
  {
    "objectID": "reference/config/functionality.html#namespace",
    "href": "reference/config/functionality.html#namespace",
    "title": "Functionality",
    "section": "namespace",
    "text": "namespace\nType: String\nNamespace this component is a part of. See the Namespaces guide for more information on namespaces.\nExample:\nnamespace: fancy_components"
  },
  {
    "objectID": "reference/config/functionality.html#outputs",
    "href": "reference/config/functionality.html#outputs",
    "title": "Functionality",
    "section": "outputs",
    "text": "outputs\nType: List of Argument\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.6.0. Use arguments instead.\n\n\nA list of output arguments in addition to the arguments list. Any arguments specified here will have their type set to file and thr direction set to output by default.\nExample:\noutputs:\n  - name: output_file\n  - name: another_output\nThis results in the following output when calling the component with the --help argument:\ncomponent_with_outputs\n  \n  Outputs:\n      output_file\n          type: file, output\n  \n      another_output\n          type: file, output"
  },
  {
    "objectID": "reference/config/functionality.html#requirements",
    "href": "reference/config/functionality.html#requirements",
    "title": "Functionality",
    "section": "requirements",
    "text": "requirements\nType: ComputationalRequirements\nComputational requirements related to running the component. cpus specifies the maximum number of (logical) cpus a component is allowed to use., whereas memory specifies the maximum amount of memory a component is allowed to allicate. Memory units must be in B, KB, MB, GB, TB or PB.\nExample:\nrequirements:\n  cpus: 5\n  memory: 10GB"
  },
  {
    "objectID": "reference/config/functionality.html#resources",
    "href": "reference/config/functionality.html#resources",
    "title": "Functionality",
    "section": "resources",
    "text": "resources\nType: List of Resource\nResources are files that support the component. The first resource should be a script that will be executed when the functionality is run. Additional resources will be copied to the same directory.\nCommon properties:\n\ntype: file / r_script / python_script / bash_script / javascript_script / scala_script / csharp_script, the type of resource. The first resource cannot be of type file. When the type is not specified, the default type is simply file.\nname: filename, the resulting name of the resource.\npath: path/to/file, the path of the input file. Can be a relative or an absolute path, or a URI.\ntext: …multiline text…, the raw content of the input file. Exactly one of path or text must be defined, the other undefined.\nis_executable: true / false, whether the resulting file is made executable.\n\nExample:\nresources:\n  - type: r_script\n    path: script.R\n  - type: file\n    path: resource1.txt"
  },
  {
    "objectID": "reference/config/functionality.html#status",
    "href": "reference/config/functionality.html#status",
    "title": "Functionality",
    "section": "status",
    "text": "status\nType: Status\nAllows setting a component to active, deprecated or disabled."
  },
  {
    "objectID": "reference/config/functionality.html#test_resources",
    "href": "reference/config/functionality.html#test_resources",
    "title": "Functionality",
    "section": "test_resources",
    "text": "test_resources\nType: List of Resource\nOne or more scripts to be used to test the component behaviour when viash test is invoked. Additional files of type file will be made available only during testing. Each test script should expect no command-line inputs, be platform-independent, and return an exit code >0 when unexpected behaviour occurs during testing. See Unit Testing for more info.\nExample:\ntest_resources:\n  - type: bash_script\n    path: tests/test1.sh\n  - type: r_script\n    path: tests/test2.R\n  - path: resource1.txt"
  },
  {
    "objectID": "reference/config/functionality.html#tests",
    "href": "reference/config/functionality.html#tests",
    "title": "Functionality",
    "section": "tests",
    "text": "tests\nType: List of Resource\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.5.13. Use test_resources instead. No functional difference.\n\n\nOne or more Bash/R/Python scripts to be used to test the component behaviour when viash test is invoked. Additional files of type file will be made available only during testing. Each test script should expect no command-line inputs, be platform-independent, and return an exit code >0 when unexpected behaviour occurs during testing."
  },
  {
    "objectID": "reference/config/functionality.html#usage",
    "href": "reference/config/functionality.html#usage",
    "title": "Functionality",
    "section": "usage",
    "text": "usage\nType: String\nA description on how to use the component. This will be displayed with --help under the ‘Usage:’ section.\nExample:\nusage: Place the executable in a directory containing TSV files and run it"
  },
  {
    "objectID": "reference/config/functionality.html#version",
    "href": "reference/config/functionality.html#version",
    "title": "Functionality",
    "section": "version",
    "text": "version\nType: String\nVersion of the component. This field will be used to version the executable and the Docker container.\nExample:\nversion: 0.8"
  },
  {
    "objectID": "reference/config/config-modding.html",
    "href": "reference/config/config-modding.html",
    "title": "Dynamic Config Modding",
    "section": "",
    "text": "Viash can modify a viash config at runtime using a custom Domain Specific Language (DSL). This allows making dynamic changes to your components or projects.\nAll Viash subcommands have support for the DSL through the -c|--config_mod parameter. The format for these is as follows:\nMultiple config mods can be added by adding more -c|--config_mod parameters:"
  },
  {
    "objectID": "reference/config/config-modding.html#examples",
    "href": "reference/config/config-modding.html#examples",
    "title": "Dynamic Config Modding",
    "section": "Examples",
    "text": "Examples\nChange the version of a component:\nviash build -c '.functionality.version := \"0.3.0\"'\nChange the registry of a docker container:\nviash build -c \\\n  '.platforms[.type == \"docker\"].container_registry := \"url-to-registry\"'\nAdd an author to the list:\nviash build -c '.functionality.authors += { name: \"Mr. T\", role: \"sponsor\" }'\nYou can use dynamic config modding to alter the config of multiple components at once:\nviash ns build \\\n  -c '.functionality.version := \"0.3.0\"' \\\n  -c '.platforms[.type == \"docker\"].container_registry := \"url-to-registry\"' \\\n  -c '.functionality.authors += { name: \"Mr. T\", role: \"sponsor\" }'"
  },
  {
    "objectID": "reference/config/requirements/rRequirements.html",
    "href": "reference/config/requirements/rRequirements.html",
    "title": "R Requirements",
    "section": "",
    "text": "Specify which R packages should be available in order to run the component.\n\nExample\nsetup: \n  - type: r\n    cran: [ dynutils ]\n    bioc: [ AnnotationDbi ]\n    git: [ https://some.git.repository/org/repo ]\n    github: [ rcannood/SCORPIUS ]\n    gitlab: [ org/package ]\n    svn: [ https://path.to.svn/group/repo ]\n    url: [ https://github.com/hadley/stringr/archive/HEAD.zip ]\n    script: [ 'devtools::install(\".\")' ]"
  },
  {
    "objectID": "reference/config/requirements/javascriptRequirements.html",
    "href": "reference/config/requirements/javascriptRequirements.html",
    "title": "Javascript Requirements",
    "section": "",
    "text": "Specify which JavaScript packages should be available in order to run the component.\n\nExample\nsetup:\n  - type: javascript\n    npm: [ packagename ]\n    git: [ https://... ]\n    github: [ owner/repository ]\n    url: [ https://... ]"
  },
  {
    "objectID": "reference/config/requirements/aptRequirements.html",
    "href": "reference/config/requirements/aptRequirements.html",
    "title": "Apt Requirements",
    "section": "",
    "text": "Specify which apt packages should be available in order to run the component.\n\nExample\nsetup:\n  - type: apt\n    packages: [ sl ]"
  },
  {
    "objectID": "reference/config/requirements/yumRequirements.html",
    "href": "reference/config/requirements/yumRequirements.html",
    "title": "Yum Requirements",
    "section": "",
    "text": "Specify which yum packages should be available in order to run the component.\n\nExample\nsetup:\n  - type: yum\n    packages: [ sl ]"
  },
  {
    "objectID": "reference/config/requirements/rubyRequirements.html",
    "href": "reference/config/requirements/rubyRequirements.html",
    "title": "Ruby Requirements",
    "section": "",
    "text": "Specify which Ruby packages should be available in order to run the component.\n\nExample\nsetup:\n  - type: ruby\n    packages: [ rspec ]"
  },
  {
    "objectID": "reference/config/requirements/dockerRequirements.html",
    "href": "reference/config/requirements/dockerRequirements.html",
    "title": "Docker Requirements",
    "section": "",
    "text": "Specify which Docker commands should be run during setup.\n\nExample\nsetup:\n  - type: docker\n    build_args: [ GITHUB_PAT=hello_world ]\n    run: [ git clone ... ]\n    add: [ \"http://foo.bar .\" ]\n    copy: [ \"http://foo.bar .\" ]\n    resources: \n      - resource.txt /path/to/resource.txt"
  },
  {
    "objectID": "reference/config/requirements/pythonRequirements.html",
    "href": "reference/config/requirements/pythonRequirements.html",
    "title": "Python Requirements",
    "section": "",
    "text": "Specify which Python packages should be available in order to run the component.\n\nExample\nsetup:\n  - type: python\n    pip: [ numpy ]\n    git: [ https://some.git.repository/org/repo ]\n    github: [ jkbr/httpie ]\n    gitlab: [ foo/bar ]\n    mercurial: [ http://... ]\n    svn: [ http://...]\n    bazaar: [ http://... ]\n    url: [ http://... ]"
  },
  {
    "objectID": "reference/config/requirements/apkRequirements.html",
    "href": "reference/config/requirements/apkRequirements.html",
    "title": "Apk Requirements",
    "section": "",
    "text": "Specify which apk packages should be available in order to run the component.\n\nExample\nsetup:\n  - type: apk\n    packages: [ sl ]"
  },
  {
    "objectID": "reference/config/requirements.html",
    "href": "reference/config/requirements.html",
    "title": "Setup Requirements",
    "section": "",
    "text": "Specify which apk packages should be available in order to run the component.\nExample:\nsetup:\n  - type: apk\n    packages: [ sl ]\n\n\nType: String / List of String\nSpecifies which packages to install.\nExample:\npackages: [ sl ]\n\n\n\nType: String\nSpecifies the type of the requirement specification."
  },
  {
    "objectID": "reference/config/requirements.html#apt-requirements",
    "href": "reference/config/requirements.html#apt-requirements",
    "title": "Setup Requirements",
    "section": "Apt Requirements",
    "text": "Apt Requirements\nSpecify which apt packages should be available in order to run the component.\nExample:\nsetup:\n  - type: apt\n    packages: [ sl ]\n\ninteractive\nType: Boolean\nIf false, the Debian frontend is set to non-interactive (recommended). Default: false.\n\n\npackages\nType: String / List of String\nSpecifies which packages to install.\nExample:\npackages: [ sl ]\n\n\ntype\nType: String\nSpecifies the type of the requirement specification."
  },
  {
    "objectID": "reference/config/requirements.html#docker-requirements",
    "href": "reference/config/requirements.html#docker-requirements",
    "title": "Setup Requirements",
    "section": "Docker Requirements",
    "text": "Docker Requirements\nSpecify which Docker commands should be run during setup.\nExample:\nsetup:\n  - type: docker\n    build_args: \"R_VERSION=hello_world\"\n    run: |\n      echo 'Run a custom command'\n      echo 'Foo' > /path/to/file.txt\n\nadd\nType: String / List of String\nSpecifies which ADD entries to add to the Dockerfile while building it.\nExample:\nadd: [ \"http://foo/bar .\" ]\n\n\nbuild_args\nType: String / List of String\nSpecifies which ARG entries to add to the Dockerfile while building it.\nExample:\nbuild_args: [ \"R_VERSION=4.2\" ]\n\n\ncopy\nType: String / List of String\nSpecifies which COPY entries to add to the Dockerfile while building it.\nExample:\ncopy: [ \"resource.txt /path/to/resource.txt\" ]\n\n\nenv\nType: String / List of String\nSpecifies which ENV entries to add to the Dockerfile while building it. Unlike ARG, ENV entries are also accessible from inside the container.\nExample:\nenv: [ \"R_VERSION=4.2\" ]\n\n\nlabel\nType: String / List of String\nSpecifies which LABEL entries to add to the Dockerfile while building it.\nExample:\nlabel: [ component=\"foo\" ]\n\n\nresources\nType: String / List of String\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.6.3. Use copy instead.\n\n\nSpecifies which COPY entries to add to the Dockerfile while building it.\nExample:\nresources: [ \"resource.txt /path/to/resource.txt\" ]\n\n\nrun\nType: String / List of String\nSpecifies which RUN entries to add to the Dockerfile while building it.\nExample:\nrun: |\n  echo 'Run a custom command'\n  echo 'Foo' > /path/to/file.txt\n\n\ntype\nType: String\nSpecifies the type of the requirement specification."
  },
  {
    "objectID": "reference/config/requirements.html#javascript-requirements",
    "href": "reference/config/requirements.html#javascript-requirements",
    "title": "Setup Requirements",
    "section": "Javascript Requirements",
    "text": "Javascript Requirements\nSpecify which JavaScript packages should be available in order to run the component.\nExample:\nsetup:\n  - type: javascript\n    npm: packagename\n    git: \"https://some.git.repository/org/repo\"\n    github: \"owner/repository\"\n    url: \"https://github.com/org/repo/archive/HEAD.zip\"\n\ngit\nType: String / List of String\nSpecifies which packages to install using a Git URI.\nExample:\ngit: [ https://some.git.repository/org/repo ]\n\n\ngithub\nType: String / List of String\nSpecifies which packages to install from GitHub.\nExample:\ngithub: [ owner/repository ]\n\n\nnpm\nType: String / List of String\nSpecifies which packages to install from npm.\nExample:\nnpm: [ packagename ]\n\n\npackages\nType: String / List of String\nSpecifies which packages to install from npm.\nExample:\npackages: [ packagename ]\n\n\ntype\nType: String\nSpecifies the type of the requirement specification.\n\n\nurl\nType: String / List of String\nSpecifies which packages to install using a generic URI.\nExample:\nurl: [ https://github.com/org/repo/archive/HEAD.zip ]"
  },
  {
    "objectID": "reference/config/requirements.html#python-requirements",
    "href": "reference/config/requirements.html#python-requirements",
    "title": "Setup Requirements",
    "section": "Python Requirements",
    "text": "Python Requirements\nSpecify which Python packages should be available in order to run the component.\nExample:\nsetup:\n  - type: python\n    pip: numpy\n    github: [ jkbr/httpie, foo/bar ]\n    url: \"https://github.com/some_org/some_pkg/zipball/master\"\n\nbazaar\nType: String / List of String\nSpecifies which packages to install using a Bazaar URI.\nExample:\nbazaar: [ http://bazaar.launchpad.net/some_pkg/some_pkg/release-0.1 ]\n\n\ngit\nType: String / List of String\nSpecifies which packages to install using a Git URI.\nExample:\ngit: [ https://some.git.repository/org/repo ]\n\n\ngithub\nType: String / List of String\nSpecifies which packages to install from GitHub.\nExample:\ngithub: [ jkbr/httpie ]\n\n\ngitlab\nType: String / List of String\nSpecifies which packages to install from GitLab.\nExample:\ngitlab: [ foo/bar ]\n\n\nmercurial\nType: String / List of String\nSpecifies which packages to install using a Mercurial URI.\nExample:\nmercurial: [ https://hg.myproject.org/MyProject/#egg=MyProject ]\n\n\npackages\nType: String / List of String\nSpecifies which packages to install from pip.\nExample:\npackages: [ numpy ]\n\n\npip\nType: String / List of String\nSpecifies which packages to install from pip.\nExample:\npip: [ numpy ]\n\n\npypi\nType: String / List of String\nSpecifies which packages to install from PyPI using pip.\nExample:\npypi: [ numpy ]\n\n\nscript\nType: String / List of String\nSpecifies a code block to run as part of the build.\nExample:\nscript: |\n  print(\"Running custom code\")\n  x = 1 + 1 == 2\n\n\nsvn\nType: String / List of String\nSpecifies which packages to install using an SVN URI.\nExample:\nsvn: [ http://svn.repo/some_pkg/trunk/#egg=SomePackage ]\n\n\ntype\nType: String\nSpecifies the type of the requirement specification.\n\n\nupgrade\nType: Boolean\nSets the --upgrade flag when set to true. Default: true.\n\n\nurl\nType: String / List of String\nSpecifies which packages to install using a generic URI.\nExample:\nurl: [ https://github.com/some_org/some_pkg/zipball/master ]\n\n\nuser\nType: Boolean\nSets the --user flag when set to true. Default: false."
  },
  {
    "objectID": "reference/config/requirements.html#r-requirements",
    "href": "reference/config/requirements.html#r-requirements",
    "title": "Setup Requirements",
    "section": "R Requirements",
    "text": "R Requirements\nSpecify which R packages should be available in order to run the component.\nExample:\nsetup: \n  - type: r\n    cran: anndata\n    bioc: [ AnnotationDbi, SingleCellExperiment ]\n    github: rcannood/SCORPIUS\n\nbioc\nType: String / List of String\nSpecifies which packages to install from BioConductor.\nExample:\nbioc: [ AnnotationDbi ]\n\n\nbioc_force_install\nType: Boolean\nForces packages specified in bioc to be reinstalled, even if they are already present in the container. Default: false.\nExample:\nbioc_force_install: false\n\n\nbitbucket\nType: String / List of String\nSpecifies which packages to install from Bitbucket.\nExample:\nbitbucket: [ org/package ]\n\n\ncran\nType: String / List of String\nSpecifies which packages to install from CRAN.\nExample:\ncran: [ anndata, ggplot2 ]\n\n\ngit\nType: String / List of String\nSpecifies which packages to install using a Git URI.\nExample:\ngit: [ https://some.git.repository/org/repo ]\n\n\ngithub\nType: String / List of String\nSpecifies which packages to install from GitHub.\nExample:\ngithub: [ rcannood/SCORPIUS ]\n\n\ngitlab\nType: String / List of String\nSpecifies which packages to install from GitLab.\nExample:\ngitlab: [ org/package ]\n\n\npackages\nType: String / List of String\nSpecifies which packages to install from CRAN.\nExample:\npackages: [ anndata, ggplot2 ]\n\n\nscript\nType: String / List of String\nSpecifies a code block to run as part of the build.\nExample:\nscript: |\n  cat(\"Running custom code\n\")\n  install.packages(\"anndata\")\n\n\nsvn\nType: String / List of String\nSpecifies which packages to install using an SVN URI.\nExample:\nsvn: [ https://path.to.svn/group/repo ]\n\n\ntype\nType: String\nSpecifies the type of the requirement specification.\n\n\nurl\nType: String / List of String\nSpecifies which packages to install using a generic URI.\nExample:\nurl: [ https://github.com/hadley/stringr/archive/HEAD.zip ]"
  },
  {
    "objectID": "reference/config/requirements.html#ruby-requirements",
    "href": "reference/config/requirements.html#ruby-requirements",
    "title": "Setup Requirements",
    "section": "Ruby Requirements",
    "text": "Ruby Requirements\nSpecify which Ruby packages should be available in order to run the component.\nExample:\nsetup:\n  - type: ruby\n    packages: [ rspec ]\n\npackages\nType: String / List of String\nSpecifies which packages to install.\nExample:\npackages: [ rspec ]\n\n\ntype\nType: String\nSpecifies the type of the requirement specification."
  },
  {
    "objectID": "reference/config/requirements.html#yum-requirements",
    "href": "reference/config/requirements.html#yum-requirements",
    "title": "Setup Requirements",
    "section": "Yum Requirements",
    "text": "Yum Requirements\nSpecify which yum packages should be available in order to run the component.\nExample:\nsetup:\n  - type: yum\n    packages: [ sl ]\n\npackages\nType: String / List of String\nSpecifies which packages to install.\nExample:\npackages: [ sl ]\n\n\ntype\nType: String\nSpecifies the type of the requirement specification."
  },
  {
    "objectID": "reference/viash/run.html",
    "href": "reference/viash/run.html",
    "title": "viash run",
    "section": "",
    "text": "Executes a viash component from the provided viash config file. viash generates a temporary executable and immediately executes it with the given parameters.\nUsage:\nviash run config.vsh.yaml [-p docker] [-k true/false]  -- [arguments for script]\n\n\n\nArgument\nDescription\nType\n\n\n\n\nconfig\nA viash config file (example: config.vsh.yaml). This argument can also be a script with the config as a header. This is a required argument.\nString\n\n\n--config_mod, -c\nModify a viash config at runtime using dynamic config modding.\nList[String]\n\n\n--cpus\nThe maximum number of (logical) cpus a component is allowed to use.\nInt\n\n\n--keep, -k\nWhether or not to keep temporary files. By default, files will be deleted if all goes well but remain when an error occurs. By specifying –keep true, the temporary files will always be retained, whereas –keep false will always delete them. The temporary directory can be overwritten by setting defining a VIASH_TEMP directory.\nString\n\n\n--memory\nThe maximum amount of memory a component is allowed to allocate. Unit must be one of B, KB, MB, GB, TB or PB.\nString\n\n\n--platform, -p\nSpecifies which platform amongst those specified in the config to use. If this is not provided, the first platform will be used. If no platforms are defined in the config, the native platform will be used. In addition, the path to a platform yaml file can also be specified.\nString\n\n\n--help, -h\nShow help message"
  },
  {
    "objectID": "reference/viash/build.html",
    "href": "reference/viash/build.html",
    "title": "viash build",
    "section": "",
    "text": "Build an executable from the provided viash config file.\nUsage:\nviash build config.vsh.yaml -o output [-p docker] [-m] [-s]\n\n\n\nArgument\nDescription\nType\n\n\n\n\nconfig\nA viash config file (example: config.vsh.yaml). This argument can also be a script with the config as a header. This is a required argument.\nString\n\n\n--config_mod, -c\nModify a viash config at runtime using dynamic config modding.\nList[String]\n\n\n--meta, -m\nPrint out some meta information at the end.\nBoolean\n\n\n--output, -o\nPath to directory in which the executable and any resources is built to. Default: “output/”. This is a required argument.\nString\n\n\n--platform, -p\nSpecifies which platform amongst those specified in the config to use. If this is not provided, the first platform will be used. If no platforms are defined in the config, the native platform will be used. In addition, the path to a platform yaml file can also be specified.\nString\n\n\n--push\nWhether or not to push the container to a Docker registry [Docker Platform only].\nBoolean\n\n\n--setup, -s\nWhich setup strategy for creating the container to use [Docker Platform only].\nString\n\n\n--write_meta, -w\nWrite out some meta information to RESOURCES_DIR/viash.yaml at the end.\nBoolean\n\n\n--help, -h\nShow help message"
  },
  {
    "objectID": "reference/viash/test.html",
    "href": "reference/viash/test.html",
    "title": "viash test",
    "section": "",
    "text": "Test the component using the tests defined in the viash config file.\nUsage:\nviash test config.vsh.yaml [-p docker] [-k true/false]\n\n\n\nArgument\nDescription\nType\n\n\n\n\nconfig\nA viash config file (example: config.vsh.yaml). This argument can also be a script with the config as a header. This is a required argument.\nString\n\n\n--config_mod, -c\nModify a viash config at runtime using dynamic config modding.\nList[String]\n\n\n--cpus\nThe maximum number of (logical) cpus a component is allowed to use.\nInt\n\n\n--keep, -k\nWhether or not to keep temporary files. By default, files will be deleted if all goes well but remain when an error occurs. By specifying –keep true, the temporary files will always be retained, whereas –keep false will always delete them. The temporary directory can be overwritten by setting defining a VIASH_TEMP directory.\nString\n\n\n--memory\nThe maximum amount of memory a component is allowed to allocate. Unit must be one of B, KB, MB, GB, TB or PB.\nString\n\n\n--platform, -p\nSpecifies which platform amongst those specified in the config to use. If this is not provided, the first platform will be used. If no platforms are defined in the config, the native platform will be used. In addition, the path to a platform yaml file can also be specified.\nString\n\n\n--help, -h\nShow help message"
  },
  {
    "objectID": "reference/viash/config.html",
    "href": "reference/viash/config.html",
    "title": "viash config",
    "section": "",
    "text": "View the config file after parsing.\nUsage:\nviash config view config.vsh.yaml\n\n\n\nArgument\nDescription\nType\n\n\n\n\nconfig\nA viash config file (example: config.vsh.yaml). This argument can also be a script with the config as a header. This is a required argument.\nString\n\n\n--config_mod, -c\nModify a viash config at runtime using dynamic config modding.\nList[String]\n\n\n--format, -f\nWhich output format to use.\nString\n\n\n--parse_argument_groups\nWhether or not to postprocess each component’s argument groups.\nBoolean\n\n\n--platform, -p\nSpecifies which platform amongst those specified in the config to use. If this is not provided, the first platform will be used. If no platforms are defined in the config, the native platform will be used. In addition, the path to a platform yaml file can also be specified.\nString\n\n\n--help, -h\nShow help message"
  },
  {
    "objectID": "reference/viash/config.html#viash-config-inject",
    "href": "reference/viash/config.html#viash-config-inject",
    "title": "viash config",
    "section": "viash config inject",
    "text": "viash config inject\nInject a Viash header into the main script of a Viash component.\nUsage:\nviash config inject config.vsh.yaml\n\n\n\nArgument\nDescription\nType\n\n\n\n\nconfig\nA viash config file (example: config.vsh.yaml). This argument can also be a script with the config as a header. This is a required argument.\nString\n\n\n--config_mod, -c\nModify a viash config at runtime using dynamic config modding.\nList[String]\n\n\n--platform, -p\nSpecifies which platform amongst those specified in the config to use. If this is not provided, the first platform will be used. If no platforms are defined in the config, the native platform will be used. In addition, the path to a platform yaml file can also be specified.\nString\n\n\n--help, -h\nShow help message"
  },
  {
    "objectID": "reference/viash/ns.html",
    "href": "reference/viash/ns.html",
    "title": "viash ns",
    "section": "",
    "text": "Build a namespace from many viash config files.\nUsage:\nviash ns build [-n nmspc] [-s src] [-t target] [-p docker] [--setup] [---push] [--parallel] [--flatten]\n\n\n\nArgument\nDescription\nType\n\n\n\n\n--config_mod, -c\nModify a viash config at runtime using dynamic config modding.\nList[String]\n\n\n--flatten, -f\nFlatten the target builds, handy for building one platform to a bin directory.\nBoolean\n\n\n--parallel, -l\nWhether or not to run the process in parallel.\nBoolean\n\n\n--platform, -p\nActs as a regular expression to filter the platform ids specified in the found config files. If this is not provided, all platforms will be used. If no platforms are defined in a config, the native platform will be used. In addition, the path to a platform yaml file can also be specified.\nString\n\n\n--push\nWhether or not to push the container to a Docker registry [Docker Platform only].\nBoolean\n\n\n--query, -q\nFilter which components get selected by component and namespace name. Can be a regex. Example: “^mynamespace/component1$”.\nString\n\n\n--query_name\nFilter which components get selected by component name. Can be a regex. Example: “^component1”.\nString\n\n\n--query_namespace, -n\nFilter which namespaces get selected by namespace name. Can be a regex. Example: “^mynamespace$”.\nString\n\n\n--setup\nWhich setup strategy for creating the container to use [Docker Platform only].\nString\n\n\n--src, -s\nA source directory containing viash config files, possibly structured in a hierarchical folder structure. Default: src/.\nString\n\n\n--target, -t\nA target directory to build the executables into. Default: target/.\nString\n\n\n--write_meta, -w\nWrite out some meta information to RESOURCES_DIR/viash.yaml at the end.\nBoolean\n\n\n--help, -h\nShow help message"
  },
  {
    "objectID": "reference/viash/ns.html#viash-ns-test",
    "href": "reference/viash/ns.html#viash-ns-test",
    "title": "viash ns",
    "section": "viash ns test",
    "text": "viash ns test\nTest a namespace containing many viash config files.\nUsage:\nviash ns test [-n nmspc] [-s src] [-p docker] [--parallel] [--tsv file.tsv] [--append]\n\n\n\nArgument\nDescription\nType\n\n\n\n\n--append, -a\nAppend to tsv instead of overwrite\nBoolean\n\n\n--config_mod, -c\nModify a viash config at runtime using dynamic config modding.\nList[String]\n\n\n--cpus\nThe maximum number of (logical) cpus a component is allowed to use.\nInt\n\n\n--keep, -k\nWhether or not to keep temporary files. By default, files will be deleted if all goes well but remain when an error occurs. By specifying –keep true, the temporary files will always be retained, whereas –keep false will always delete them. The temporary directory can be overwritten by setting defining a VIASH_TEMP directory.\nString\n\n\n--memory\nThe maximum amount of memory a component is allowed to allocate. Unit must be one of B, KB, MB, GB, TB or PB.\nString\n\n\n--parallel, -l\nWhether or not to run the process in parallel.\nBoolean\n\n\n--platform, -p\nActs as a regular expression to filter the platform ids specified in the found config files. If this is not provided, all platforms will be used. If no platforms are defined in a config, the native platform will be used. In addition, the path to a platform yaml file can also be specified.\nString\n\n\n--query, -q\nFilter which components get selected by component and namespace name. Can be a regex. Example: “^mynamespace/component1$”.\nString\n\n\n--query_name\nFilter which components get selected by component name. Can be a regex. Example: “^component1”.\nString\n\n\n--query_namespace, -n\nFilter which namespaces get selected by namespace name. Can be a regex. Example: “^mynamespace$”.\nString\n\n\n--src, -s\nA source directory containing viash config files, possibly structured in a hierarchical folder structure. Default: src/.\nString\n\n\n--tsv, -t\nPath to write a summary of the test results to.\nString\n\n\n--help, -h\nShow help message"
  },
  {
    "objectID": "reference/viash/ns.html#viash-ns-list",
    "href": "reference/viash/ns.html#viash-ns-list",
    "title": "viash ns",
    "section": "viash ns list",
    "text": "viash ns list\nList a namespace containing many viash config files.\nUsage:\nviash ns list [-n nmspc] [-s src] [-p docker]\n\n\n\nArgument\nDescription\nType\n\n\n\n\n--config_mod, -c\nModify a viash config at runtime using dynamic config modding.\nList[String]\n\n\n--format, -f\nWhich output format to use.\nString\n\n\n--parallel, -l\nWhether or not to run the process in parallel.\nBoolean\n\n\n--parse_argument_groups\nWhether or not to postprocess each component’s argument groups.\nBoolean\n\n\n--platform, -p\nActs as a regular expression to filter the platform ids specified in the found config files. If this is not provided, all platforms will be used. If no platforms are defined in a config, the native platform will be used. In addition, the path to a platform yaml file can also be specified.\nString\n\n\n--query, -q\nFilter which components get selected by component and namespace name. Can be a regex. Example: “^mynamespace/component1$”.\nString\n\n\n--query_name\nFilter which components get selected by component name. Can be a regex. Example: “^component1”.\nString\n\n\n--query_namespace, -n\nFilter which namespaces get selected by namespace name. Can be a regex. Example: “^mynamespace$”.\nString\n\n\n--src, -s\nA source directory containing viash config files, possibly structured in a hierarchical folder structure. Default: src/.\nString\n\n\n--help, -h\nShow help message"
  },
  {
    "objectID": "reference/viash/ns.html#viash-ns-exec",
    "href": "reference/viash/ns.html#viash-ns-exec",
    "title": "viash ns",
    "section": "viash ns exec",
    "text": "viash ns exec\nExecute a command for all found Viash components. The syntax of this command is inspired by find . -exec echo {} \\;.\nThe following fields are automatically replaced:\n\n{} | {path}: path to the config file\n{abs-path}: absolute path to the config file\n{dir}: path to the parent directory of the config file\n{abs-dir}: absolute path to the directory of the config file\n{main-script}: path to the main script (if any)\n{abs-main-script}: absolute path to the main script (if any)\n{functionality-name}: name of the component\n{namespace}: namespace of the component\n{platform}: selected platform id (only when –apply_platform is used)\n\nA command suffixed by \\; (or nothing) will execute one command for each of the Viash components, whereas a command suffixed by + will execute one command for all Viash components.\nUsage:\nviash ns exec 'echo {path} \\\\;'\nviash ns exec 'chmod +x {main-script} +'\n\n\n\n\n\n\n\n\nArgument\nDescription\nType\n\n\n\n\n--apply_platform, -a\nFills in the {platform} field by applying each platform to the config separately.\n\n\n\n\nNote that this results in the provided command being applied once for every platform that matches the –platform regex. | Boolean | | --cmd | The command to execute for each viash config file in the namespace. This is a required argument. | String | | --config_mod, -c | Modify a viash config at runtime using dynamic config modding. | List[String] | | --dry_run, -d | Perform a dry run. | Boolean | | --parallel, -l | Whether or not to run the process in parallel. | Boolean | | --platform, -p | Acts as a regular expression to filter the platform ids specified in the found config files. If this is not provided, all platforms will be used. If no platforms are defined in a config, the native platform will be used. In addition, the path to a platform yaml file can also be specified. | String | | --query, -q | Filter which components get selected by component and namespace name. Can be a regex. Example: “^mynamespace/component1$”. | String | | --query_name | Filter which components get selected by component name. Can be a regex. Example: “^component1”. | String | | --query_namespace, -n | Filter which namespaces get selected by namespace name. Can be a regex. Example: “^mynamespace$”. | String | | --src, -s | A source directory containing viash config files, possibly structured in a hierarchical folder structure. Default: src/. | String | | --help, -h | Show help message | |"
  },
  {
    "objectID": "guide/dev-environment/vscode.html",
    "href": "guide/dev-environment/vscode.html",
    "title": "VS Code",
    "section": "",
    "text": "Viash supports a lot of different scripting languages and requires you to be somewhat familiar with YAML to create and edit config files. You’re free to use any editor of your choosing to write these files.\nOn this page, we want to provide you with all the necessary information if you choose Visual Studio Code for both the writing of the scripts and the creation of a config file."
  },
  {
    "objectID": "guide/dev-environment/vscode.html#general",
    "href": "guide/dev-environment/vscode.html#general",
    "title": "VS Code",
    "section": "General",
    "text": "General\nThese extensions are useful for most languages:\n\nCode Runner: This allows you to easily run any selected code and output the results to the built-in terminal. Make sure to take a look at the Configuration section of the page to set it up for the languages you’ll work with.\nCode Spell Checker: A quality of life extension that prevents you from making common spelling mistakes in your code by showing squiggly underlines below typos.\nDocker: Build, manage and deploy containerized applications with this extension. Also provides one-click debugging for Node.js, Python and .NET Core inside a container. Very useful for testing out scripts inside of a container before creating components.\nError Lens: This extension makes errors and warnings more prominent by highlighting the entire line and adding the message at the end. This can speed up the writing of scripts tremendously.\nPrettier code formatter: Integrates the prettier code formatter into VS Code, which makes formatting your code extremely easy."
  },
  {
    "objectID": "guide/dev-environment/vscode.html#yaml",
    "href": "guide/dev-environment/vscode.html#yaml",
    "title": "VS Code",
    "section": "YAML",
    "text": "YAML\nViash config files are written in YAML, so it makes sense to have an extension for that language:\n\nYAML: This extension provides YAML validation, syntax highlighting, auto completion and document outlining for YAML. A must have for writing and editing Viash config files!"
  },
  {
    "objectID": "guide/dev-environment/vscode.html#markdown",
    "href": "guide/dev-environment/vscode.html#markdown",
    "title": "VS Code",
    "section": "Markdown",
    "text": "Markdown\nIf you’re planning on writing documentation for components you write, can supplement the description and the CLI with a Markdown document. VS Code has Markdown support built-in, but the extension below makes writing markdown documents even easier!\n\nMarkdown All in One: Some of the features include keyboard shortcuts for text formatting, list editing , GitHub flavored Markdown and auto completion for Markdown."
  },
  {
    "objectID": "guide/dev-environment/vscode.html#bash",
    "href": "guide/dev-environment/vscode.html#bash",
    "title": "VS Code",
    "section": "Bash",
    "text": "Bash\n\nshell-format: By installing this extension, you get syntax highlighting and code formatting for shell scripts."
  },
  {
    "objectID": "guide/dev-environment/vscode.html#c",
    "href": "guide/dev-environment/vscode.html#c",
    "title": "VS Code",
    "section": "C#",
    "text": "C#\n\nC#: Adds syntax highlighting, IntelliSense and debugging capabilities to VS Code for C#."
  },
  {
    "objectID": "guide/dev-environment/vscode.html#python",
    "href": "guide/dev-environment/vscode.html#python",
    "title": "VS Code",
    "section": "Python",
    "text": "Python\nPython: Adds syntax highlighting, IntelliSense, debugging and code formatting. This extension also installs the PyLance language server and Jupyter for Jupyter Notebook support."
  },
  {
    "objectID": "guide/dev-environment/vscode.html#javascript",
    "href": "guide/dev-environment/vscode.html#javascript",
    "title": "VS Code",
    "section": "Javascript",
    "text": "Javascript\nNode.js Extension Pack: VS Code actually already has a lot of Node.js features out of the box, but this extension pack adds adds even more. The extensions adds JS code hints, module search, code snippets and IntelliSense for NPM and paths just to name a few features."
  },
  {
    "objectID": "guide/dev-environment/vscode.html#r",
    "href": "guide/dev-environment/vscode.html#r",
    "title": "VS Code",
    "section": "R",
    "text": "R\nR: This extension adds syntax highlighting, code analysis, keyboard shortcuts, package management and a lot more for the R language.\n\nNote: This extension requires you to install R and the languageserver CRAN package which depends on libxml2-dev, libcurl4-openssl-dev and libssl-dev before the extension will work."
  },
  {
    "objectID": "guide/dev-environment/vscode.html#scala",
    "href": "guide/dev-environment/vscode.html#scala",
    "title": "VS Code",
    "section": "Scala",
    "text": "Scala\n\nScala Syntax (official): Adds syntax highlighting for Scala 2 and 3.\nScala (Metals): Adds code completion, debugging, formatting, renaming and much more for Scala."
  },
  {
    "objectID": "guide/dev-environment/vscode.html#wsl2",
    "href": "guide/dev-environment/vscode.html#wsl2",
    "title": "VS Code",
    "section": "WSL2",
    "text": "WSL2\nIf you’re using WSL2, you’ll probably want to install the Remote - WSL extension. This extension lets you use your Windows version of VS Code in WSL2, as if it was running native.\nThe commands, extensions and the terminal will run on WSL, which makes for an ideal hybrid environment.\nOnce installed, you can connect to WSL2 by clicking the green remote button at the bottom left and choosing New WSL Window in the list that pops up. Alternatively, you can use the command code FOLDER/FILE (e.g. code .) on the WSL2 side to open that file or folder in a remote VS Code session."
  },
  {
    "objectID": "guide/building-block/native-building-running.html",
    "href": "guide/building-block/native-building-running.html",
    "title": "Native Executable",
    "section": "",
    "text": "This guide covers how you can can build and run a native executable."
  },
  {
    "objectID": "guide/building-block/native-building-running.html#building-a-native-executable",
    "href": "guide/building-block/native-building-running.html#building-a-native-executable",
    "title": "Native Executable",
    "section": "Building a native executable",
    "text": "Building a native executable\nTo start with, create a Viash component that targets the native platform as explained in this guide or download the sample component via the download button below.\nThe zip contains the component in all supported languages. Simply rename the language folder you want to use to hello_world and use that as your working directory.\nDownload hello_world.zip\nNext, use the viash build command to generate an executable inside of a bin directory:\nviash build config.vsh.yaml --output bin\nThis will generate an executable named the same as your component in the bin directory:\nhello_world\n├── bin\n│   └── hello_world\n├── config.vsh.yaml\n└── script.sh"
  },
  {
    "objectID": "guide/building-block/native-building-running.html#documentation",
    "href": "guide/building-block/native-building-running.html#documentation",
    "title": "Native Executable",
    "section": "Documentation",
    "text": "Documentation\nIt’s often useful to know what arguments an executable expects before trying to run it. To display its documentation, run the executable with just the --help argument:\nbin/hello_world --help\nThis will result in output that looks like this:\nhello_world\n\nA minimal example component.\n\nOptions:\n    --input\n        type: string\n        default: World\nThis example takes a single optional string named --input as an argument."
  },
  {
    "objectID": "guide/building-block/native-building-running.html#running-the-executable",
    "href": "guide/building-block/native-building-running.html#running-the-executable",
    "title": "Native Executable",
    "section": "Running the executable",
    "text": "Running the executable\nRunning a native executable is the same as any other executable on your system. Simply call it as a command in your terminal:\nbin/hello_world\nThis results in the following output:\nHello World\nYou can pass arguments to it directly, which differs from using the viash run command as Viash itself isn’t called:\nbin/hello_world --input \"everyone!\"\nThis outputs:\nHello everyone!"
  },
  {
    "objectID": "guide/building-block/native-building-running.html#whats-next",
    "href": "guide/building-block/native-building-running.html#whats-next",
    "title": "Native Executable",
    "section": "What’s next?",
    "text": "What’s next?\n\n\nNow you know how to build and run native executables, you might also be interested in learning more about executables with a Docker backend."
  },
  {
    "objectID": "guide/building-block/nextflow/building-running.html",
    "href": "guide/building-block/nextflow/building-running.html",
    "title": "Build & Run",
    "section": "",
    "text": "This guide covers how you can can build a Nextflow module and run it as a standalone pipeline."
  },
  {
    "objectID": "guide/building-block/nextflow/building-running.html#building-a-nextflow-vdsl3-module",
    "href": "guide/building-block/nextflow/building-running.html#building-a-nextflow-vdsl3-module",
    "title": "Build & Run",
    "section": "Building a Nextflow VDSL3 module",
    "text": "Building a Nextflow VDSL3 module\nTo start off, either follow along with the Nextflow component creation guide to create a simple hello_world component that targets Nextflow or download the zip below containing the component in all supported languages.\nDownload hello_world_nextflow.zip\nIf you downloaded the zip above, rename the language folder you want to use to hello_world and use that as your working directory.\nTo let Viash generate a Nextflow module from your component, use the viash build command:\nviash build src/config.vsh.yaml --platform nextflow --output target\nThis will generate two files in the target directory: a pipeline script named main.nf and a Nextflow config file named nextflow.config. Your directory structure should now look like this:\nhello_world\n├── src\n│   ├── config.vsh.yaml\n│   └── script.sh\n└── target\n    ├── main.nf\n    └── nextflow.config"
  },
  {
    "objectID": "guide/building-block/nextflow/building-running.html#running-a-standalone-pipeline",
    "href": "guide/building-block/nextflow/building-running.html#running-a-standalone-pipeline",
    "title": "Build & Run",
    "section": "Running a standalone pipeline",
    "text": "Running a standalone pipeline\nWith the module built, you can now call the pipeline script with nextflow to run it standalone:\nnextflow run target/main.nf --publishDir ./output --output myFile.txt \nYou might be wondering where the --publishDir argument comes from. This is required by Nextflow, it specifies the directory where the output from the module should be put. In this case, a new folder named output. The --output argument sets the filename, myFile.txt.\nHere’s what should be shown in the console:\nN E X T F L O W  ~  version 22.04.5\nLaunching `target/main.nf` [prickly_brattain] DSL2 - revision: 3c1902d86f\nWARN: Key for module 'hello_world' is duplicated.\n\nexecutor >  local (1)\n[90/735d3c] process > hello_world:hello_world_process1 (1) [100%] 1 of 1 ✔\ninput: [hello_world, [input:World, id:hello_world, output:myFile.txt]]\noutput: [hello_world, /home/user/hello_world/work/90/735d3cc9396ce3aa5629eb9ede59b7/myFile.txt]\nNextflow will have generated several directories and files, but the one we’re interested in is the output directory. It should contain a file named myFile.txt with a single line of text: Hello World. You can check this by opening the file or printing its contents to the terminal like this:\ncat output/myFile.txt \nWhich should result in:\nHello World"
  },
  {
    "objectID": "guide/building-block/nextflow/building-running.html#whats-next",
    "href": "guide/building-block/nextflow/building-running.html#whats-next",
    "title": "Build & Run",
    "section": "What’s next?",
    "text": "What’s next?\nTo use generated modules inside an actual Nextflow pipeline, take a look at our Pipeline Basics guide."
  },
  {
    "objectID": "guide/building-block/docker/setup-strategies.html",
    "href": "guide/building-block/docker/setup-strategies.html",
    "title": "Setup Strategies",
    "section": "",
    "text": "Viash supports the use of several different Docker setup strategies. You can choose what strategy to build an executable with when using a Docker backend by passing the --setup option followed by one of the strategies below.\nFor example:"
  },
  {
    "objectID": "guide/building-block/docker/setup-strategies.html#build",
    "href": "guide/building-block/docker/setup-strategies.html#build",
    "title": "Setup Strategies",
    "section": "Build",
    "text": "Build\n\nalwaysbuild / build / b: Always build the image from the dockerfile. This is the default setup strategy.\nalwayscachedbuild / cachedbuild / cb: Always build the image from the dockerfile, with caching enabled.\nifneedbebuild: Build the image if it does not exist locally.\nifneedbecachedbuild: Build the image with caching enabled if it does not exist locally."
  },
  {
    "objectID": "guide/building-block/docker/setup-strategies.html#pull",
    "href": "guide/building-block/docker/setup-strategies.html#pull",
    "title": "Setup Strategies",
    "section": "Pull",
    "text": "Pull\n\nalwayspull / pull / p: Try to pull the container from Docker Hub or the specified docker registry.\nalwayspullelsebuild / pullelsebuild: Try to pull the image from a registry and build it if it doesn’t exist.\nalwayspullelsecachedbuild / pullelsecachedbuild: Try to pull the image from a registry and build it with caching if it doesn’t exist.\nifneedbepull: If the image does not exist locally, pull the image.\nifneedbepullelsebuild If the image does not exist locally, pull the image. If the image does exist, build it.\nifneedbepullelsecachedbuild: If the image does not exist locally, pull the image. If the image does exist, build it with caching enabled."
  },
  {
    "objectID": "guide/building-block/docker/setup-strategies.html#push",
    "href": "guide/building-block/docker/setup-strategies.html#push",
    "title": "Setup Strategies",
    "section": "Push",
    "text": "Push\n\npush: Push the container to Docker Hub or the specified docker registry.\npushifnotpresent Push the container to Docker Hub or the specified docker registry if the specified tag does not exist yet."
  },
  {
    "objectID": "guide/building-block/docker/setup-strategies.html#do-nothing",
    "href": "guide/building-block/docker/setup-strategies.html#do-nothing",
    "title": "Setup Strategies",
    "section": "Do nothing",
    "text": "Do nothing\n\ndonothing / meh: Do not build or pull anything."
  },
  {
    "objectID": "guide/building-block/docker/building-running.html",
    "href": "guide/building-block/docker/building-running.html",
    "title": "Build & Run",
    "section": "",
    "text": "This guide covers how you can can build and run an executable with a Docker backend. Most of what is covered in the Native Executable guide is true for executables with a Docker backend."
  },
  {
    "objectID": "guide/building-block/docker/building-running.html#building-the-executable",
    "href": "guide/building-block/docker/building-running.html#building-the-executable",
    "title": "Build & Run",
    "section": "Building the executable",
    "text": "Building the executable\nIf you have multiple platforms defined in your Viash config file, use the --platform argument of viash build to specify you want to create an executable with a Docker backend.\nviash build config.vsh.yaml --platform docker --output bin"
  },
  {
    "objectID": "guide/building-block/docker/building-running.html#running-the-executable",
    "href": "guide/building-block/docker/building-running.html#running-the-executable",
    "title": "Build & Run",
    "section": "Running the executable",
    "text": "Running the executable\nYou can run the executable by executing it as a command:\nbin/hello_world\nExecutable with a Docker backend include functions to create a Docker image and a container based on your Viash config file. When you run the executable for the first time, both the image and container will built, followed by running the executable inside of the container:\n[notice] Checking if Docker image is available at 'hello_world:latest'\n[warning] Could not pull from 'hello_world:latest'. Docker image doesn't exist or is not accessible.\n[notice] Building container 'hello_world:latest' with Dockerfile\nHello World\nIf you already have the container on your system, that will be used to run the executable:\nHello World"
  },
  {
    "objectID": "guide/building-block/docker/building-running.html#whats-next",
    "href": "guide/building-block/docker/building-running.html#whats-next",
    "title": "Build & Run",
    "section": "What’s next?",
    "text": "What’s next?\nNow you know how to build and run executables with a Docker backend, you may be interested in building and running Nextflow modules."
  },
  {
    "objectID": "guide/building-block/docker/inspect-dockerfile.html",
    "href": "guide/building-block/docker/inspect-dockerfile.html",
    "title": "Inspect Dockerfile",
    "section": "",
    "text": "Viash generates a dockerfile for executables with a Docker backend. You can view the result of this by passing the hidden ---dockerfile argument to an executable:\nviash run -p docker config.vsh.yaml -- ---dockerfile\n./my_docker_executable ---dockerfile\nBoth of these output the Docker config to the terminal:\nFROM bash:latest\n\nRUN apk add --no-cache curl"
  },
  {
    "objectID": "guide/building-block/docker/docker-volume.html",
    "href": "guide/building-block/docker/docker-volume.html",
    "title": "Docker Volumes",
    "section": "",
    "text": "Viash automatically creates a Docker volume for components and executables with a Docker backend if a file argument exists in the config file. This allows your script to read and write files as if working with them natively.\nThe full mount path is /viash_automount/ABSOLUTE_PATH_TO_FILE_DIRECTORY.\nBy default, files created and modified by a Docker container are owned by root. By default, Viash automatically changes the owner of any files defined in the config file to the user running the executable. This behaviour can be overridden by setting the chown setting to false in your config file.\n\n\n\n\n\n\nImportant\n\n\n\nAny files your script generates that are not defined as file arguments will still be owned by root as Viash won’t have any knowledge of them."
  },
  {
    "objectID": "guide/data-workflow/nextflow-pipeline/pipeline-basics.html",
    "href": "guide/data-workflow/nextflow-pipeline/pipeline-basics.html",
    "title": "Basic Pipeline",
    "section": "",
    "text": "This guide will explain how to create a basic Nextflow pipeline using a Viash component."
  },
  {
    "objectID": "guide/data-workflow/nextflow-pipeline/pipeline-basics.html#creating-the-module",
    "href": "guide/data-workflow/nextflow-pipeline/pipeline-basics.html#creating-the-module",
    "title": "Basic Pipeline",
    "section": "Creating the module",
    "text": "Creating the module\nNextflow works with modules to run scripts and handle their input and output, so the first step is generating a Nextflow module from a Viash component. This guide will use a small component named remove_comments that removes comments (lines starting with a hashtag) from a TSV file.\n\n\n\n\n\n\nNote\n\n\n\nThis guide won’t go in-depth about how to generate a Nextflow module from a Viash component. For more information on that topic, read the Nextflow component creation and the Nextflow Build & Run guides.\n\n\n\nDownload the source files\nDownload the zip below and extract it to a directory of your choosing:\nDownload basic_pipeline.zip\nOnce extracted, the directory contains the remove_comments component in the src directory and a small TSV file in the data directory:\nbasic_pipeline\n├── data\n│   └── sample.tsv\n└── src\n    └── remove_comments\n        ├── config.vsh.yaml\n        └── script.sh\n\n\nBuilding the Nextflow module\nWith the component ready, execute the viash build command below to generate the Nextflow module:\nviash build src/remove_comments/config.vsh.yaml -p nextflow -o target/remove_comments\nYou should now have a target directory that contains the generated Nextflow module.\nbasic_pipeline\n├── data\n│   └── sample.tsv\n├── src\n│   └── remove_comments\n│       ├── config.vsh.yaml\n│       └── script.sh\n└── target\n    └── remove_comments\n        ├── main.nf\n        └── nextflow.config"
  },
  {
    "objectID": "guide/data-workflow/nextflow-pipeline/pipeline-basics.html#creating-the-pipeline",
    "href": "guide/data-workflow/nextflow-pipeline/pipeline-basics.html#creating-the-pipeline",
    "title": "Basic Pipeline",
    "section": "Creating the pipeline",
    "text": "Creating the pipeline\nTo use the module in a pipeline, create a new file in the root of the directory and name it main.nf, this will be the Nextflow pipeline script. Add this as its contents:\ntargetDir = \"./target\" // 1\n\ninclude { remove_comments } from \"$targetDir/remove_comments/main.nf\" // 2\n\nworkflow {\n  Channel.fromPath(params.input) // 3\n    | map{ file -> [ file.baseName, file ] } // 4\n    | view{ file -> \"Input: $file\" } // 5\n    | remove_comments.run( // 6\n      auto: [ publish: true ]\n      )\n    | view{ file -> \"Output: $file\" } // 7\n}\nHere’s an overview of this Nextflow script:\n\nStore the location of the target directory where the modules are located\nInclude the remove_comments module from the remove_comments/main.nf script\nCreate a channel based on the input parameter’s path\nTake the tuple list and map it to the [ file.baseName, file ] format\nPrint the input tuple to the console\nRun the remove_comments module with auto publishing enabled using the auto directive, this makes sure that the output of this module is written to a directory based on its id\nPrint the output tuple to the console"
  },
  {
    "objectID": "guide/data-workflow/nextflow-pipeline/pipeline-basics.html#running-the-pipeline",
    "href": "guide/data-workflow/nextflow-pipeline/pipeline-basics.html#running-the-pipeline",
    "title": "Basic Pipeline",
    "section": "Running the pipeline",
    "text": "Running the pipeline\nYou can now run the pipeline script above with Nextflow using the following command:\nnextflow run main.nf --input \"data/sample.tsv\" --publishDir output\nThis results in a console output similar to this:\nN E X T F L O W  ~  version 22.04.3\nLaunching `main.nf` [curious_gates] DSL2 - revision: 3e22e3038c\nexecutor >  local (1)\n[2a/5df658] process > remove_comments:remove_comments_process (1) [100%] 1 of 1 ✔\nInput: [sample, basic_pipeline/data/sample.tsv]\nOutput: [sample, basic_pipeline/work/2a/5df6584524e26995953a4eaec97136/sample.remove_comments.output.tsv]\nAfter the pipeline has finished working, a new file named sample.remove_comments.output.tsv has been created in the output directory:\nbasic_pipeline\n└── output\n    └── sample.remove_comments.output.tsv\nFor comparison, here’s what the input and output files look like to show what changed:\nsample.tsv\n# this is a header      \n# this is also a header     \none     0.11    123\ntwo     0.23    456\nthree   0.35    789\nfour    0.47    123\nsample.remove_comments.output.tsv\none     0.11    123\ntwo     0.23    456\nthree   0.35    789\nfour    0.47    123"
  },
  {
    "objectID": "guide/data-workflow/nextflow-pipeline/pipeline-basics.html#whats-next",
    "href": "guide/data-workflow/nextflow-pipeline/pipeline-basics.html#whats-next",
    "title": "Basic Pipeline",
    "section": "What’s next?",
    "text": "What’s next?\nThe pipeline in this guide was a bare minimum example, to learn more about creating Nextflow pipelines, take a look at the Advanced Pipeline guide."
  },
  {
    "objectID": "guide/data-workflow/nextflow-pipeline/pipeline-advanced.html",
    "href": "guide/data-workflow/nextflow-pipeline/pipeline-advanced.html",
    "title": "Advanced Pipeline",
    "section": "",
    "text": "This guide explains how to create an example pipeline that’s closer to a typical use-case of a Nextflow bioinformatics pipeline. It has a mixture of scripting languages and uses a join to merge all events."
  },
  {
    "objectID": "guide/data-workflow/nextflow-pipeline/pipeline-advanced.html#creating-the-modules",
    "href": "guide/data-workflow/nextflow-pipeline/pipeline-advanced.html#creating-the-modules",
    "title": "Advanced Pipeline",
    "section": "Creating the modules",
    "text": "Creating the modules\nThe sections below describe how to create the VDSL3 modules in preparation for creating the pipeline.\n\nPreparation\ncreate a new folder named advanced pipeline, add src folder with a nextflow_module folder inside. Now create three folders inside nextflow_module folder, one per component needed for the pipeline:\n\ncombine_columns\nremove_comments\ntake_columns\n\nThe folder structure should look like this now:\nadvanced_pipeline\n└── src\n    └── nextflow_modules\n        ├── combine_columns\n        ├── remove_comments\n        └── take_column\n\n\nCreating the remove_comments component\nThis component removes all comments (lines starting with a hashtag) from a tsv file.\nDownload or copy the contents of config.vsh.yaml and script.sh below into the remove_comments folder.\nDownload config.vsh.yaml\n\n\n\nContents of config.vsh.yaml\n\nfunctionality:\n  name: remove_comments\n  description: Remove comments from a TSV file.\n  namespace: nextflow_modules\n  arguments:\n    - name: \"--input\"\n      alternatives: [ \"-i\" ]\n      type: file\n      required: true\n      example: \"file.tsv\"\n    - name: \"--output\"\n      alternatives: [ \"-o\" ]\n      type: file\n      required: true\n      direction: output\n      example: \"file.tsv\"\n    - type: string\n      name: --id\n      default: \"remove_comments\"\n  resources:\n  - type: bash_script\n    path: ./script.sh\nplatforms:\n  - type: docker\n    image: ubuntu:20.04\n  - type: nextflow\n    variant: vdsl3\n\nDownload script.sh\n\n\n\nContents of script.sh\n\n#!/bin/bash\n\ngrep -v '^#' \"$par_input\" > \"$par_output\"\n\n\n\nCreating the take_column component\nThis component subsets an incoming tsv file by extracting a certain column from the file.\nDownload or copy the contents of config.vsh.yaml and script.py below into the take_column folder.\nDownload config.vsh.yaml\n\n\n\nContents of config.vsh.yaml\n\nfunctionality:\n  name: take_column\n  namespace: nextflow_modules\n  arguments:\n    - name: \"--input\"\n      alternatives: [ \"-i\" ]\n      type: file\n      required: true\n    - name: \"--output\"\n      alternatives: [ \"-o\" ]\n      type: file\n      required: true\n      direction: output\n    - name: \"--column\"\n      type: integer\n      required: false\n      default: 2\n    - type: string\n      name: --id\n      default: \"take_column\"\n  resources:\n  - type: python_script\n    path: ./script.py\nplatforms:\n  - type: nextflow\n    variant: vdsl3\n    directives:\n      container: amancevice/pandas:slim\n\nDownload script.py\n\n\n\nContents of script.py\n\nimport pandas as pd\n\n## VIASH START\npar = {\n    \"input\": \"data/file1.tsv\",\n    \"column\": 2,\n    \"output\": \"temp/foo\"\n}\n## VIASH END\n\n# read the tsv file\ntab = pd.read_csv(par[\"input\"], sep=\"\\t\", comment=\"#\")\n\n# subset a column\ntab_filt = tab.iloc[:, par[\"column\"]-1]\n\n# write to file\ntab_filt.to_csv(par[\"output\"], index=False)\n\n\n\nCreating the combine_columns component\nThis component combines multiple tsv files into one by concatenating all of the columns together. It assumes each incoming tsv file has an equal number of rows.\nDownload or copy the contents of config.vsh.yaml and script.R below into the combine_columns folder.\nDownload config.vsh.yaml\n\n\n\nContents of config.vsh.yaml\n\nfunctionality:\n  name: combine_columns\n  namespace: nextflow_modules\n  arguments:\n    - name: \"--input\"\n      alternatives: [ \"-i\" ]\n      type: file\n      multiple: true\n      required: true\n    - name: \"--output\"\n      alternatives: [ \"-o\" ]\n      type: file\n      required: true\n      direction: output\n    - type: string\n      name: --id\n      default: \"combine_columns\"\n  resources:\n    - type: r_script\n      path: ./script.R\nplatforms:\n  - type: nextflow\n    variant: vdsl3\n    directives:\n      container: rocker/r-ver:4.1\n\nDownload script.R\n\n\n\nContents of script.R\n\n## VIASH START\npar <- list(\n    input = c(\"data/file1.tsv\", \"data/file2.tsv\"),\n    output = \"temp/foo.tsv\"\n)\n## VIASH END\n\nouts <- lapply(par$input, function(file) {\n  read.delim(file, comment.char = \"#\", sep = \"\\t\", header = FALSE)\n})\n\ntable <- do.call(cbind, outs)\n\nwrite.table(table, par$output, col.names = FALSE, sep = \"\\t\")"
  },
  {
    "objectID": "guide/data-workflow/nextflow-pipeline/pipeline-advanced.html#building-the-modules",
    "href": "guide/data-workflow/nextflow-pipeline/pipeline-advanced.html#building-the-modules",
    "title": "Advanced Pipeline",
    "section": "Building the modules",
    "text": "Building the modules\nThe basic pipeline guide describes how to generate an individual VDSL3 Nextflow module using the viash build command, but there’s a better way when it comes to building multiple modules at once: viash ns build. Each one of the three components has its namespace defined as nextflow_modules inside of its config file. Execute this command from the root of the advanced_pipeline directory\nviash ns build\nThis will result in the following output:\nExporting take_column (nextflow_modules) =nextflow=> target/nextflow/nextflow_modules/take_column\nExporting combine_columns (nextflow_modules) =nextflow=> target/nextflow/nextflow_modules/combine_columns\nExporting remove_comments (nextflow_modules) =nextflow=> target/nextflow/nextflow_modules/remove_comments\nThe VDSL3 Nextflow modules were generated inside of a target folder. The directory structure now looks like this:\nadvanced_pipeline\n├── src\n│   └── nextflow_modules\n│       ├── combine_columns\n│       │   ├── config.vsh.yaml\n│       │   └── script.R\n│       ├── remove_comments\n│       │   ├── config.vsh.yaml\n│       │   └── script.sh\n│       └── take_column\n│           ├── config.vsh.yaml\n│           └── script.py\n└── target\n    └── nextflow\n        └── nextflow_modules\n            ├── combine_columns\n            │   ├── main.nf\n            │   └── nextflow.config\n            ├── remove_comments\n            │   ├── main.nf\n            │   └── nextflow.config\n            └── take_column\n                ├── main.nf\n                └── nextflow.config"
  },
  {
    "objectID": "guide/data-workflow/nextflow-pipeline/pipeline-advanced.html#creating-the-pipeline",
    "href": "guide/data-workflow/nextflow-pipeline/pipeline-advanced.html#creating-the-pipeline",
    "title": "Advanced Pipeline",
    "section": "Creating the pipeline",
    "text": "Creating the pipeline\nCreate a new file named main.nf and add it to the root of the advanced_pipeline directory. Use the following as its contents:\ntargetDir = \"../target/nextflow\" // 1\n\n// 2\ninclude { remove_comments } from \"$targetDir/nextflow_modules/remove_comments/main.nf\"\ninclude { take_column } from \"$targetDir/nextflow_modules/take_column/main.nf\"\ninclude { combine_columns } from \"$targetDir/nextflow_modules/combine_columns/main.nf\"\n\nworkflow {\n  Channel.fromPath(params.input) // 3\n  \n    // 4\n    // File -> (String, File)\n    | map{ file -> [ file.baseName, file ] }\n    \n    // 5\n    // (String, File) -> (String, File)\n    | remove_comments\n\n    // 6\n    // (String, File) -> (String, File)\n    | take_column\n\n    // 7\n    // (String, File)* -> List[(String, File)]\n    | toList()\n\n    // 8\n    // List[(String, File)] -> (String, {input: List[File]})\n    | map{ tups -> \n      files = tups.collect{id, file -> file}\n      [ \"combined\", [ input: files ] ] \n    }\n\n    // 9\n    // (String, {input: List[File]}) -> (String, File)\n    | combine_columns.run(\n      auto: [ publish: true ]\n      )\n\n    // 10\n    | view{ file -> \"Output: $file\" }\n}\n\nTarget directory where the modules are located\nInclude the modules from the target directory\nCreate a channel based on the input parameter’s path\nAssign a unique ID to each event using map{}\nRun remove_comments to remove the comments from the TSV\nExtract a single column from TSV by running take_column\nCombine all events into a single List event using toList()\nAdd unique ID to the tuple\nConcatenate the TSVs into one by running the combine_columns module with auto publishing enabled using the auto directive\nView the channel contents bu printing it to the console using view()"
  },
  {
    "objectID": "guide/data-workflow/nextflow-pipeline/pipeline-advanced.html#running-the-pipeline",
    "href": "guide/data-workflow/nextflow-pipeline/pipeline-advanced.html#running-the-pipeline",
    "title": "Advanced Pipeline",
    "section": "Running the pipeline",
    "text": "Running the pipeline\nBefore being able to run the pipeline, you’ll need some TSV files to work with. Download the files below and place them in a new directory named data in the root of advanced_pipeline.\nDownload file1.tsv\nDownload file2.tsv\nNow run the following command to run the pipeline using Nextflow:\nnextflow run main.nf --input \"data/file?.tsv\" --publishDir output\nYou should get an output similar to this:\nN E X T F L O W  ~  version 22.04.3\nLaunching `workflows/310-realistic_pipeline/main.nf` [stupefied_saha] DSL2 - revision: 6669aefc6c\n[93/232aba] Submitted process > remove_comments:remove_comments_process (2)\n[ef/a28e89] Submitted process > remove_comments:remove_comments_process (1)\n[63/279f98] Submitted process > take_column:take_column_process (1)\n[50/2a17ef] Submitted process > take_column:take_column_process (2)\n[8d/6eeff5] Submitted process > combine_columns:combine_columns_process\nOutput: [combined, /home/runner/work/viash_nxf_course/viash_nxf_course/work/8d/6eeff571e9ff2c5389851c6ab3001c/combined.combine_columns.output]\nYou can find the final TSV in the output directory:\n# this is a header      \n# this is also a header     \none     0.11    123\ntwo     0.23    456\nthree   0.35    789\nfour    0.47    123"
  },
  {
    "objectID": "guide/component/unit-testing.html",
    "href": "guide/component/unit-testing.html",
    "title": "Unit Testing",
    "section": "",
    "text": "To ensure that your components and namespaces works as expected during its development cycle, writing one or more tests is essential.\nViash supports unit testing, which is a software testing method by which individual units of source code are tested to determine whether they output data as expected."
  },
  {
    "objectID": "guide/component/unit-testing.html#unit-testing-a-single-component",
    "href": "guide/component/unit-testing.html#unit-testing-a-single-component",
    "title": "Unit Testing",
    "section": "Unit testing a single component",
    "text": "Unit testing a single component\nTo write a unit test for a component, you need two things: a definition in the config file and a script that runs the executable and verifies its output.\nThis tutorial uses a sample component named md_url_checker to explain how to write a unit test for Viash. To follow along, start by creating a new folder named “testing” on your machine.\nNow create a new file named Testfile.md and add the following contents:\n# Test File\n\nThis is a simple markdown file with some hyperlinks to test if the component works correctly.\nSome links to websites:\n\n- [Google](https://www.google.com)\n- [Reddit](https://www.reddit.com)\n- [A broken link](http://microsoft.com/random-link)\n\nLinks that are relative to [viash.io](http://www.viash.io):\n\n- You can [install viash here](/installation).\n- It all starts with a script and a [config file](/reference/config/index.html).\nNext, either download or copy the text for the config file and script below and add them to the same folder:\nDownload config.vsh.yaml\n\n\n\nContents of config.vsh.yaml\n\nfunctionality:\n  name: md_url_checker\n  description: Check if URLs in a markdown are reachable and create a text report with the results.\n  arguments:                     \n  - type: file\n    name: --inputfile\n    description: The input markdown file.\n    required: true\n    must_exist: true\n  - type: string                           \n    name: --domain\n    description: The domain URL that gets inserted before any relative URLs. For example, \"/intro\" could be replaced with \"https://my-website/intro\" to create a valid URL.\n  - type: file                           \n    name: --output\n    description: The path of the output text file that will contain the report.\n    default: \"output.txt\"\n    direction: output\n  resources:\n  - type: bash_script\n    path: script.sh\n  test_resources:\n  - type: bash_script\n    path: test.sh\n  - path: Testfile.md\nplatforms:\n  - type: native\n  - type: docker\n    image: bash:latest\n    setup:\n      - type: apk\n        packages: [ curl ]\n\nDownload script.sh\n\n\n\nContents of script.sh\n\n#!/usr/bin/env bash\n\n### 1 ###\n\n## VIASH START\n\npar_inputfile=\"Testfile.md\"\npar_domain=\"https://viash.io\"\npar_output=\"output.txt\"\n\n## VIASH END\n\namount_of_errors=0\n\necho \"Extracting URLs\"\n\n### 2 ###\n\n# Extract the titles and URLs from the markdown file with sed and put them into arrays\nreadarray -t title_array <<<$(sed -rn 's@^.*\\[(.*)\\]\\((.*)\\).*$@\\1@p' $par_inputfile)\nreadarray -t url_array <<<$(sed -rn 's@^.*\\[(.*)\\]\\((.*)\\).*$@\\2@p' $par_inputfile)\n\n# Get length of array\namount_of_urls=$(echo \"${#url_array[@]}\")\n\necho \"Checking $amount_of_urls URLs\"\n\n# Clear file\n>$par_output\n\n### 3 ###\n\n# Iterate over the array of titles and check each URL\nfor ((n = 0; n < ${#title_array[*]}; n++)); do\n    title=\"${title_array[n]}\"\n    url=\"${url_array[n]}\"\n\n    ### 4 ###\n\n    # If an URL doesn't start with 'http', add the domain before it\n    if [[ $url != http* ]]; then\n        url=\"$par_domain${url_array[n]}\"\n    fi\n\n    echo \"$(($n + 1)): $url\"\n\n    echo -e \"Link name: $title\" >>$par_output\n    echo -e \"URL: $url\" >>$par_output\n\n    ### 5 ###\n\n    # Do a cURL and get the status code from the last response after following any redirects\n    status_code=$(curl -ILs --max-redirs 5 $url | tac | grep -m1 HTTP)\n    expected_code=\"200\"\n\n    # Check if status code obtained via cURL contains the expected code\n    if [[ $status_code == *$expected_code* ]]; then\n        echo \"OK\"\n        echo -e \"Status: OK, can be reached.\" >>$par_output\n    else\n        echo $status_code\n        echo -e \"Status: ERROR! URL cannot be reached. Status code: $status_code\" >>$par_output\n        amount_of_errors=$(($amount_of_errors + 1))\n    fi\n\n    echo -e \"---\" >>$par_output\ndone\n\necho \"\"\necho \"$par_inputfile has been checked and a report named $par_output has been generated.\n$amount_of_errors of $amount_of_urls URLs could not be resolved.\"\n\n\nConfiguration\nTo see where to define your unit tests, open up config.vsh.yaml file and take a look at the end of the functionality dictionary, between the path: script.sh and platforms: lines:\n  test_resources:\n  - type: bash_script\n    path: test.sh\n  - path: Testfile.md\nThe test_resources dictionary contains a reference to a test script and all of the files that need to be copied over in order to complete a test:\n\nThe type signifies what scripting language is used for performing the unit test, which doesn’t need to be the same language as the main script. The path points to the test script.\nEvery file path added straight into the tests dictionary will be copied over next to the temporary test directory. Any files that are necessary for the test to work correctly can be added here.\n\nIn the case of this example, test.sh will be the test script and Testfile.md is necessary as an input markdown file for the script to function.\n\n\nTest script\nTo write the test itself, create a new file named test.sh in the testing folder and add this as its content:\nset -ex # Exit the script when one of the checks fail. Output all commands.\n\n# Check 1\necho \">>> Checking whether output is correct\"\n\n# Run md_url_checker component with its required inputs and output the results to test-output.txt\n\"./$meta_functionality_name\" --inputfile Testfile.md > test-output.txt\n\n[[ ! -f test-output.txt ]] && echo \"Test output file could not be found!\" && exit 1 # Check if test-output.txt exists\ngrep -q '1: https://www.google.com' test-output.txt # Did the script find the URL?\ngrep -q 'HTTP/2 404' test-output.txt  # Did the web request return a 404 for the page that doesn't exist?\n\n# Check 2\necho \">>> Checking whether an output file was created correctly\"\n\n[[ ! -f output.txt ]] && echo \"Output file could not be found!\" && exit 1 # Check if output.txt exists\ngrep -q 'URL: https://www.google.com' output.txt # Was the URL written correctly in the report?\ngrep -q 'Status: ERROR! URL cannot be reached. Status code: HTTP/2 404' output.txt # Was the error written correctly in the report?\ngrep -q 'Link name: install viash here' output.txt # Was link name written correctly in the report?\n\necho \">>> Test finished successfully!\"\nexit 0 # Exit with a 0 code to note a success \n\n\n\n\n\n\nTip\n\n\n\nAs you can see above, you can use the meta variable $meta_functionality_name to automatically get the name of the component (and the generated executable). This way, you can more reuse parts of your test scripts.\n\n\n\n\n\n\n\n\nTip\n\n\n\nThis script uses grep to search for files and strings. Make sure to read the comments to understand what is happening.\n\n\nThe bash script above is just a minimal example of how you can write a test. You can use any of the supported languages and your favorite testing framework if that’s your preference. The most important part is the last line, which uses a 0 exit code to signal a success.\n\n\nRunning a test\nTo run all tests defined in a config file, use the viash test command:\nviash test config.vsh.yaml\nViash will now automatically build an executable and place it alongside the other defined resources in a temporary working directory. The output should look like this:\nRunning tests in temporary directory: '/tmp/viash_test_md_url_checker5828773777380597444'\n====================================================================\n+/tmp/viash_test_md_url_checker5828773777380597444/build_executable/md_url_checker ---setup\n====================================================================\n+/tmp/viash_test_md_url_checker5828773777380597444/test_test.sh/test.sh\n>>> Checking whether output is correct\n+ echo '>>> Checking whether output is correct'\n+ ./md_url_checker --inputfile Testfile.md\n+ [[ ! -f test-output.txt ]]\n+ grep -q '1: https://www.google.com' test-output.txt\n+ grep -q 'HTTP/2 404' test-output.txt\n>>> Checking whether an output file was created correctly\n+ echo '>>> Checking whether an output file was created correctly'\n+ [[ ! -f output.txt ]]\n+ grep -q 'URL: https://www.google.com' output.txt\n+ grep -q 'Status: ERROR! URL cannot be reached. Status code: HTTP/2 404' output.txt\n+ grep -q 'Link name: install viash here' output.txt\n+ echo '>>> Test finished successfully!'\n>>> Test finished successfully!\n+ exit 0\n====================================================================\n[32mSUCCESS! All 1 out of 1 test scripts succeeded![0m\nCleaning up temporary directory\nIf the test succeeds, Viash writes the full output to the shell and deletes the temporary files. If there are any issues, the script stops and an error message will appear in red. In this case, you can inspect the temporary files to troubleshoot.\n\n\n\n\n\n\nTip\n\n\n\nYou can pass the --keep true argument to viash test to prevent viash from automatically deleting the temporary files in case of a success: viash test --keep true config.vsh.yaml."
  },
  {
    "objectID": "guide/component/namespaces.html",
    "href": "guide/component/namespaces.html",
    "title": "Namespaces",
    "section": "",
    "text": "A namespace is a group of Viash components.\nHere are some benefits of grouping your components:\n\nGrouping components in namespaces allows for categorizing components.\nEach teams of developers can work on a different set of components in parallel, which improves the separation of concerns.\nGenerating build targets and unit testing can be done in bulk, with optional filtering by namespace using the viash ns commands.\n\nThis guide will cover how to define a namespace and use it with Viash."
  },
  {
    "objectID": "guide/component/namespaces.html#adding-components-to-a-namespace",
    "href": "guide/component/namespaces.html#adding-components-to-a-namespace",
    "title": "Namespaces",
    "section": "Adding components to a namespace",
    "text": "Adding components to a namespace\nThere are two ways of defining a namespace: either by adding the namespace property to the Viash config file or by creating a directory structure. You can use one or both of these methods in your projects.\n\nNamespace property\nYou can assign a component to a namespace by defining its namespace attribute in the viash config file:\nfunctionality:\n  name: some_component\n  namespace: my_namespace\n\n\nDirectory structure\nViash can deduce namespaces automatically if you structure the components hierarchically. The namespace directories should be in the root of your (source) directory, with the component directories inside, grouped per namespace.\nIn the example below, there are two namespaces: namespace_one and namespace_two, each of these namespaces has one or more components assigned to them:\nsrc\n├── namespace_one\n│   ├── component_one\n│   │   ├── config.vsh.yaml\n│   │   └── script.sh\n│   └── component_two\n│       ├── config.vsh.yaml\n│       └── script.sh\n└── namespace_two\n    └── component_three\n        ├── config.vsh.yaml\n        └── script.sh\nHere, namespace_one groups component_one and component_two together while namespace_two only consists of a single component, component_three."
  },
  {
    "objectID": "guide/component/namespaces.html#using-the-viash-ns-subcommands",
    "href": "guide/component/namespaces.html#using-the-viash-ns-subcommands",
    "title": "Namespaces",
    "section": "Using the viash ns subcommands",
    "text": "Using the viash ns subcommands\nViash comes with a useful viash ns command to work with namespaces. This can be used to inspect, test and build the components that are part of a namespace.\nWe’ve provided a simple example project if you wish to test these commands. Its components use bash for some integer and string manipulation.\nDownload namespace_example.zip\n\nListing components and namespaces\nThe viash ns list command is the namespace equivalent of viash config view, it outputs a parsed version of all config files found in a directory and their subdirectories:\nviash ns list -src src\nThis prints all fields to the terminal, even those not defined in the config files themselves. Here’s a part of the output:\n\n\nOutput\n\n- functionality:\n    name: \"replace\"\n    namespace: \"string_manipulation\"\n    authors: []\n    inputs: []\n    outputs: []\n    arguments:\n    - type: \"string\"\n      name: \"--text\"\n      alternatives: []\n      example: []\n      default:\n      - \"Hello world!\"\n      required: false\n      values: []\n      direction: \"input\"\n      multiple: false\n      multiple_sep: \":\"\n    - type: \"string\"\n      name: \"--search\"\n      alternatives: []\n      example: []\n      default:\n      - \"Hello\"\n      required: false\n      values: []\n      direction: \"input\"\n      multiple: false\n      multiple_sep: \":\"\n    - type: \"string\"\n      name: \"--replace\"\n      alternatives: []\n      example: []\n      default:\n      - \"Greetings\"\n      required: false\n      values: []\n      direction: \"input\"\n      multiple: false\n      multiple_sep: \":\"\n    resources:\n    - type: \"bash_script\"\n      path: \"script.sh\"\n      is_executable: true\n      parent: \"file:/.namespace_example/src/string_manipulation/replace/config.vsh.yaml\"\n    description: \"Search for a substring in a string and replace it with another string\"\n    test_resources:\n    - type: \"bash_script\"\n      path: \"test.sh\"\n      is_executable: true\n      parent: \"file:/.namespace_example/src/string_manipulation/replace/config.vsh.yaml\"\n    info: {}\n    dummy_arguments: []\n    set_wd_to_resources_dir: false\n  platform:\n    type: \"native\"\n    id: \"native\"\n  platforms:\n  - type: \"native\"\n    id: \"native\"\n  info:\n    config: \"namespace_example/src/string_manipulation/replace/config.vsh.yaml\"\n    platform: \"native\"\n    viash_version: \"0.5.12\"\n    git_commit: \"d9d624de0264b1154d7eeb5dba3c1deb567311ac\"\n    git_remote: \"https://github.com/...\"\n...\n\n\n\nUnit testing a namespace\nYou can test multiple components using the viash ns test command.\nviash ns test --src src\n\n\n\n\n\n\nTip\n\n\n\nTo speed up the testing, you can use the parallel flag to test all components at once:\nviash ns test --src src --parallel\n\n\nThis will test each component in series and will output a tab separated output that contains the results:\nThe working directory for the namespace tests is /tmp/viash_ns_test2526740097581645786\n           namespace        functionality             platform            test_name exit_code duration               result\n string_manipulation              replace               native                start                                        \n string_manipulation              replace               native              test.sh         0        0              SUCCESS\n                math             subtract               native                start                                        \n                math             subtract               native              test.sh         0        0              SUCCESS\n                math                  add               native                start                                        \n                math                  add               native              test.sh         0        0              SUCCESS\n\n\nBuilding a namespace\nMultiple components can be build in series using the viash ns build command:\nviash ns build --src src --target target\n\n\n\n\n\n\nTip\n\n\n\nTo speed up the building, you can use the parallel flag to build all components at once:\nviash ns build --src src --target target --parallel\n\n\nThis will output the following to the console:\nExporting replace (string_manipulation) =native=> target/native/string_manipulation/replace\nExporting subtract (math) =native=> target/native/math/subtract\nExporting add (math) =native=> target/native/math/add\nAn executable and/or module will be generated for every target platform defined in each of the component configs. These are grouped per platform and namespace in the target directory:\ntarget\n└── native\n    ├── math\n    │   ├── add\n    │   │   └── add\n    │   └── subtract\n    │       └── subtract\n    └── string_manipulation\n        └── replace\n            └── replace"
  },
  {
    "objectID": "guide/component/creation/nextflow.html",
    "href": "guide/component/creation/nextflow.html",
    "title": "Nextflow",
    "section": "",
    "text": "When targeting the Nextflow platform, a module is generated that can be run standalone or used in a pipeline."
  },
  {
    "objectID": "guide/component/creation/nextflow.html#requirements",
    "href": "guide/component/creation/nextflow.html#requirements",
    "title": "Nextflow",
    "section": "Requirements",
    "text": "Requirements\nThis example targets the Nextflow platform, which requires you to install Nextflow and Docker. Follow the instructions on NextFlow’s homepage to install it on your system if you haven’t done so already. You can find instructions on how to install Docker for your OS on the Viash installation page."
  },
  {
    "objectID": "guide/component/creation/nextflow.html#preparing-a-component-for-nextflow",
    "href": "guide/component/creation/nextflow.html#preparing-a-component-for-nextflow",
    "title": "Nextflow",
    "section": "Preparing a component for Nextflow",
    "text": "Preparing a component for Nextflow\nUnlike components that target the native and Docker platform, a component targeting Nextflow requires you to keep some things in mind besides editing your config file.\n\nCreating the component\nThis guide builds upon the hello_world component from the Docker component creation guide. You can either follow with that guide first or simply download the component below that contains the component in all supported languages. Simply rename the language folder you want to use to hello_world and use that as your working directory.\nDownload hello_world_docker.zip\nCreate a new folder named src and drag the component files inside of that, this is to keep your source and target files neatly separated. Your directory structure should look like this now:\nhello world\n└── src\n    └── config.vsh.yaml\n    └── script"
  },
  {
    "objectID": "guide/component/creation/nextflow.html#adapting-the-script",
    "href": "guide/component/creation/nextflow.html#adapting-the-script",
    "title": "Nextflow",
    "section": "Adapting the script",
    "text": "Adapting the script\nComponents that target the Nextflow platform don’t support writing to standard output when run in a pipeline. Instead, their output should be redirected to a file. To do that, change the contents of your script file as below:\n\nBashC#JavaScriptPythonScalaR\n\n\nChange this:\necho \"Hello $par_input\"\nTo this:\necho \"Hello $par_input\" > $par_output\n\n\nChange this:\nConsole.WriteLine(\"Hello \" + par.input);\nTo this:\nFile.WriteAllText(par.output, \"Hello \" + par.input);\n\n\nChange this:\nconsole.log('Hello' + par['input']);\nTo this:\nconst fs = require('fs');\nfs.writeFileSync(par['output'], 'Hello ' + par['input']);\n\n\nChange this:\nprint(\"Hello\", par[\"input\"])\nTo this:\nfile = open(par[\"output\"], 'a+')\nfile.write(\"Hello \" + par[\"input\"])\nfile.close()\n\n\nChange this:\nprintln(\"Hello \" + par.input.get)\nTo this:\nimport java.io._\n\nval writer = new FileWriter(par.output.get)\ntry { writer.append(\"Hello \" + par.input.get) }\nfinally { writer.close }        \n\n\nChange this:\ncat(\"Hello \", par$input)\nTo this:\ncat(\"Hello\", par$input, file=par$output, sep=\" \", append=TRUE)"
  },
  {
    "objectID": "guide/component/creation/nextflow.html#adjusting-the-config",
    "href": "guide/component/creation/nextflow.html#adjusting-the-config",
    "title": "Nextflow",
    "section": "Adjusting the config",
    "text": "Adjusting the config\n\nAdd --id argument\nNextflow modules need an --id argument in order to work, so add that to the config file below the --input argument:\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  - type: string\n    name: --id\n    default: \"hello_world\"\n...\n\n\nAdd a file output argument\nNow that the script outputs a file, its output path should be added as an argument to the config file. To do that, add yet another argument below the --id argument named --output:\n- type: file\n  name: --output\n  default: \"output\"\n\n\nAdd Nextflow platform\nTo add support for the Nextflow platform as a build target, you need to add nextflow to the platforms section of your Viash config file. To do this, add these lines to the bottom of your config file:\n- type: nextflow\n  variant: vdsl3\nThis will add Nextflow as a build target, with VDSL3 set as the pipeline scripting variant, which adds new features and quality of life changes.\n\n\n\n\n\n\nSpecifying the Docker image\n\n\n\n\n\nBy default, Nextflow will use the Docker image specified in the docker platform section. For example:\nplatforms:\n  - type: docker\n    image: bash:4.0\nIf you don’t add docker as a build target or want to override the image, you can use the directives dictionary to specify a base image to use:\nplatforms:\n  - type: nextflow\n    variant: vdsl3\n    directives:\n      container: ubuntu:20.04\n\n\n\n\nBashC#JavaScriptPythonScalaR\n\n\nHere’s the full config after making these changes:\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  - type: string\n    name: --id\n    default: \"hello_world\"\n  - type: file\n    name: --output\n    direction: output\n    default: \"output\"\n  resources:\n  - type: bash_script\n    path: script.sh\nplatforms:\n  - type: native\n  - type: docker\n    image: bash:4.0\n  - type: nextflow\n    variant: vdsl3\n\n\nHere’s the full config after making these changes:\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  - type: string\n    name: --id\n    default: \"hello_world\"\n  - type: file\n    name: --output\n    direction: output\n    default: \"output\"\n  resources:\n  - type: csharp_script\n    path: script.csx\nplatforms:\n  - type: native\n  - type: docker\n    image: \"dataintuitive/dotnet-script:1.2.1\"\n    setup:\n      - type: apk\n        packages: [ bash ]\n  - type: nextflow\n    variant: vdsl3\n\n\nHere’s the full config after making these changes:\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  - type: string\n    name: --id\n    default: \"hello_world\"\n  - type: file\n    name: --output\n    direction: output\n    default: \"output\"\n  resources:\n  - type: javascript_script\n    path: script.js\nplatforms:\n  - type: native\n  - type: docker\n    image: node:15-buster\n  - type: nextflow\n    variant: vdsl3\n\n\nHere’s the full config after making these changes:\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  - type: string\n    name: --id\n    default: \"hello_world\"\n  - type: file\n    name: --output\n    direction: output\n    default: \"output\"\n  resources:\n  - type: python_script\n    path: script.py\nplatforms:\n  - type: native\n  - type: docker\n    image: \"python:3.8\"\n  - type: nextflow\n    variant: vdsl3\n\n\nHere’s the full config after making these changes:\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  - type: string\n    name: --id\n    default: \"hello_world\"\n  - type: file\n    name: --output\n    direction: output\n    default: \"output\"\n  resources:\n  - type: scala_script\n    path: script.scala\nplatforms:\n  - type: native\n  - type: docker\n    image: hseeberger/scala-sbt\n  - type: nextflow\n    variant: vdsl3\n\n\nHere’s the full config after making these changes:\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  - type: string\n    name: --id\n    default: \"hello_world\"\n  - type: file\n    name: --output\n    direction: output\n    default: \"output\"\n  resources:\n  - type: r_script\n    path: script.R\nplatforms:\n  - type: native\n  - type: docker\n    image: \"rocker/tidyverse:4.0.4\"\n  - type: nextflow\n    variant: vdsl3"
  },
  {
    "objectID": "guide/component/creation/nextflow.html#running",
    "href": "guide/component/creation/nextflow.html#running",
    "title": "Nextflow",
    "section": "Running",
    "text": "Running\nIn contrast to native and Docker based components, a Nextflow based component cannot be ran by using the viash run command. Components targeting Nextflow require you to use viash build first to generate a Nextflow module and run that module using nextflow run. See the Nextflow Build Target page for more information on how to generate a Nextflow module and run it as a standalone pipeline."
  },
  {
    "objectID": "guide/component/creation/docker.html",
    "href": "guide/component/creation/docker.html",
    "title": "Docker",
    "section": "",
    "text": "Viash can generate a Docker image and final container for you based on a component. This guide explains how to adapt a component that targets the native platform to work with a Docker backend."
  },
  {
    "objectID": "guide/component/creation/docker.html#requirements",
    "href": "guide/component/creation/docker.html#requirements",
    "title": "Docker",
    "section": "Requirements",
    "text": "Requirements\nAs this example targets the Docker platform, the only requirement is to have Docker installed on your system. This is one of the biggest benefits of targeting the Docker platform. You can find instructions on how to install Docker for your OS on the Viash installation page."
  },
  {
    "objectID": "guide/component/creation/docker.html#preparing-a-component-for-docker",
    "href": "guide/component/creation/docker.html#preparing-a-component-for-docker",
    "title": "Docker",
    "section": "Preparing a component for Docker",
    "text": "Preparing a component for Docker\n\nCreating a component\nFor this example, you’ll use the same hello_world component the native component creation guide uses. You can either follow with that guide first or simply download the component below that contains the component in all supported languages. Simply rename the language folder you want to use to hello_world and use that as your working directory.\nDownload hello_world.zip\n\n\nAdjusting the config\nAll you need to do to add the Docker platform as a build target is adding docker to the platforms list in your Viash config file. The docker platform has an image property that points to a Docker image from Docker Hub to use as a base.\nDepending on the scripting language you’re using, a setup section might be included that will install additional packages in the final image.\n\nBashC#JavaScriptPythonScalaR\n\n\nAdd this snippet to the bottom of your config file to add Docker as a build target and add a bash base image:\n- type: docker\n  image: bash:4.0\nHere’s the full config after making this change:\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: bash_script\n    path: script.sh\nplatforms:\n  - type: native\n  - type: docker\n    image: bash:4.0\n\n\nAdd this snippet to the bottom of your config file to add Docker as a build target and our dotnet-script base image:\n- type: docker\n  image: \"dataintuitive/dotnet-script:1.2.1\"\n  setup:\n    - type: apk\n      packages: [ bash ]\nHere’s the full config after making this change:\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: csharp_script\n    path: script.csx\nplatforms:\n  - type: native\n  - type: docker\n    image: \"dataintuitive/dotnet-script:1.2.1\"\n    setup:\n      - type: apk\n        packages: [ bash ]\n\n\nAdd this snippet to the bottom of your config file to add Docker as a build target and a Node.js base image:\n- type: docker\n  image: node:15-buster\nHere’s the full config after making this change:\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: javascript_script\n    path: script.js\nplatforms:\n  - type: native\n  - type: docker\n    image: node:15-buster\n\n\nAdd this snippet to the bottom of your config file to add Docker as a build target and a Python base image:\n- type: docker\n  image: \"python:3.8\"\nHere’s the full config after making this change:\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: python_script\n    path: script.py\nplatforms:\n  - type: native\n  - type: docker\n    image: \"python:3.8\"\n\n\nAdd this snippet to the bottom of your config file to add Docker as a build target and a base image containing Scala and sbt:\n- type: docker\n  image: hseeberger/scala-sbt\nHere’s the full config after making this change:\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: scala_script\n    path: script.scala\nplatforms:\n  - type: native\n  - type: docker\n    image: hseeberger/scala-sbt\n\n\nAdd this snippet to the bottom of your config file to add Docker as a build target and a base image containing R, rstudio and R packages:\n- type: docker\n  image: \"rocker/tidyverse:4.0.4\"\nHere’s the full config after making this change:\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: r_script\n    path: script.R\nplatforms:\n  - type: native\n  - type: docker\n    image: \"rocker/tidyverse:4.0.4\"\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nWhen building your own components that only target Docker or Nextflow, adding the native target platform isn’t necessary."
  },
  {
    "objectID": "guide/component/creation/docker.html#running",
    "href": "guide/component/creation/docker.html#running",
    "title": "Docker",
    "section": "Running",
    "text": "Running\nYou can now call upon Viash to generate a temporary executable and run it:\nviash run config.vsh.yaml --platform docker\nThe --platform argument is passed to viash run so Docker will be chosen as the build target. If the platform isn’t specified, the first one in the platforms list is picked.\nThis results in the following output:\n[notice] Checking if Docker image is available at 'hello_world:latest'\n[warning] Could not pull from 'hello_world:latest'. Docker image doesn't exist or is not accessible.\n[notice] Building container 'hello_world:latest' with Dockerfile\nHello World\nAs you can see, Viash checks first if an image has been generated before continuing. If the image already exists, Viash will run a contained based on the image.\nIn this case though, no image was found for this component, so Viash generates the image before building and running the container."
  },
  {
    "objectID": "guide/component/creation/docker.html#whats-next",
    "href": "guide/component/creation/docker.html#whats-next",
    "title": "Docker",
    "section": "What’s next?",
    "text": "What’s next?\nTo learn how to use Viash to build an executable with a Docker backend and run it, see Building and Running."
  },
  {
    "objectID": "guide/component/creation/native.html",
    "href": "guide/component/creation/native.html",
    "title": "Native",
    "section": "",
    "text": "A Viash component can target one or more platforms. When targeting the native platform, a single executable is generated."
  },
  {
    "objectID": "guide/component/creation/native.html#requirements",
    "href": "guide/component/creation/native.html#requirements",
    "title": "Native",
    "section": "Requirements",
    "text": "Requirements\nThe example targets the Native platform, which means you will need to have the required packages installed on your system depending on your chosen scripting language. Take a look at the Scripting Languages page to learn more about a specific language.\n\n\n\n\n\n\nTip\n\n\n\nIf you want to get started quickly, use Bash as that doesn’t have any external dependencies."
  },
  {
    "objectID": "guide/component/creation/native.html#creating-the-viash-component",
    "href": "guide/component/creation/native.html#creating-the-viash-component",
    "title": "Native",
    "section": "Creating the Viash component",
    "text": "Creating the Viash component\n\nWriting the script\nFor this example, you’ll use a tiny script that simply outputs “Hello World”, with the “World” part being a variable. To start off, create a folder named hello_world and follow the instructions below based on your preferred scripting language.\n\nBashC#JavaScriptPythonScalaR\n\n\nCreate a new file named script.sh and copy the following content inside of it:\necho \"Hello $par_input\"\n\n\nCreate a new file named script.csx and copy the following content inside of it:\nConsole.WriteLine(\"Hello \" + par.input);\n\n\nCreate a new file named script.js and copy the following content inside of it:\nconsole.log('Hello' + par['input']);\n\n\nCreate a new file named script.py and copy the following content inside of it:\nprint(\"Hello\", par[\"input\"])\n\n\nCreate a new file named script.scala and copy the following content inside of it:\nprintln(\"Hello \" + par.input.get)\n\n\nCreate a new file named script.R and copy the following content inside of it:\ncat(\"Hello \", par$input)\n\n\n\nThis outputs Hello to the console, followed by an input variable. Notice that this variable isn’t defined in the script itself as Viash will generate it for you based on the config file you’ll create in the next step.\n\n\n\n\n\n\nTip\n\n\n\nEvery scripting language has its own way of using variables generated by Viash. Check out the Scripting Languages for more information and examples.\n\n\n\n\nAdding the config\nA Viash config file is a YAML file that describes the functionality of a component and the platform(s) it targets. Create a file name config.vsh.yaml and add the contents below based on your chosen scripting language.\n\nBashC#JavaScriptPythonScalaR\n\n\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: bash_script\n    path: script.sh\nplatforms:\n  - type: native\n\n\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: csharp_script\n    path: script.csx\nplatforms:\n  - type: native\n\n\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: javascript_script\n    path: script.js\nplatforms:\n  - type: native\n\n\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: python_script\n    path: script.py\nplatforms:\n  - type: native\n\n\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: scala_script\n    path: script.scala\nplatforms:\n  - type: native\n\n\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: r_script\n    path: script.R\nplatforms:\n  - type: native\n\n\n\nHere’s a breakdown of the different sections:\n\nfunctionality describes what the component does and the resources it needs. It contains the name, a short description and more importantly, the arguments and resources the component uses.\n\narguments contains all arguments the component accepts and will be passed to the script. In this case, a single string named --input resides here with a default value of World.\nresources holds references to all necessary files and folders to make the component work. For this example, a single script is all that’s needed.\n\nplatforms lists what platforms the component can target. This example targets the native platform, which will generate an executable that’s run using the system resources."
  },
  {
    "objectID": "guide/component/creation/native.html#running",
    "href": "guide/component/creation/native.html#running",
    "title": "Native",
    "section": "Running",
    "text": "Running\nWith the two necessary files present to create a component, you can call upon Viash to generate a temporary executable and run it:\nviash run config.vsh.yaml\nWithout passing any arguments, this will use the default value for --input, which is World. This results in the following output:\nHello World\nBy providing the a value for --input, you can customize the greeting:\nviash run config.vsh.yaml -- --input Earth\n\n\n\n\n\n\nNote\n\n\n\nThe double dash (--) between the viash command and the arguments is used to signify the end of the arguments passed to viash and the start of those passed to the component. If you forgot to add these, you’ll get an error similar to this:\n[scallop] Error: Unknown option 'input'\n\n\nThe example above results in this output:\nHello Earth"
  },
  {
    "objectID": "guide/component/creation/native.html#whats-next",
    "href": "guide/component/creation/native.html#whats-next",
    "title": "Native",
    "section": "What’s next?",
    "text": "What’s next?\nTo learn how to use Viash to build an executable and run it, see the Native Executable Build Target page."
  },
  {
    "objectID": "guide/component/languages.html",
    "href": "guide/component/languages.html",
    "title": "Scripting Languages",
    "section": "",
    "text": "Viash supports several languages to use in your components. This guide explains how to reference scripts in your Viash config files and how to use Viash specific variables."
  },
  {
    "objectID": "guide/component/languages.html#requirements",
    "href": "guide/component/languages.html#requirements",
    "title": "Scripting Languages",
    "section": "Requirements",
    "text": "Requirements\n\n\n\n\n\n\nNote\n\n\n\nIf you’re using WSL2, make sure to follow the Linux instructions and execute the commands in a WSL2 terminal.\n\n\n\nBashC#JavaScriptPythonRScala\n\n\nBash doesn’t have any dependencies and is included in every modern Linux distro, including those provided for WSL2 on Microsoft’s Store app. On macOS, the default shell is Zsh since 2019, but it still comes packaged with an older Bash 3.2.\n\n\nTo get started with C# scripting, you need to download and install the .NET 6.0 SDK.\nAfter installing the SDK, run this command to install the dotnet-script tool:\ndotnet tool install -g dotnet-script\nTo verify that dotnet-script was installed successfully, run this command to get a list of installed tools:\ndotnet tool list -g\nThe output should look something like this:\nPackage Id         Version      Commands     \n---------------------------------------------\ndotnet-script      1.3.1        dotnet-script\n\n\nTo run JavaScript on your system, you’ll need to download and install Node.js from their homepage.\n\n\nTo run Python scripts on your system, download and install Python. Most package managers include a python package as well. Make sure to install a version of Python that’s at least version 3.8 or newer.\n\n\nTo be able to run R scripts, you’ll need download and install R for your OS.\n\n\nRunning Scala scripts requires you to download and install Scala."
  },
  {
    "objectID": "guide/component/languages.html#referencing-scripts-in-a-viash-config-file",
    "href": "guide/component/languages.html#referencing-scripts-in-a-viash-config-file",
    "title": "Scripting Languages",
    "section": "Referencing scripts in a Viash config file",
    "text": "Referencing scripts in a Viash config file\n\nBashC#JavaScriptPythonRScala\n\n\nWhen referencing a Bash script in the resources of the functionality section your Viash config, use bash_script as its type:\nfunctionality:\n  name: my_component\n  resources:\n  - type: bash_script\n    path: script.sh\n\n\nWhen referencing a C# script in the resources of the functionality section your Viash config, use csharp_script as its type:\nfunctionality:\n  name: my_component\n  resources:\n  - type: csharp_script\n    path: script.csx\n\n\nWhen referencing a JavaScript script in the resources of the functionality section your Viash config, use javascript_script as its type:\nfunctionality:\n  name: my_component\n  resources:\n  - type: javascript_script\n    path: script.js\n\n\nWhen referencing a Python script in the resources of the functionality section your Viash config, use python_script as its type:\nfunctionality:\n  name: my_component\n  resources:\n  - type: python_script\n    path: script.py\n\n\nWhen referencing a R script in the resources of the functionality section your Viash config, use r_script as its type:\nfunctionality:\n  name: my_component\n  resources:\n  - type: r_script\n    path: script.r\n\n\nWhen referencing a Scala script in the resources of the functionality section your Viash config, use scala_script as its type:\nfunctionality:\n  name: my_component\n  resources:\n  - type: scala_script\n    path: script.scala"
  },
  {
    "objectID": "guide/component/languages.html#executing-scripts",
    "href": "guide/component/languages.html#executing-scripts",
    "title": "Scripting Languages",
    "section": "Executing scripts",
    "text": "Executing scripts\n\nBashC#JavaScriptPythonRScala\n\n\nBash scripts end with the .sh extension. They can be run locally by using the bash command:\nbash script.sh\n\n\nC# scripts end with the .csx extension. They can be run locally by using the dotnet script command:\ndotnet script script.csx\n\n\nJavaScript scripts end with the .js extension. They can be run locally by using the node command:\nnode script.js\n\n\nPython scripts end with the .py extension. They can be run locally by using the python command:\npython script.py\n\n\nR scripts end with the .r extension. They can be run locally by using the Rscript command:\nRscript script.r\n\n\nScala scripts end with the .scala extension. They can be run locally by using the scala -nc command:\nscala -nc script.scala"
  },
  {
    "objectID": "guide/component/languages.html#script-examples",
    "href": "guide/component/languages.html#script-examples",
    "title": "Scripting Languages",
    "section": "Script examples",
    "text": "Script examples\nThese examples will briefly show to start scripting with Viash in mind. Each example shows the source code and the output after running it.\n\nUsing variables\n\nBashC#JavaScriptPythonRScala\n\n\n#!/bin/bash\n\nhello=\"Hello World!\"\necho $hello\n\n\n#!/usr/bin/env dotnet-script\n\nstring hello = \"Hello World!\";\nConsole.WriteLine(hello);\n\n\n#!/usr/bin/env node\n\nlet hello = 'Hello World!'\nconsole.log(hello)\n\n\n#!/usr/bin/env python3\n\nhello = \"Hello World!\"\nprint(hello)\n\n\n#!/usr/bin/env Rscript\n\nhello = \"Hello World!\"\ncat(hello)\nRscript script.r\n\n\n#!/usr/bin/env scala\n\nval hello = \"Hello World!\";\nprintln(hello)\n\n\n\nOutput\nHello World!\n\n\nUsing Viash arguments as variables\nViash generates variables based on the arguments defined in the Viash config file and injects them at the top of your script.\n\nBashC#JavaScriptPythonRScala\n\n\nVariables start with $par_, followed by the name of the argument.\nconfig.vsh.yaml\nfunctionality:\n  name: hello_world\n  arguments:\n  - type: string\n    name: --hello\n    default: \"Hello World!\"\n  resources:\n  - type: bash_script\n    path: ViashVariables.sh\nViashVariables.sh\n#!/bin/bash\n\necho $par_hello\n\n\nVariables are grouped inside an anonymous par class and can be referenced by name.\nconfig.vsh.yaml\nfunctionality:\n  name: hello_world\n  arguments:\n  - type: string\n    name: --hello\n    default: \"Hello World!\"\n  resources:\n  - type: csharp_script\n    path: ViashVariables.csx\nViashVariables.csx\n#!/usr/bin/env dotnet-script\n\nConsole.WriteLine(par.hello);\n\n\nVariables are grouped inside a dictionary named par and can be referenced by name.\nconfig.vsh.yaml\nfunctionality:\n  name: hello_world\n  arguments:\n  - type: string\n    name: --hello\n    default: \"Hello World!\"\n  resources:\n  - type: javascript_script\n    path: ViashVariables.js\nViashVariables.js\n#!/usr/bin/env node\n\nconsole.log(par['hello'])\n\n\nVariables are grouped inside a dictionary named par and can be referenced by name.\nconfig.vsh.yaml\nfunctionality:\n  name: hello_world\n  arguments:\n  - type: string\n    name: --hello\n    default: \"Hello World!\"\n  resources:\n  - type: python_script\n    path: ViashVariables.py\nViashVariables.py\n#!/usr/bin/env python3\n\nprint(par[\"hello\"])\n\n\nVariables are grouped inside a list named par and can be referenced by name.\nconfig.vsh.yaml\nfunctionality:\n  name: hello_world\n  arguments:\n  - type: string\n    name: --hello\n    default: \"Hello World!\"\n  resources:\n  - type: r_script\n    path: ViashVariables.r\nViashVariables.r\n#!/usr/bin/env Rscript\n\ncat(par$hello)\n\n\nVariables are grouped inside an instance of a class named par and can be referenced by name.\nconfig.vsh.yaml\nfunctionality:\n  name: hello_world\n  arguments:\n  - type: string\n    name: --hello\n    default: \"Hello World!\"\n  resources:\n  - type: scala_script\n    path: ViashVariables.scala\nViashVariables.scala\n#!/usr/bin/env scala\n\nprintln(par.hello.get)\n\n\n\n\n\nUsing Viash placeholder variables\nBy adding Viash variables between a VIASH START and a VIASH END comment, you can write your script with Viash in mind while keeping it working for standalone execution.\n\nBashC#JavaScriptPythonRScala\n\n\n#!/bin/bash\n\n## VIASH START\npar_hello=\"Hello World!\"\n## VIASH END\n\necho $par_hello\n\n\n#!/usr/bin/env dotnet-script\n\n// VIASH START\nvar par = new {\n  hello = \"Hello World!\"\n};\n// VIASH END\n\nConsole.WriteLine(par.hello);\n\n\n#!/usr/bin/env node\n\n// VIASH START\nlet par = {\n    'hello': 'Hello World!'\n  }\n// VIASH END\n\nconsole.log(par['hello'])\n\n\n#!/usr/bin/env python3\n\n## VIASH START\npar = {\n  \"hello\": \"Hello World!\"\n}\n## VIASH END\n\nprint(par[\"hello\"])\n\n\n#!/usr/bin/env Rscript\n\n## VIASH START\npar <- list(\n  hello = \"Hello World!\"\n)\n## VIASH END\n\ncat(par$hello)\n\n\n#!/usr/bin/env scala\n\n// VIASH START\ncase class ViashPar(\n  greeter: Option[String]\n)\n\nval par = ViashPar(\n  greeter = Some(\"Hello World!\")\n)\n// VIASH END\n\nprintln(par.hello.get)\n\n\n\nOutput\nHello World!\nAnything between VIASH START and VIASH END will be replaced by the injected variables Viash generates once the script is executed as part of a component. This allows you to easily troubleshoot your script while being compatible with Viash.\n\n\nLanguage specific tips\n\nBashC#JavaScriptPythonRScala\n\n\n\nSourcing other scripts\nWith bash, you can include other bash scripts to share content and functionality by using the source command.\nBy writing two scripts and adding them to the same directory, one can reference the other:\nscript.sh\n#!/bin/bash\n\nsource include_me.sh\necho \"Hello from the main script!\"\ninclude_me.sh\n#!/bin/bash\n\necho \"Hi from the included script!\"\nRunning script.sh results in the following output:\nHi from the included script!\nHello from the main script!\nViash supports the sourcing of scripts by adding them as a resource:\nconfig.vsh.yaml\nfunctionality:\n  name: source_example\n  resources:\n  - type: bash_script\n    path: script.sh\n  - type: bash_script\n    path: include_me.sh\nDoing this will ensure any needed scripts will be included with the build target.\n\n\n\n\nUsing NuGet packages\nWith dotnet-script, you can reference NuGet packages directly from within the script. In the example below, we add a reference to Newtonsoft.Json to convert a dictionary to JSON and output it to the console.\nscript.csx\n#!/usr/bin/env dotnet-script\n#r \"nuget: Newtonsoft.Json, 13.0.1\"\n\nusing Newtonsoft.Json;\n\nDictionary<string, int> downloads = new Dictionary<string, int>\n{\n    { \"v1.0\", 501 },\n    { \"v1.1\", 802 },\n    { \"v2.0\", 2857 }\n};\n\nstring json = JsonConvert.SerializeObject(downloads, Formatting.Indented);\nConsole.WriteLine(json);\nRunning script.csx results in the following output:\n{\n  \"v1.0\": 501,\n  \"v1.1\": 802,\n  \"v2.0\": 2857\n}\n\n\n\nWe don’t have any JavaScript tips yet!\n\n\nWe don’t have any Python tips yet!\n\n\nWe don’t have any R tips yet!\n\n\nWe don’t have any Scala tips yet!"
  },
  {
    "objectID": "guide/component/languages.html#meta-variables",
    "href": "guide/component/languages.html#meta-variables",
    "title": "Scripting Languages",
    "section": "Meta variables",
    "text": "Meta variables\nViash offers hidden variables to use in your scripts that can be used to get meta information about your component.\n\nFunctionality name\nName of the component found in the functionality section of the Viash config:\nfunctionality:\n  name: my_component\n\nBashC#JavaScriptPythonRScala\n\n\necho $meta_functionality_name\n\n\nConsole.WriteLine(meta.functionality_name);\n\n\nconsole.log(meta['functionality_name']);\n\n\nprint(meta[\"functionality_name\"])\n\n\ncat(meta$functionality_name)\n\n\nprintln(meta.functionality_name)\n\n\n\nOutput\nmy_component\n\n\nResources directory\nPath where the resources as defined in the Viash config file are stored.\n\nBashC#JavaScriptPythonRScala\n\n\necho $meta_resources_dir\n\n\nConsole.WriteLine(meta.resources_dir);\n\n\nconsole.log(meta['resources_dir']);\n\n\nprint(meta[\"resources_dir\"])\n\n\ncat(meta$resources_dir)\n\n\nprintln(meta.resources_dir)\n\n\n\nWhen using viash run to create a temporary build target and execute it, this will point to the temporary path where the executable was generated:\n/tmp/viash_my_component9560481446119256265\nAfter building a component using viash build and running the generated executable, it points to the directory where the executable and the other resources reside in:\n/home/user/components/my_component_target_dir\n\n\nTemp directory\nPath to the directory supplied by the host system where you can write temporary files to.\n\nBashC#JavaScriptPythonRScala\n\n\necho $meta_temp_dir\n\n\nConsole.WriteLine(meta.temp_dir);\n\n\nconsole.log(meta['temp_dir']);\n\n\nprint(meta[\"temp_dir\"])\n\n\ncat(meta$temp_dir)\n\n\nprintln(meta.temp_dir)\n\n\n\nOutput\n/tmp"
  },
  {
    "objectID": "quickstart/index.html",
    "href": "quickstart/index.html",
    "title": "Quickstart",
    "section": "",
    "text": "Important\n\n\n\nThis guide assumes you’ve installed Viash, Docker and Nextflow on your system.\nThis tutorial will guide you through using our Viash template project to run a data pipeline."
  },
  {
    "objectID": "quickstart/index.html#what-is-viash",
    "href": "quickstart/index.html#what-is-viash",
    "title": "Quickstart",
    "section": "What is Viash?",
    "text": "What is Viash?\nViash is a script code wrapper for building modular software components that serve as building blocks to develop (Nextflow) data pipelines. All you need is your script and a metadata file to get started.\nHere are a few of Viash’s key features:\n\nYou can use your preferred scripting language per component, and mix and match scripts between multiple components as you please. Supported languages include: Bash, Python, R, Scala, JS and C#.\nA custom Docker container is automatically generated based on your dependencies described in your metadata. No expert Docker knowledge is required.\nViash generates a Nextflow module from your script. No expert Nextflow knowledge is required.\nYou can simply script the nextflow modules to create and run your scalable and reproducible data pipeline.\nYou can test every single module on your local workstation through the built-in development kit."
  },
  {
    "objectID": "quickstart/index.html#quickstart-example-project",
    "href": "quickstart/index.html#quickstart-example-project",
    "title": "Quickstart",
    "section": "Quickstart example project",
    "text": "Quickstart example project\nThis Quickstart will take you from nothing to a scalable and reproducible Nextflow data pipeline. Here’s the flow of the pipeline you’ll be using:\n\n\n\n\ngraph LR\n   A(file?.tsv) --> B[/remove_comments/]\n   B --> C[/take_column/]\n   C --> D[/combine_columns/]\n   D --> E(output)\n\n\n\n\n\n\n\n\nOne or more TSV files are taken as the input and will be processed through a series of modules. At the end, the output is written away to a folder."
  },
  {
    "objectID": "quickstart/index.html#step-1-get-the-template",
    "href": "quickstart/index.html#step-1-get-the-template",
    "title": "Quickstart",
    "section": "Step 1: Get the template",
    "text": "Step 1: Get the template\nTo get up and running fast, we provide a template project for you to use:\n\nUsing git CLIZip download\n\n\nRun the command below to clone the template repository to a new folder named advanced_pipeline:\ngit clone https://github.com/viash-io/viash_project_template advanced_pipeline\n\n\nClick the button below to download a zip file containing the template project. Once downloaded, unzip the file and rename the root directory to advanced_pipeline.\nDownload template"
  },
  {
    "objectID": "quickstart/index.html#step-2-project-overview",
    "href": "quickstart/index.html#step-2-project-overview",
    "title": "Quickstart",
    "section": "Step 2: Project overview",
    "text": "Step 2: Project overview\nOpen the advanced_pipeline project directory if you haven’t done so already. Here’s a quick overview of its contents:\n\nThe bin directory contains a single script to initialize the project, more on that in the next step\nmain.nf and nextflow.config are dummy files required for Nextflow to work correctly\nREADME.md contains extra information on how to use the template\nThe resources_test directory contains two TSV files which will be used to test the example pipeline\nsrc contains three Viash components, each with a config file and a script\nThe workflows directory contains a Nextflow script and config to be able to run the pipeline"
  },
  {
    "objectID": "quickstart/index.html#step-3-use-the-init-script",
    "href": "quickstart/index.html#step-3-use-the-init-script",
    "title": "Quickstart",
    "section": "Step 3: Use the init script",
    "text": "Step 3: Use the init script\nInside of the project is a bin directory containing the init script. This will automatically download Viash and Nextflow to that same directory.\nUse the following command to run the init script inside of the bin directory:\nbin/init\nAfter a short while, the script will finish and the following files will be in the bin directory:\nbin\n├── init\n├── nextflow\n├── viash\n├── viash_build\n├── viash_clean_nxf\n├── viash_gendoc\n├── viash_genrep\n├── viash_install\n├── viash_push\n├── viash_skeleton\n├── viash_tag\n├── viash_test\n└── viash_trafo\nThese are executables needed to build, test and run the pipeline."
  },
  {
    "objectID": "quickstart/index.html#step-4-build-the-viash-components",
    "href": "quickstart/index.html#step-4-build-the-viash-components",
    "title": "Quickstart",
    "section": "Step 4: Build the Viash components",
    "text": "Step 4: Build the Viash components\nWith the tools present, you can build the Docker executables and Nextflow modules using Viash. To do so, make sure Docker is running and use the following command:\nbin/viash_build\nWhile building, this will result in the following output:\nIn development mode with 'dev'.\nExporting remove_comments (demo) =nextflow=> target/nextflow/demo/remove_comments\nExporting combine_columns (demo) =docker=> target/docker/demo/combine_columns\nExporting take_column (demo) =nextflow=> target/nextflow/demo/take_column\nExporting take_column (demo) =docker=> target/docker/demo/take_column\nExporting remove_comments (demo) =docker=> target/docker/demo/remove_comments\nExporting combine_columns (demo) =nextflow=> target/nextflow/demo/combine_columns\n[notice] Building container 'demo_combine_columns:dev' with Dockerfile\n[notice] Building container 'demo_take_column:dev' with Dockerfile\n[notice] Building container 'demo_remove_comments:dev' with Dockerfile\nOnce everything is built, a new target directory has been created containing the executables and modules grouped per platform:\ntarget/\n├── docker\n│   └── demo\n│       ├── combine_columns\n│       │   ├── combine_columns\n│       │   └── viash.yaml\n│       ├── remove_comments\n│       │   ├── remove_comments\n│       │   └── viash.yaml\n│       └── take_column\n│           ├── take_column\n│           └── viash.yaml\n└── nextflow\n    └── demo\n        ├── combine_columns\n        │   ├── main.nf\n        │   ├── nextflow.config\n        │   └── viash.yaml\n        ├── remove_comments\n        │   ├── main.nf\n        │   ├── nextflow.config\n        │   └── viash.yaml\n        └── take_column\n            ├── main.nf\n            ├── nextflow.config\n            └── viash.yaml"
  },
  {
    "objectID": "quickstart/index.html#step-5-run-the-pipeline",
    "href": "quickstart/index.html#step-5-run-the-pipeline",
    "title": "Quickstart",
    "section": "Step 5: Run the pipeline",
    "text": "Step 5: Run the pipeline\nNow run run the pipeline with Nextflow:\nbin/nextflow run . \\\n  -main-script workflows/demo_pipeline/main.nf \\\n  -with-docker \\\n  --input resources_test/file*.tsv \\\n  --publishDir temp\nThis will run the three modules in sequence, with the final result result being stored in a file named combined.combine_columns.output in a new temp directory:\n\"1\"     0.11\n\"2\"     0.23\n\"3\"     0.35\n\"4\"     0.47"
  },
  {
    "objectID": "quickstart/index.html#whats-next",
    "href": "quickstart/index.html#whats-next",
    "title": "Quickstart",
    "section": "What’s next?",
    "text": "What’s next?\nNow that you’ve had a taste of what Viash can do for you, take a look at our Guide and Reference pages to learn more about how to use Viash. If you want to start simple, we suggest to take a look at the Native component creation guide."
  },
  {
    "objectID": "download/components/md_url_checker/bash/Testfile.html",
    "href": "download/components/md_url_checker/bash/Testfile.html",
    "title": "Viash",
    "section": "",
    "text": "Test File\nThis is a simple markdown file with some hyperlinks to test if the component works correctly. Some links to websites:\n\nGoogle\nReddit\nA broken link\n\nLinks that are relative to viash.io:\n\nYou can install viash here.\nIt all starts with a script and a config file."
  },
  {
    "objectID": "privacy.html",
    "href": "privacy.html",
    "title": "Privacy Policy",
    "section": "",
    "text": "TL;DR: We do not use cookies and we do not collect any personal data.\n\nWebsite visitors\n\nNo personal information is collected.\nNo information is stored in the browser.\nNo information is shared with, sent to or sold to third-parties.\nNo information is shared with advertising companies.\nNo information is mined and harvested for personal and behavioral trends.\nNo information is monetized.\n\n\n\nInformation we collect and what we use it for\nWe run Google Analytics analytics on viash.io. The following information is collected:\n\nPage URL. We track the page URL of each page view on this website. We use this to understand which pages have been viewed and how many times a particular page has been viewed. For example: https://viash.io/.\nHTTP Referrer. We use the referrer string to understand the number of visitors referred to this website from links on other sites. For example: https://github.com/.\nBrowser. We use this to understand what browsers people use when visiting this website. This is derived from the User-Agent HTTP header. The full User-Agent is discarded. For example: Chrome.\nOperating system. We use this to understand what operating systems people use when visiting this website. We only use the brand of the operating system and don’t include the version number or any other details. This is derived from the User-Agent HTTP header. The full User-Agent is discarded. For example: GNU/Linux.\nDevice type. We use this to understand what devices people use when visiting this website. This is derived from window.innerWidth. The actual width of the browser in pixels is discarded. For example: Desktop.\nVisitor Country. We look up the visitor’s country using the IP address. We do not track anything more granular than the country of origin and the IP address of the visitor is discarded. We never store IP addresses in our database or logs. For example: Canada.\n\n\n\nContact us\nContact us if you have any questions."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Viash",
    "section": "",
    "text": "Viash is developed and maintained by Data Intuitive.\nYou can find out more information about Viash in our preprint.\nFor more information or support contact us at info@data-intuitive.com."
  },
  {
    "objectID": "about.html#logos",
    "href": "about.html#logos",
    "title": "About Viash",
    "section": "Logos",
    "text": "Logos"
  },
  {
    "objectID": "faq/index.html",
    "href": "faq/index.html",
    "title": "Frequently Asked Questions",
    "section": "",
    "text": "One or more of my output files are owned by root after running a component. Why is this?\nIn Linux, files created by Docker are owned by root by default.\nYou can set up the chown attribute in your config file to automatically transfer the ownership of files to the user running the component. Any file output where an argument of the type file with an output direction was used will also have their ownership transferred.\n\n\nCan I store helper functions as separate files?\nYes, though you’ll need to let Viash know which additional files are required to run the component. For example, if several helper functions are stored in an additional file mymodule.py or mymodule.R, use the following code to import the helper functions:\n\nPython\nIn the resources section of the Viash config file:\nresources:\n  - type: python_script\n    path: script.py\n  - path: mymodule.py\nIn the main Python script:\nimport sys\n\n## VIASH START\nmeta = { 'resources_dir': '.' }\n## VIASH END\n\nsys.path.append(meta['resources_dir'])\nfrom mymodule import helper_fun\n\n\nR\nIn the resources section of the Viash config file:\nresources:\n  - type: r_script\n    path: script.R\n  - path: mymodule.R\nIn the main R script:\n## VIASH START\nmeta <- list(resources_dir = \".\")\n## VIASH END\n\nsource(paste0(meta[[\"resources_dir\"]], \"/mymodule.R\"))\nhelper_fun(...)"
  },
  {
    "objectID": "bin/data/CHANGELOG.html",
    "href": "bin/data/CHANGELOG.html",
    "title": "Viash",
    "section": "",
    "text": "[TODO] A nice summary.\n\n\n\nviash_install: The bootstrap script has been reworked in line with the project config introduced in 0.6.4:\n\nThe default location for installing the Viash executable is now ./viash (was: bin/viash).\nThe new viash_install support --output and --tag.\nThe various settings that existed in viash_install (organisation, tag, …) are moved to the project config.\n\nPlease note that this new viash_install bootstrap script can be run from the CLI using:\ncurl -fsSL dl.viash.io | bash\nThe old get.viash.io is still available but points to the version 0.6.7 version of this component and is deprecated.\n\n\n\n\n\nMain: Capture build, setup and push errors and output an exit code.\nTestbenches: Add testbenches to verify switching of viash versions.\nFile downloading: Add check to preemptively catch file errors (e.g. 404).\nScala: Updated to Scala 2.13 and updated several dependencies.\nTestbenches: Prepare ConfigDeriver by copying base resources to the targetFolder. Use cases so far showed that it’s always required and it simplifies the usage.\nTestbenches: Remove some old & unmaintained IntelliJ Idea editor-fold tags. Given that the testbenches were split up, these were broken but also no longer needed.\nTestbenches: Add 2 testbenches for computational requirements when running viash run or viash test.\nMain: Improve match completeness in some edge cases and throw exceptions where needed.\nChangelog: Reformat the changelog to a more structured format. For every release, there is now a date, title, and summary. This both improves the changelog itself but can then also be used to postprocess the CHANGELOG programmatically.\n\n\n\n\n\nTestbenches: Fix GitTest testbench to correctly increment temporary folder naming and dispose them after the test finishes.\nviash xxx url: Fix passing a url to viash as the config file to process. Add a short testbench to test principle functionality.\nTestbenches: Simplify testr container."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#minor-changes-1",
    "href": "bin/data/CHANGELOG.html#minor-changes-1",
    "title": "Viash",
    "section": "MINOR CHANGES",
    "text": "MINOR CHANGES\n\nNextflowPlatform: Create directories during a stub run when output path is a nested directory (#314).\nAutomatically generate a warning for deprecated parameters while parsing a .viash.yaml configuration file using the inline documentation deprecation annotations.\nAdd a “planned removal” field in the deprecation annotations.\nAdd testbenches to verify proper formatting of the deprecation versions and compare current version to the planned removal version so no deprecated parameters get to stick around beyond what was planned.\nNextflowPlatform: Nextflow processes are created lazily; that is, only when running a Nextflow workflow (#321)."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-1",
    "href": "bin/data/CHANGELOG.html#bug-fixes-1",
    "title": "Viash",
    "section": "BUG FIXES",
    "text": "BUG FIXES\n\nNextflowPlatform: Automatically split Viash config strings into strings of length 65000 since the JVM has a limit (65536) on the length of string constants (#323)."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-2",
    "href": "bin/data/CHANGELOG.html#bug-fixes-2",
    "title": "Viash",
    "section": "BUG FIXES",
    "text": "BUG FIXES\n\nDon’t redirect stderr to stdout when switching Viash versions (#312)."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-3",
    "href": "bin/data/CHANGELOG.html#bug-fixes-3",
    "title": "Viash",
    "section": "BUG FIXES",
    "text": "BUG FIXES\n\nviash ns list: When the -p <platform> is defined, filter the output by that platform."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#breaking-changes-1",
    "href": "bin/data/CHANGELOG.html#breaking-changes-1",
    "title": "Viash",
    "section": "BREAKING CHANGES",
    "text": "BREAKING CHANGES\n\nConfig: Viash configs whose filenames start with a . are ignored (#291).\nviash build: --write_meta/-m and --meta/-m arguments have been removed. Instead, the .config.vsh.yaml file is always created when building Viash components (#293).\nFileArgument: Default setting of must_exist was changed from false to true. As such, the component will throw an error by default if an input file or output file is missing (#295).\nConfig merging: __inherits__ has been renamed to __merge__."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#new-functionality",
    "href": "bin/data/CHANGELOG.html#new-functionality",
    "title": "Viash",
    "section": "NEW FUNCTIONALITY",
    "text": "NEW FUNCTIONALITY\n\nYou can switch versions of Viash using the VIASH_VERSION environment variable (#304)! Example:\nVIASH_VERSION=0.6.0 viash --version\nTraceability: Running viash build and viash test creates a .config.vsh.yaml file by default, which contains the processed config of the component. As a side effect, this allows for reading in the .config.vsh.yaml from within the component to learn more about the component being tested (#291 and #293).\nFileArgument: Added create_parent option, which will check if the directory of an output file exists and create it if necessary (#295)."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#minor-changes-2",
    "href": "bin/data/CHANGELOG.html#minor-changes-2",
    "title": "Viash",
    "section": "MINOR CHANGES",
    "text": "MINOR CHANGES\n\nviash run, viash test: When running or testing a component, Viash will add an extension to the temporary file that is created. Before: /tmp/viash-run-wdckjnce, now: /tmp/viash-run-wdckjnce.py (#302).\nNextflowPlatform: Add DataflowHelper.nf as a retrievable resource in Viash (#301).\nNextflowPlatform: During a stubrun, argument requirements are turned off and the publishDir, cpus, memory, and label directives are also removed from the process (#301).\nNextflowPlatform: Added a filter processing argument to filter the incoming channel after the map, mapData, mapId and mapPassthrough have been applied (#296).\nNextflowPlatform: Added the Viash config to the Nextflow module for later introspection (#296). For example:\ninclude { foo } from \"$targetDir/path/foo/main.nf\"\n\nfoo.run(filter: { tup ->\n  def preferredNormalization = foo.config.functionality.info.preferred_normalization\n  tup.normalization_id == preferredNormalization\n})\nBUG FIXES\nBashWrapper: Don’t overwrite meta values when trailing arguments are provided (#295)."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#experimental-features",
    "href": "bin/data/CHANGELOG.html#experimental-features",
    "title": "Viash",
    "section": "EXPERIMENTAL FEATURES",
    "text": "EXPERIMENTAL FEATURES\n\nViash Project: Viash will automatically search for a _viash.yaml file in the directory of a component and its parent directories (#294).\nContents of _viash.yaml:\nsource: src\ntarget: target\nconfig_mods: |\n  .platforms[.type == 'docker'].target_registry := 'ghcr.io'\n  .platforms[.type == 'docker'].target_organization := 'viash-io'\n  .platforms[.type == 'docker'].namespace_separator := '/'\n  .platforms[.type == 'docker'].target_image_source := 'https://github.com/viash-io/viash'\nConfig merging: Allow specifying the order in which Viash will merge configs (#289). If . is not in the list of inherited objects, it will be added at the end.\nContents of config.vsh.yaml:\nfunctionality:\n  name: foo\n  arguments:\n    - __merge__: obj_input.yaml\n      name: \"--one\"\n    - __merge__: [., obj_input.yaml]\n      name: \"--two\"\n    - __merge__: [obj_input.yaml, .]\n      name: \"--three\"\nContents of obj_input.yaml:\ntype: file\nname: --input\ndescription: A h5ad file\nOutput of viash config view config.vsh.yaml (stripped irrelevant bits):\nfunctionality:\n  arguments:\n  - type: \"file\"\n    name: \"--one\"\n    description: \"A h5ad file\"\n  - type: \"file\"\n    name: \"--input\"\n    description: \"A h5ad file\"\n  - type: \"file\"\n    name: \"--three\"\n    description: \"A h5ad file\""
  },
  {
    "objectID": "bin/data/CHANGELOG.html#major-changes",
    "href": "bin/data/CHANGELOG.html#major-changes",
    "title": "Viash",
    "section": "MAJOR CHANGES",
    "text": "MAJOR CHANGES\n\nConfig: Made major internal changes w.r.t. how config files are read and at which point a platform (native, docker, nextflow) is applied to the functionality script. The only visible side effect is that viash ns list will output each config only once instead of multiple times.\nFunctionality: Structured annotation can be added to a functionality and its arguments using the info field. Example:\nfunctionality:\n  name: foo\n  info:\n    site: https://abc.xyz\n    tags: [ one, two, three ]\n  arguments:\n    - name: --foo\n      type: string\n      info:\n        foo: bar\n        a:\n          b:\n            c"
  },
  {
    "objectID": "bin/data/CHANGELOG.html#minor-changes-3",
    "href": "bin/data/CHANGELOG.html#minor-changes-3",
    "title": "Viash",
    "section": "MINOR CHANGES",
    "text": "MINOR CHANGES\n\nBashWrapper: Allow printing the executor command by adding ---verbose ---verbose to a viash run or an executable.\nTestbenches: Rework MainBuildAuxiliaryNativeParameterCheck to create stimulus files and loop over the file from bash instead of looping natively. This prevents creating thousands of new processes which would only test a single parameter. Note this still calls the main script for each stimulus separately, but that was the case anyway, only much much worse.\nTestbenches: Split some grouped test benches into slightly smaller test benches that group tested functionality better.\nAnnotations: Complete the config schema annotations. Make sure all arguments are documented. Added an annotation internalFunctionality and undocumented for arguments that should not be documented. Added a testbench that verifies that all arguments are in fact annotated, skipping those that are not in the class constructor. Adds a hierarchy field in the __this__ member to list the relation of the own and parent classes.\nTestbenches: Add exit code to helper method testMainWithStdErr.\nTestbenches: Add testbench to verify viash underscore components (viash_build, viash_install, viash_push, viash_skeleton, viash_test).\nTestbenches: Update viash underscore component tests to use $meta_executable.\nviash ns exec: Allow choosing whether the {platform} field should be filled in, based on the --apply_platform parameter."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-5",
    "href": "bin/data/CHANGELOG.html#bug-fixes-5",
    "title": "Viash",
    "section": "BUG FIXES",
    "text": "BUG FIXES\n\nDockerPlatform: Remove duplicate auto-mounts (#257).\nUnderscore component tests: Fix tests for viash_skeleton and viash_test components.\nNextflowVDSL3Platform: Fix ‘Module scriptPath has not been defined yet’ error when Nextflow>=22.10 (#269).\nconfig inject: Doesn’t work when must_exist == true (#273).\nRScript: Fix compatibility issue where the new character escaping in r_script required R>=4.0 (#275). Escaping is now handled without using the new r'(foo)' notation."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#deprecation",
    "href": "bin/data/CHANGELOG.html#deprecation",
    "title": "Viash",
    "section": "DEPRECATION",
    "text": "DEPRECATION\n\nDockerRequirements: The resources: setting has been deprecated and will be removed in Viash 0.7.0. Please use copy: instead.\nDockerRequirements: The privileged: setting has been deprecated and will be removed in Viash 0.7.0. Please use run_args: \"--privileged\" instead."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#experimental-functionality",
    "href": "bin/data/CHANGELOG.html#experimental-functionality",
    "title": "Viash",
    "section": "EXPERIMENTAL FUNCTIONALITY",
    "text": "EXPERIMENTAL FUNCTIONALITY\n\nConfig: Any part of a Viash config can use inheritance to fill data (#271). For example: Contents of src/test/config.vsh.yaml:\n__inherits__: ../api/base.yaml\nfunctionality:\n  name: test\n  resources:\n    - type: bash_script\n      path: script.sh\n      text: |\n        echo Copying $par_input to $par_output\n        cp $par_input $par_output\nContents of src/api/base.yaml:\nfunctionality:\n  arguments:\n    - name: \"--input\"\n      type: file\n    - name: \"--output\"\n      type: file\n      direction: output\nThe resulting yaml will be:\nfunctionality:\n  name: test\n  arguments:\n    - name: \"--input\"\n      type: file\n    - name: \"--output\"\n      type: file\n      direction: output\n  resources:\n    - type: bash_script\n      path: script.sh\n      text: |\n        echo Copying $par_input to $par_output\n        cp $par_input $par_output"
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-6",
    "href": "bin/data/CHANGELOG.html#bug-fixes-6",
    "title": "Viash",
    "section": "BUG FIXES",
    "text": "BUG FIXES\n\nGit: Strip credentials from remote repositories when retrieving the path.\nVDSL3: Allow optional output files to be null."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#breaking-changes-2",
    "href": "bin/data/CHANGELOG.html#breaking-changes-2",
    "title": "Viash",
    "section": "BREAKING CHANGES",
    "text": "BREAKING CHANGES\n\nDeprecated usage resources_dir variable inside scripts, use meta[\"resources_dir\"] instead (or $meta_resources_dir in Bash, or meta$resources_dir in R).\nDeprecated meta[\"n_proc\"] in favour for meta[\"cpus\"]."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#new-functionality-1",
    "href": "bin/data/CHANGELOG.html#new-functionality-1",
    "title": "Viash",
    "section": "NEW FUNCTIONALITY",
    "text": "NEW FUNCTIONALITY\n\nviash ns exec: Added two more fields:\n\n{platform}: the platform name (if applicable)\n{namespace}: the namespace of the component\n\nLongArgument: Added support for 64-bit integers with type: long as opposed to type: integer which are 32-bit integers."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#major-changes-1",
    "href": "bin/data/CHANGELOG.html#major-changes-1",
    "title": "Viash",
    "section": "MAJOR CHANGES",
    "text": "MAJOR CHANGES\n\nAllow passing integers/doubles/booleans to string parameters (#225). Removed the ‘Version’ helper class."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#minor-changes-4",
    "href": "bin/data/CHANGELOG.html#minor-changes-4",
    "title": "Viash",
    "section": "MINOR CHANGES",
    "text": "MINOR CHANGES\n\nmeta[\"cpus\"] is now an integer, meta[\"memory_*\"] are now longs (#224).\nDockerPlatform: Only store author names in the authors metadata.\nNextflowPlatform: Only store author names in the authors metadata.\nArgument[_]: Turn multiple_sep from Char into String."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#internal-changes",
    "href": "bin/data/CHANGELOG.html#internal-changes",
    "title": "Viash",
    "section": "INTERNAL CHANGES",
    "text": "INTERNAL CHANGES\n\nAll meta[...] variables are now processed similar to Argument[_]s, instead of using custom code to convert object types and detect Docker mounts.\nEscaper: Make more generic Escaper helper class."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#documentation",
    "href": "bin/data/CHANGELOG.html#documentation",
    "title": "Viash",
    "section": "DOCUMENTATION",
    "text": "DOCUMENTATION\n\nHardcoded URLs pointing to viash.io in the documentation annotations were replaced with a new keyword system.\nReplaced references to “DSL” with “Dynamic Config Modding” in the --help output.\nAdded an example for Ruby based Docker setups."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-7",
    "href": "bin/data/CHANGELOG.html#bug-fixes-7",
    "title": "Viash",
    "section": "BUG FIXES",
    "text": "BUG FIXES\n\nviash ns: Reverse exit code outputs, was returning 1 when everything was OK and 0 when errors were detected (#227).\nviash config inject: Fix processing of arguments when argument groups are defined (#231).\nFixed a few typos in the CLI.\nFixed the formatting of ns exec documentation.\nVDSL3: Fix stub functionality.\nVDSL3: Fix error during error message.\nviash test: Fix issue where VIASH_TEMP could not be a relative directory when running viash test (#242).\nBashScript, CSharpScript, JavaScriptScript, PythonScript, RScript, ScalaScript: Fix quoting issues of certain characters (#113)."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#deprecation-1",
    "href": "bin/data/CHANGELOG.html#deprecation-1",
    "title": "Viash",
    "section": "DEPRECATION",
    "text": "DEPRECATION\n\nNextflowPlatform: Deprecate --param_list_format parameter."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#testing",
    "href": "bin/data/CHANGELOG.html#testing",
    "title": "Viash",
    "section": "TESTING",
    "text": "TESTING\n\nBashScript, CSharpScript, JavaScriptScript, PythonScript, RScript, ScalaScript: Implement more rigorous testing of which characters are escaped.\nBashWrapper: Escape usage of multiple_sep. This fixes various checks and transformations not working when when multiple_sep is set to \";\" (#235)."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#breaking-changes-3",
    "href": "bin/data/CHANGELOG.html#breaking-changes-3",
    "title": "Viash",
    "section": "BREAKING CHANGES",
    "text": "BREAKING CHANGES\n\nNextflowPlatform: variant: vdsl3 is now the default NextflowPlatform. variant: legacy has been deprecated.\nFunctionality: Fields .inputs and .outputs has been deprecated. Please use .argument_groups instead (#186). Before:\nfunctionality:\n  inputs:\n    - name: \"--foo\"\n  outputs:\n    - name: \"--bar\"\nNow:\nfunctionality:\n  argument_groups:\n    - name: Inputs\n      arguments:\n        - name: \"--foo\"\n          type: file\n    - name: Outputs\n      arguments:\n        - name: \"--bar\"\n          type: file\n          direction: output\nPassing strings to an argument group’s arguments has been deprecated. Please simply copy the argument itself into the argument group (#186). Before:\nfunctionality:\n  arguments:\n    - name: \"--foo\"\n      type: file\n    - name: \"--bar\"\n      type: file\n      direction: output\n  argument_groups:\n    - name: Inputs\n      arguments: [ foo ]\n    - name: Outputs\n      arguments: [ bar ]\nNow:\nfunctionality:\n  argument_groups:\n    - name: Inputs\n      arguments:\n        - name: \"--foo\"\n          type: file\n    - name: Outputs\n      arguments:\n        - name: \"--bar\"\n          type: file\n          direction: output"
  },
  {
    "objectID": "bin/data/CHANGELOG.html#new-functionality-2",
    "href": "bin/data/CHANGELOG.html#new-functionality-2",
    "title": "Viash",
    "section": "NEW FUNCTIONALITY",
    "text": "NEW FUNCTIONALITY\n\nAllow setting the number of processes and memory limit from within the Viash config, as well as a list of required commands. Example:\nfunctionality:\nname: foo\nrequirements:\n  cpus: 10\n  memory: 10GB\n  commands: [ bash, r, perl ]\nYou can override the default requirements at runtime:\n\n./foo ---cpus 4 ---memory 100PB (for NativePlatform or DockerPlatform)\nBy adding process.cpus = 4 and process.memory \"100 PB\" to a nextflow.config (for NextflowPlatform)\n\nThis results the following meta variables to be injected into a script:\n\nmeta_cpus (in Bash) or meta[\"cpus\"] (in any other language): Number of processes the script is allowed to spawn.\nmeta_memory_b (in Bash) or meta[\"memory_b\"] (in any other language): Amount of memory the script is allowed to allocate, in bytes.\nmeta_memory_kb (in Bash) or meta[\"memory_kb\"] (in any other language): Same but in kilobytes, rounded up.\nmeta_memory_mb (in Bash) or meta[\"memory_mb\"] (in any other language): Same but in megabytes, rounded up.\nmeta_memory_gb (in Bash) or meta[\"memory_gb\"] (in any other language): Same but in gigabytes, rounded up.\nmeta_memory_tb (in Bash) or meta[\"memory_tb\"] (in any other language): Same but in terabytes, rounded up.\nmeta_memory_pb (in Bash) or meta[\"memory_pb\"] (in any other language): Same but in petabytes, rounded up.\n\nviash ns exec: Added a command for executing arbitrary commands for all found Viash components. The syntax of this command is inspired by find . -exec echo {} \\;.\nThe following fields are automatically replaced:\n\n{} | {path}: path to the config file\n{abs-path}: absolute path to the config file\n{dir}: path to the parent directory of the config file\n{abs-dir}: absolute path to the directory of the config file\n{main-script}: path to the main script (if any)\n{abs-main-script}: absolute path to the main script (if any)\n{functionality-name}: name of the component\n\nA command suffixed by \\; (or nothing) will execute one command for each of the Viash components, whereas a command suffixed by + will execute one command for all Viash components.\nConfigMod: Added a del(...) config mod to be able to delete a value from the yaml. Example: del(.functionality.version)."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#major-changes-2",
    "href": "bin/data/CHANGELOG.html#major-changes-2",
    "title": "Viash",
    "section": "MAJOR CHANGES",
    "text": "MAJOR CHANGES\n\nFolder structure: Adjusted the folder structure to correctly reflect the the namespace change of viash from com.dataintuitive.viash to io.viash.\nFunctionality: Reworked the enabled field from boolean to a status field which can have the following statusses: enabled, disabled and deprecated. When parsing a config file which has the status field set to deprecated a warning message is displayed on stderr. Backwards for enabled is provided where enabled: true => status: enabled and enabled: false => status: false. The enabled field is marked deprecated."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#minor-changes-5",
    "href": "bin/data/CHANGELOG.html#minor-changes-5",
    "title": "Viash",
    "section": "MINOR CHANGES",
    "text": "MINOR CHANGES\n\nResources: Handle edge case when no resources are specified in the vsh.yaml config file and display a warning message.\nBashWrapper: Add a warning when an argument containing flags (e.g. --foo) is not recognized and will be handled as a positional argument as this is likely a mistake.\nFunctionality: Add check to verify there are no double argument names or short names in the config vsh.yaml declarations.\nBashWrapper: Add check to verify a parameter isn’t declared twice on the CLI, except in the case multiple: true is declared as then it’s a valid use case.\nBashWrapper: For int min/max checking: use native bash functionality so there is no dependency to bc. For double min/max checking: add fallback code to use awk in case bc is not present on the system (most likely to happen when running tests in a docker container).\nviash ns list/viash config view: Allow viewing the post-processed argument groups by passing the --parse_argument_groups parameter."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#testing-1",
    "href": "bin/data/CHANGELOG.html#testing-1",
    "title": "Viash",
    "section": "TESTING",
    "text": "TESTING\n\nConfigMod: Added unit tests for condition config mods.\nMainTestDockerSuite: Derive config alternatives from the base vsh.yaml instead of adding the changes in separate files. This both reduces file clutter and prevents having to change several files when there are updates in the config format.\nGitTest: Added unit tests for Git helper (#216)."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-8",
    "href": "bin/data/CHANGELOG.html#bug-fixes-8",
    "title": "Viash",
    "section": "BUG FIXES",
    "text": "BUG FIXES\n\ncsharp_script, javascript_script, python_script, r_script, scala_script: Make meta fields for memory and cpus optional.\nNextflowVdsl3Platform: Don’t generate an error when --publish_dir is not defined and -profile no_publish is used.\nViash run: Viash now properly returns the exit code from the executed script.\nGit: Fix incorrect metadata when git repository is empty (#216)."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#breaking-changes-4",
    "href": "bin/data/CHANGELOG.html#breaking-changes-4",
    "title": "Viash",
    "section": "BREAKING CHANGES",
    "text": "BREAKING CHANGES\n\nWorkflowHelper::helpMessage: Now only takes one argument, namely the config."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#major-changes-3",
    "href": "bin/data/CHANGELOG.html#major-changes-3",
    "title": "Viash",
    "section": "MAJOR CHANGES",
    "text": "MAJOR CHANGES\n\nNamespace: Changed the namespace of viash from com.dataintuitive.viash to io.viash."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#minor-changes-6",
    "href": "bin/data/CHANGELOG.html#minor-changes-6",
    "title": "Viash",
    "section": "MINOR CHANGES",
    "text": "MINOR CHANGES\n\nTestbenches: Add a testbench framework to test lots of character sequences, single or repeating to be tested in the yaml config. This can be used to later extend to other tests.\nTestbenches::vdsl3: Add testbenches to verify functionality:\n\nVdsl3’s param_list (yamlblob, yaml, json, csv).\nNextflow’s own params-file.\nVdsl3’s recalculating resource file paths to be relative to the param_list file instead of the workflow file (only available for yaml, json, csv).\nVdsl3’s wrapping of modules to run these as a separate workflow automagically out of the box.\n\nMain: Added viash --schema_export which outputs a schema of the Viash config file to console. This is to be used to automate populating the documentation website.\nHelper: Split help message by argument group.\nHelper: Remove unneeded arguments.\nFunctionality: Add default groups Inputs, Outputs and Arguments for all arguments missing from user-defined argument_groups.\nWorkflowHelper::helpMessage: Rewrite to bring on par with Viash’s help message.\nBooleanArguments: Renamed internal class names for BooleanArguments to be better in line with how they are named in the config yaml. BooleanArgumentRegular -> BooleanArgument (in line with boolean) BooleanArgumentTrue -> BooleanTrueArgument (in line with boolean_true) BooleanArgumentFalse -> BooleanFalseArgument (in line with boolean_false)"
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-9",
    "href": "bin/data/CHANGELOG.html#bug-fixes-9",
    "title": "Viash",
    "section": "BUG FIXES",
    "text": "BUG FIXES\n\nNextflowVdsl3Platform: Change how --id is processed when a VDSL3 module is called from the CLI.\nNextflowVdsl3Platform: Fix error when param_list is null.\nNextflowVdsl3Platform: Fix error when optional, multiple arguments are set to null.\nTestbenches: Better capture expected error messages while running testbenches again. Code changes right before previous release re-introduced some of the messages.\nNextflowVdsl3Platform: Fix issue where optional parameters aren’t removed when .run(args: [optarg: null]).\nWorkflowHelper::readCsv: Treat empty values as undefined instead of throwing an error.\nNextflowVdsl3Platform: Use $NXF_TEMP or $VIASH_TEMP as temporary directory if the container engine is not set to docker, podman or charlieengine, else set to /tmp.\nResources: When adding a resource folder, allow a trailing / at the end of the path. Previously this caused the target folder to be erased and the content of the resource folder to be written directly into the target folder."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#new-functionality-3",
    "href": "bin/data/CHANGELOG.html#new-functionality-3",
    "title": "Viash",
    "section": "NEW FUNCTIONALITY",
    "text": "NEW FUNCTIONALITY\n\nFunctionality: Allow specifying argument groups. Example:\nfunctionality:\n  ...\n  argument_groups:\n    - name: First group\n      arguments: [foo, bar]\n      description: Description\nAddition of the viash_nxf_schema component for converting a Viash config (for a workflow) into a nextflow schema file.\nNextflowVdsl3Platform: Use --param_list to initialise a Nextflow channel with multiple parameter sets. Possible formats are csv, json, yaml, or simply a yaml_blob. A csv should have column names which correspond to the different arguments of this pipeline. A json or a yaml file should be a list of maps, each of which has keys corresponding to the arguments of the pipeline. A yaml blob can also be passed directly as a parameter. Inside the Nextflow pipeline code, params.param_list can also be used to directly a list of parameter sets. When passing a csv, json or yaml, relative path names are relativized to the location of the parameter file.\nExamples:\nnextflow run \"target/foo/bar/main.nf\" --param_list '[{\"id\": \"foo\", \"input\": \"/path/to/bar\"}]'\nnextflow run \"target/foo/bar/main.nf\" --param_list \"params.csv\" --reference \"/path/to/ref\""
  },
  {
    "objectID": "bin/data/CHANGELOG.html#major-changes-4",
    "href": "bin/data/CHANGELOG.html#major-changes-4",
    "title": "Viash",
    "section": "MAJOR CHANGES",
    "text": "MAJOR CHANGES\n\nNextflowVdsl3Platform: The functionality is now slurped from a json instead of manually taking care of the formatting in Groovy.\nNextflowVdsl3Platform: The --help is auto-generated from the config."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#minor-changes-7",
    "href": "bin/data/CHANGELOG.html#minor-changes-7",
    "title": "Viash",
    "section": "MINOR CHANGES",
    "text": "MINOR CHANGES\n\nNextflowVdsl3Platform: Allow both --publish_dir and --publishDir when auto.publish = true.\nNextflowVdsl3Platform: Allow passing parameters with multiplicity > 1 from Nextflow CLI.\nMain: Added viash --cli_export which outputs the internal cli construction information to console. This is to be used to automate populating the documentation website.\nviash ns: Display success and failure summary statistics, printed to stderr.\nDataObject: .alternatives is now a OneOrMore[String] instead of List[String], meaning you can now specify { type: string, name: \"--foo\", alternatives: \"-f\" } instead of { type: string, name: \"--foo\", alternatives: [ \"-f\" ] }\nBashWrapper: Added metadata field meta_executable, which is a shorthand notation for meta_executable=\"$meta_resources_dir/$meta_functionality_name\""
  },
  {
    "objectID": "bin/data/CHANGELOG.html#internal-changes-1",
    "href": "bin/data/CHANGELOG.html#internal-changes-1",
    "title": "Viash",
    "section": "INTERNAL CHANGES",
    "text": "INTERNAL CHANGES\n\nArguments: Internal naming of functionality.arguments is changed from DataObject to Arguments. Change is also applied to child classes, e.g. StringObject -> StringArgument.\nScript: Allow more control over where injected code ends up.\nRestructure type system to allow type-specific arguments."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-10",
    "href": "bin/data/CHANGELOG.html#bug-fixes-10",
    "title": "Viash",
    "section": "BUG FIXES",
    "text": "BUG FIXES\n\nDockerPlatform: Change org.opencontainers.image.version annotation to functionality.version when set. Additionally fixed retrieving the git tag possibly returning fatal: No names found, cannot describe anything. or similar.\nviash config inject: Fix config inject when .functionality.inputs or .functionality.outputs is used.\nBashWrapper: Don’t add bc as dependency. Only perform integer/float min/max checks when bc is available, otherwise ignore.\nDockerPlatform: Fix inputs & outputs arguments being present twice.\nviash ns test: Silently skip Nextflow platforms as these don’t support tests and will always fail.\nTestbenches: Better capture expected error messages while running testbenches. Having these show on the console could be confusing.\nNextflowVdsl3Platform: Fix issue when running multiple VDSL3 modules concurrently on the same channel."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#new-functionality-4",
    "href": "bin/data/CHANGELOG.html#new-functionality-4",
    "title": "Viash",
    "section": "NEW FUNCTIONALITY",
    "text": "NEW FUNCTIONALITY\n\nNextflowVdsl3Platform: Allow overriding the container registry of all Viash components by setting the params.override_container_registry value. Only works for auto-derived image names."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#major-changes-5",
    "href": "bin/data/CHANGELOG.html#major-changes-5",
    "title": "Viash",
    "section": "MAJOR CHANGES",
    "text": "MAJOR CHANGES\n\nFunctionality: renamed tests to test_resources. Backwards compatibility provided but a notification message is displayed on the console."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#minor-changes-8",
    "href": "bin/data/CHANGELOG.html#minor-changes-8",
    "title": "Viash",
    "section": "MINOR CHANGES",
    "text": "MINOR CHANGES\n\nFunctionality and viash ns: Added .enabled in functionality, set to true by default. Filter for disabled components in namespace commands.\nDockerPlatform: Add org.opencontainers.image annotations to built docker images.\nFunctionality: when defining text resources, permit defining path instead of dest. If both dest and path are unset, use a default file name depending on the resource type, such as script.sh or text.txt.\nviash build: Errors are printed in red."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-11",
    "href": "bin/data/CHANGELOG.html#bug-fixes-11",
    "title": "Viash",
    "section": "BUG FIXES",
    "text": "BUG FIXES\n\nNextflowVdsl3Platform: Undefined input files should not inject a VIASH_PAR_* variable when multiple: true.\nNextflowVdsl3Platform: Make injected resources dir absolute.\nNextflowVdsl3Platform: Fix escaping of triple single quotes.\nNextflowVdsl3Platform: Also apply auto.simplifyInput to Lists.\nDockerPlatform: added a test_setup that allows adding apt/apk/… setup requirements. These are only executed when running tests."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#minor-changes-9",
    "href": "bin/data/CHANGELOG.html#minor-changes-9",
    "title": "Viash",
    "section": "MINOR CHANGES",
    "text": "MINOR CHANGES\n\n--help: Don’t print “my_component ” when no version is specified, but instead simply “my_component”.\nNextflowVdsl3Platform: Set mode=copy for auto.publish and auto.transcript.\nNextflowVdsl3Platform: When a module is used multiple times in the same workflow, don’t throw an error anymore, instead simply generate a warning.\nNextflowVdsl3Platform: Throw an error when an input file was not found.\nviash build: Indent auto-generated code according the indentation of VIASH START when found.\nMain: Handle not finding the config file or resources in a config file better. Display a more helpful message instead of a stack trace.\nBashWrapper: Add checks on parameters for valid integer, double and boolean values.\nBashWrapper: Add option to limit string and integer values to specific choice values.\nBashWrapper: Add option to set min and max values for integer and double values.\nDependencies:\n\nScala was upgraded from 2.12.10 to 2.12.15\nsbt was upgraded from 1.3.4 to 1.6.1\nsbt-scoverage was upgraded from 1.5.1 to 1.9.3"
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-12",
    "href": "bin/data/CHANGELOG.html#bug-fixes-12",
    "title": "Viash",
    "section": "BUG FIXES",
    "text": "BUG FIXES\n\nviash_test: Add back --no_cache parameter to viash_test.\nviash_test: Fix --append parameter for viash_test, was not getting passed through.\nviash ns test: Fix --append parameter, actually start from a clean file if append is false.\nviash_push: Fix component not being built during a release of Viash.\nPythonRequirements: Fix packages being mentioned twice in a Dockerfile.\nMain: Added support spaces in filenames of config files and resources\nBashWrapper: Display a message when the last parsed argument would require more values than are still available. Now display a message that values are missing, used to silently crash the wrapper.\nviash config inject: Fix error when file argument is must_exist: true."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#major-changes-6",
    "href": "bin/data/CHANGELOG.html#major-changes-6",
    "title": "Viash",
    "section": "MAJOR CHANGES",
    "text": "MAJOR CHANGES\n\nFunctionality: Now also accepts ‘inputs’ and ‘outputs’ in addition to ‘arguments’. For inputs and outputs, any specified arguments will have default type: file and direction: input or direction: output respectively."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#minor-changes-10",
    "href": "bin/data/CHANGELOG.html#minor-changes-10",
    "title": "Viash",
    "section": "MINOR CHANGES",
    "text": "MINOR CHANGES\n\nDockerPlatform: Move description labels to the end of the Dockerfile to improve cross-component caching.\nFunctionality: Arguments where .multiple is true can now have lists as default and example.\nviash_build: Added unit test for this component.\nviash_test: Added unit test for this component.\nPythonRequirements: Allow upgrading dependencies. Example: [ type: python. pypi: anndata, upgrade: true ].\nNextflowLegacyPlatform: Remove annoying messages when building Nxf modules.\nConfigMods: Expanded the DSL to allow specifying at which point to apply a config mod. This functionality was necessary to allow for setting fields which alter the way configs are parsed. Example of when this is useful: <preparse> .platforms[.type == \"nextflow\"].variant := \"vdsl3\". Updating workflow of parsing a config file is:\n\nread Yaml from file\napply preparse config mods\nparse resulting Json as Config, thereby instantiating default values etc.\nconvert Config back to Json\napply postparse config mods (original config mods)\nconvert final Json back to Config"
  },
  {
    "objectID": "bin/data/CHANGELOG.html#beta-functionality",
    "href": "bin/data/CHANGELOG.html#beta-functionality",
    "title": "Viash",
    "section": "BETA FUNCTIONALITY",
    "text": "BETA FUNCTIONALITY\n\nNextflowVdsl3Platform: A beta implementation of the next-generation Viash+Nextflow platform. See https://github.com/viash-io/viash/issues/82 for more information. You can access the previous Nextflow platform by using the variant parameter:\n- type: nextflow\n  variant: legacy\n  separate_multiple_outputs: false"
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-13",
    "href": "bin/data/CHANGELOG.html#bug-fixes-13",
    "title": "Viash",
    "section": "BUG FIXES",
    "text": "BUG FIXES\n\nviash_build and viash_test: The query_name and query_namespace arguments were switched around. These arguments are now passed correctly.\nBashScript, JavaScriptScript, PythonScript, RScript: Correctly escape ' (#113). Update unit tests accordingly.\nCSharpScript, ScalaScript: Correctly escape \" (#113). Update unit tests accordingly.\nviash_build, viash_test, viash_push: Don’t try to remove log files if they don’t exist."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#internal-changes-2",
    "href": "bin/data/CHANGELOG.html#internal-changes-2",
    "title": "Viash",
    "section": "INTERNAL CHANGES",
    "text": "INTERNAL CHANGES\n\nDataObject:\n\nRenamed otype to flags.\nRenamed oType to type\nDeprecated tag (unused feature).\n\nAll abstract / inherited classes: Renamed oType to type."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#deprecation-2",
    "href": "bin/data/CHANGELOG.html#deprecation-2",
    "title": "Viash",
    "section": "DEPRECATION",
    "text": "DEPRECATION\n\nFunctionality: Deprecated function_type and add_resources_to_path. These should be unused features, by now."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fix",
    "href": "bin/data/CHANGELOG.html#bug-fix",
    "title": "Viash",
    "section": "BUG FIX",
    "text": "BUG FIX\n\nNextflowPlatform: Fix passthrough of organization field."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#major-changes-7",
    "href": "bin/data/CHANGELOG.html#major-changes-7",
    "title": "Viash",
    "section": "MAJOR CHANGES",
    "text": "MAJOR CHANGES\n\nviash_install:\n\nAdded --log_prefix: This prefix is used to determine the path of the log files for viash_build, viash_test and viash_push.\nAdded --organization: Id of the organisation to be used in the Docker image name, i.e. <registry>/<organization>/<namespace><namespace_sep><name>.\nAdded --target_image_source: Url to the Git repo in which this project resides.\nRemoved --log.\n\nviash_build:\n\nReduce code duplication by contructing the command with Bash Arrays.\nRenamed --platforms to --platform.\nAdded --organization: Id of the organisation to be used in the Docker image name, i.e. <registry>/<organization>/<namespace><namespace_sep><name>.\nAdded --target_image_source: Url to the Git repo in which this project resides.\nChanged default of --log from log.txt to .viash_build_log.txt.\nAdded --verbose: Print out the underlying viash ns build command before running it.\n\nviash_test:\n\nReduce code duplication by contructing the command with Bash Arrays.\nRenamed --platforms to --platform.\nAdded --organization: Id of the organisation to be used in the Docker image name, i.e. <registry>/<organization>/<namespace><namespace_sep><name>.\nAdded --target_image_source: Url to the Git repo in which this project resides.\nChanged default of --log from log.txt to .viash_test_log.txt.\nChanged default of --tsv from log.tsv to .viash_test_log.tsv.\nAdded --verbose: Print out the underlying viash ns test command before running it.\n\nviash_push:\n\nReduce code duplication by contructing the command with Bash Arrays.\nAdded --organization: Id of the organisation to be used in the Docker image name, i.e. <registry>/<organization>/<namespace><namespace_sep><name>.\nChanged default of --log from log.txt to .viash_push_log.txt.\nAdded --verbose: Print out the underlying viash ns build command before running it."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#minor-changes-11",
    "href": "bin/data/CHANGELOG.html#minor-changes-11",
    "title": "Viash",
    "section": "MINOR CHANGES",
    "text": "MINOR CHANGES\n\nNextflowPlatform: Added the organization field to the nextflow platform as well."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#new-features",
    "href": "bin/data/CHANGELOG.html#new-features",
    "title": "Viash",
    "section": "NEW FEATURES",
    "text": "NEW FEATURES\n\nviash run: A long running Viash component can be interrupted by pressing CTRL-C or by sending it an INT or SIGINT signal.\nDockerPlatform: Automatically add a few labels based on metadata to Dockerfile.\nDockerPlatform: Added value target_image_source for setting the source of the target image. This is used for defining labels in the dockerfile. Example:\ntarget_image_source: https://github.com/foo/bar"
  },
  {
    "objectID": "bin/data/CHANGELOG.html#minor-changes-12",
    "href": "bin/data/CHANGELOG.html#minor-changes-12",
    "title": "Viash",
    "section": "MINOR CHANGES",
    "text": "MINOR CHANGES\n\nviash ns list: Added --format yaml/json argument to be able to return the output as a json as well. Useful for when jq is installed but yq is not. Example:\n  viash ns list -p docker -f json | jq '.[] | .info.config'\nviash config view: Same as above."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#deprecation-3",
    "href": "bin/data/CHANGELOG.html#deprecation-3",
    "title": "Viash",
    "section": "DEPRECATION",
    "text": "DEPRECATION\n\nCLI: Deprecated -P flag use -p intead.\nDockerPlatform: Deprecated version value."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#new-functionality-5",
    "href": "bin/data/CHANGELOG.html#new-functionality-5",
    "title": "Viash",
    "section": "NEW FUNCTIONALITY",
    "text": "NEW FUNCTIONALITY\n\nDockerPlatform: Allow defining a container’s organisation. Example:\n  - type: docker\n    registry: ghcr.io\n    organisation: viash-io\n    image: viash\n    tag: \"1.0\"\n    target_registry: ghcr.io\n    target_organization: viash-io\nDockerRequirement: Add label instructions. Example: setup: [ [ type: docker, label: [ \"foo BAR\" ]]]\nConfig: In specific places, allow parsing a value as a list of values. Fixes #97. This mostly applies to list values in DockerPlatform, but also to author roles. Examples:\nfunctionality:\n  name: foo\n  authors:\n    - name: Alice\n      role: author # can be a string or a list\nplatforms:\n  - type: docker\n    port: \"80:80\" # can be a string or a list\n    setup:\n      - type: r\n        packages: incgraph # can be a string or a list"
  },
  {
    "objectID": "bin/data/CHANGELOG.html#breaking-changes-5",
    "href": "bin/data/CHANGELOG.html#breaking-changes-5",
    "title": "Viash",
    "section": "BREAKING CHANGES",
    "text": "BREAKING CHANGES\n\nviash test: This command doesn’t automatically add the resources dir to the path."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-14",
    "href": "bin/data/CHANGELOG.html#bug-fixes-14",
    "title": "Viash",
    "section": "BUG FIXES",
    "text": "BUG FIXES\n\nFunctionality: Fix .functionality.add_resources_to_path not being picked up correctly.\nAptRequirement: Set DEBIAN_FRONTEND=noninteractive by default. This can be turned off by specifying:\n  - type: apt\n    packages: [ foo, bar ]\n    interactive: true"
  },
  {
    "objectID": "bin/data/CHANGELOG.html#minor-changes-13",
    "href": "bin/data/CHANGELOG.html#minor-changes-13",
    "title": "Viash",
    "section": "MINOR CHANGES",
    "text": "MINOR CHANGES\n\nMain: Slightly better error messages when parsing of viash yaml file fails. Before:\n$ viash test src/test/resources/testbash/config_failed_build.vsh.yaml \nException in thread \"main\" DecodingFailure(Unexpected field: [package]; valid fields: packages, interactive, type, List(DownField(apt), DownArray, DownField(platforms)))\nAfter:\n$ viash test src/test/resources/testbash/config_failed_build.vsh.yaml \nError parsing 'file:///path/to/viash/src/test/resources/testbash/config_failed_build.vsh.yaml'. Details:\nUnexpected field: [package]; valid fields: packages, interactive, type: DownField(apt),DownArray,DownField(platforms)"
  },
  {
    "objectID": "bin/data/CHANGELOG.html#breaking-changes-6",
    "href": "bin/data/CHANGELOG.html#breaking-changes-6",
    "title": "Viash",
    "section": "BREAKING CHANGES",
    "text": "BREAKING CHANGES\n\nviash config: An argument’s example now needs to be of the same type as the argument itself. For example, [ type: integer, name: foo, example: 10 ] is valid, whereas [ type: integer, name: foo, example: bar ] is not, as ‘bar’ cannot be cast to an integer."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#new-functionality-6",
    "href": "bin/data/CHANGELOG.html#new-functionality-6",
    "title": "Viash",
    "section": "NEW FUNCTIONALITY",
    "text": "NEW FUNCTIONALITY\n\nviash config inject: A command for inserting a Viash header into your script.\nYumRequirement: Added a requirement setup for installing through yum. Example: setup: [ [ type: yum, packages: [ wget] ] ]\nDockerRequirement: Allow using copy and add instructions. Example: setup: [ [ type: docker, add: [ \"http://foo.bar .\" ]]]"
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-15",
    "href": "bin/data/CHANGELOG.html#bug-fixes-15",
    "title": "Viash",
    "section": "BUG FIXES",
    "text": "BUG FIXES\n\nViashTest: Fix verbosity passthrough.\n--help: Fix repeated usage flag when printing the help."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#breaking-changes-7",
    "href": "bin/data/CHANGELOG.html#breaking-changes-7",
    "title": "Viash",
    "section": "BREAKING CHANGES",
    "text": "BREAKING CHANGES\n\nBashWrapper: Forbidden flags -v, --verbose, --verbosity have been renamed to ---v, ---verbose, ---verbosity."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#minor-changes-14",
    "href": "bin/data/CHANGELOG.html#minor-changes-14",
    "title": "Viash",
    "section": "MINOR CHANGES",
    "text": "MINOR CHANGES\n\nSet version of helper scripts to the same version as Viash.\nDockerPlatform: Produce helpful warning message when Docker image can’t be found remotely (#94).\nDockerPlatform: Produce helpful error message when Docker isn’t installed or the daemon is not running (#94 bis)."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-16",
    "href": "bin/data/CHANGELOG.html#bug-fixes-16",
    "title": "Viash",
    "section": "BUG FIXES",
    "text": "BUG FIXES\n\nviash_install:\n\nPassing Viash path as a string instead of as a file to ensure the path is not converted to an absolute path\nSwitch from Docker backend to a Native backend, ‘unzip’ and ‘wget’ are required.\nCorrectly set the log file for viash_test.\n\nDockerPlatform: Added sleep workaround to avoid concurrency issue where a file is executed to build docker containers but apparently still in the process of being written.\nDockerPlatform: Fix order issue of —verbose flag in combination with —setup, allowing to run viash run config.vsh.yaml -- ---setup cb ---verbose and actually get output."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#breaking-changes-8",
    "href": "bin/data/CHANGELOG.html#breaking-changes-8",
    "title": "Viash",
    "section": "BREAKING CHANGES",
    "text": "BREAKING CHANGES\n\nFunctionality: The resources dir no longer automatically added to the PATH variable. To alter this behaviour, set .functionality.add_resources_to_path to true."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#minor-changes-15",
    "href": "bin/data/CHANGELOG.html#minor-changes-15",
    "title": "Viash",
    "section": "MINOR CHANGES",
    "text": "MINOR CHANGES\n\nBash Script: only define variables which have values.\nCSharp Test Component: Change Docker image to dataintuitive/dotnet-script to have more control over the lifecycle of versioned tags.\nUpdated Code of Conduct from v2.0 to v2.1."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-17",
    "href": "bin/data/CHANGELOG.html#bug-fixes-17",
    "title": "Viash",
    "section": "BUG FIXES",
    "text": "BUG FIXES\n\nViash namespace: Fix incorrect output path when the parent directory of a Viash component is not equal to the value of .functionality.name."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#breaking-changes-9",
    "href": "bin/data/CHANGELOG.html#breaking-changes-9",
    "title": "Viash",
    "section": "BREAKING CHANGES",
    "text": "BREAKING CHANGES\n\nNextflowPlatform: The default caching mechanism is now what Nextflow uses as default. In order to replicate earlier caching, cache: deep should be specified in the Viash config file."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#new-features-1",
    "href": "bin/data/CHANGELOG.html#new-features-1",
    "title": "Viash",
    "section": "NEW FEATURES",
    "text": "NEW FEATURES\n\nNextflowPlatform: Added cache directive to specify the typing of caching to be performed."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#resources-directory",
    "href": "bin/data/CHANGELOG.html#resources-directory",
    "title": "Viash",
    "section": "Resources directory",
    "text": "Resources directory\nAll resources defined in the config file are copied over to a temporary location right before a Viash component is executed. This location is can now be easily accessed in your scripts, allowing you to modify and copy the files as needed.\nHere are some examples in different scripting languages on how to access the meta data, it works similarly to the par list:\nBash:\necho $meta_resources_dir \nPython:\nprint(meta[\"resources_dir\"])\nR:\ncat(meta$resources_dir)"
  },
  {
    "objectID": "bin/data/CHANGELOG.html#functionality-name",
    "href": "bin/data/CHANGELOG.html#functionality-name",
    "title": "Viash",
    "section": "Functionality name",
    "text": "Functionality name\nThe name of the component can now be accessed in the same way as the resources directory. This allows you to print the name of the component out to a console window for example. Here’s how to access this data in different scripting languages:\nBash:\necho $meta_functionality_name\nPython:\nprint(meta[\"functionality_name\"])\nR:\ncat(meta$functionality_name)"
  },
  {
    "objectID": "bin/data/CHANGELOG.html#new-features-2",
    "href": "bin/data/CHANGELOG.html#new-features-2",
    "title": "Viash",
    "section": "NEW FEATURES",
    "text": "NEW FEATURES\n\nSimilar to par, each script now also has a meta list. meta contains meta information about the component or the execution thereof. It currently has the following fields:\n\nmeta[\"resources_dir\"]: Path to the directory containing the resources\nmeta[\"functionality_name\"]: Name of the component\n\nNextflowPlatform: Export VIASH_TEMP environment variable."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-18",
    "href": "bin/data/CHANGELOG.html#bug-fixes-18",
    "title": "Viash",
    "section": "BUG FIXES",
    "text": "BUG FIXES\n\nNextflowPlatform: Fix output formatting when separate_multiple_outputs is false."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#minor-changes-16",
    "href": "bin/data/CHANGELOG.html#minor-changes-16",
    "title": "Viash",
    "section": "MINOR CHANGES",
    "text": "MINOR CHANGES\n\nDockerPlatform: Added run_args field to allow setting docker run arguments.\nNextflowPlatform: Added argument separate_multiple_outputs to allow not separating the outputs generated by a component with multiple outputs as separate events on the channel."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fix-1",
    "href": "bin/data/CHANGELOG.html#bug-fix-1",
    "title": "Viash",
    "section": "BUG FIX",
    "text": "BUG FIX\n\nIO: Allow overwriting directory resources upon rebuild."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#c-script-support",
    "href": "bin/data/CHANGELOG.html#c-script-support",
    "title": "Viash",
    "section": "C# script support",
    "text": "C# script support\nWe’ve added C# scripts (.csx) as a supported language using dotnet-script.\nTo run C# scripts natively, you’ll need to install .NET Core and execute the following command in a terminal:\ndotnet tool install -g dotnet-script\nYou can now run C# scripts like this:\ndotnet script hello_viash.csx\nTo use C# scripts as components, use the new csharp_script type in the functionality section of your config file:\n  resources:\n  - type: csharp_script\n    path: script.csx\nHere’s an example of a simple C# script with Viash in mind:\n// VIASH START\nvar par = new {\n  input = \"Hello World\",\n  name = \"Mike\"\n};\n// VIASH END\n\nSystem.Console.WriteLine(input + \", \" + name + \"!\");\nThe language-specific guide for creating C# script components will be added in the near future."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-19",
    "href": "bin/data/CHANGELOG.html#bug-fixes-19",
    "title": "Viash",
    "section": "Bug fixes",
    "text": "Bug fixes\nFirst off, these special characters can now be used in the description, usage, default and example fields of components:\n\n”\n`\n\\\n\n$\n\nNextflow output files with the same extension won’t overwrite each other any more, like it was the case for arguments like this:\nfunctionality:\n  name: bar\n  arguments:\n    - name: \"--input\"\n      type: file\n      example: input.txt\n    - name: \"--output1\"\n      type: file\n      direction: output\n      required: true\n      example: output.txt\n    - name: \"--output2\"\n      type: file\n      direction: output\n      required: true\n      example: optional.txt\nIn this case, the two output files would have been identical in the past. ___"
  },
  {
    "objectID": "bin/data/CHANGELOG.html#new-features-3",
    "href": "bin/data/CHANGELOG.html#new-features-3",
    "title": "Viash",
    "section": "NEW FEATURES",
    "text": "NEW FEATURES\n\nCSharpScript: Added support for C# scripts (type: \"csharp_script\") to viash."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#minor-changes-17",
    "href": "bin/data/CHANGELOG.html#minor-changes-17",
    "title": "Viash",
    "section": "MINOR CHANGES",
    "text": "MINOR CHANGES\n\nNextflowPlatform: Added directive_cpus, directive_max_forks, directive_memory and directive_time parameters."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-20",
    "href": "bin/data/CHANGELOG.html#bug-fixes-20",
    "title": "Viash",
    "section": "BUG FIXES",
    "text": "BUG FIXES\n\nBashWrapper: Refactor escaping descriptions, usages, defaults, and examples (#34).\nNextflowPlatform: Refactor escaping descriptions, usages, defaults and examples (#75).\nNextflowPlatform: Add argument to output path to avoid naming conflicts for components with multiple output files (#76).\nNextflowPlatform, renderCLI(): Only add flag to rendered command when boolean_true is actually true (#78).\nDockerPlatform: Only chown when output file exists."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#testing-2",
    "href": "bin/data/CHANGELOG.html#testing-2",
    "title": "Viash",
    "section": "TESTING",
    "text": "TESTING\n\nviash build: Capture stdout messages when errors are expected, so that they don’t clutter the expected output.\nviash build: Check --help description output on the whole text instead of per letter or word basis.\nTestingAllComponentsSuite: Only testing bash natively, because other dependencies might not be available."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#breaking-changes-10",
    "href": "bin/data/CHANGELOG.html#breaking-changes-10",
    "title": "Viash",
    "section": "BREAKING CHANGES",
    "text": "BREAKING CHANGES\n\nDockerPlatform: A Docker setup will be performed by default. Default strategy has been changed to ifneedbepullelsecachedbuild (#57). ---setup strategy has been removed and ---docker_setup_strategy has been renamed to ---setup. This change allows running a component for the first time. During first time setup, the Docker container will be pulled or built automatically.\nNativePlatform: Deprecated the native setup field."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#major-changes-8",
    "href": "bin/data/CHANGELOG.html#major-changes-8",
    "title": "Viash",
    "section": "MAJOR CHANGES",
    "text": "MAJOR CHANGES\n\nNXF: This version changes the handling logic for arguments. An argument can be either required or not and can have a default: ... value or not. Checks are implemented to verify that required arguments are effectively provided during pipeline running.\nNXF: If one sticks to long-option argments in the viash config, for all arguments that are required, the way of specifying the arguments on the CLI is identical for the Docker and Nextflow platforms. Non-required arguments can still be accessed from CLI using --<component_name>__<argument_name> ....\nNXF: Running a module as a standalone pipeline has become easier.\nviash run: Implement verbosity levels (#58). viash executables now have 7 levels of verbosity: emergency, alert, critical, error, warning, notice, info, debug. The default verbosity level is ‘notice’. Passing -v or --verbose bumps up the verbosity level by one, -vv by two. The verbosity level can be set manually by passing --verbosity x."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#minor-changes-18",
    "href": "bin/data/CHANGELOG.html#minor-changes-18",
    "title": "Viash",
    "section": "MINOR CHANGES",
    "text": "MINOR CHANGES\n\nDocker Platform: Added privileged argument, allowing to run docker with the --privileged flag.\nDocker Requirements: Allow specifying environment variables in the Dockerfile.\nConfig modding: Added a +0= operator to prepend items to a list.\nviash run: Added a --version flag to viash executables for viewing the version of the component.\nFunctionality: Added checks on the functionality and argument names.\nviash run: Added examples to functionality and arguments. Reworked --help formatting to include more information and be more consistent (#56)."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-21",
    "href": "bin/data/CHANGELOG.html#bug-fixes-21",
    "title": "Viash",
    "section": "BUG FIXES",
    "text": "BUG FIXES\n\nDocker R Requirements: Install remotes when using { type: r, packages: [ foo ] }.\nconfig: Throw error when user made a typo in the viash config (#62)."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#testing-3",
    "href": "bin/data/CHANGELOG.html#testing-3",
    "title": "Viash",
    "section": "TESTING",
    "text": "TESTING\n\nNXF: Add an end-to-end test for running a nextflow pipeline using viash components.\nDocker: Reorganized viash docker build testbench into a main testbench with smaller auxiliary testbenches to keep them more manageable and clear what happens where.\nviash ns: Added a basic testbench for namespace tests."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fix-2",
    "href": "bin/data/CHANGELOG.html#bug-fix-2",
    "title": "Viash",
    "section": "BUG FIX",
    "text": "BUG FIX\n\nNXF: Return original_params instead of updated params for now.\nNXF: Reinstate function_type: asis in line with the refactored module generation code\nviash ns test: print header when --tsv foo.tsv --append true but foo.tsv doesn’t exist yet. Fixes #45."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#new-features-4",
    "href": "bin/data/CHANGELOG.html#new-features-4",
    "title": "Viash",
    "section": "NEW FEATURES",
    "text": "NEW FEATURES\n\nConfig modding: A custom viash DSL allows overriding viash config properties at runtime. See online documentation for more information. Example:\nviash ns test \\\n  -p docker \\\n  -c '.functionality.version := \"1.0.0\"' \\\n  -c '.platforms[.type == \"docker\"].target_registry := \"my.docker-registry.com\"' \\\n  -c '.platforms[.type == \"docker\"].setup_strategy := \"pull\"' \\\n  -l\nviash build: The image can be pushed with --push. The same can be done by passing ---push to a viash executable.\nviash ns can query the name, namespace, or both, with the following arguments:\n\n--query_namespace or -n: filter the namespace with a regex.\n--query_name: filter the name with a regex.\n--query or -q: filter the namespace/name with a regex.\n\nAdded the project_build, project_clean, project_push and project_test components to this repository.\nAdded a field .functionality.info of type Map[String, String] in order to be able to specify custom annotations to the component."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#breaking-changes-11",
    "href": "bin/data/CHANGELOG.html#breaking-changes-11",
    "title": "Viash",
    "section": "BREAKING CHANGES",
    "text": "BREAKING CHANGES\n\nviash ns: Argument --namespace has been renamed to --query_namespace.\nviash ns: Argument --namespace does not implicitly change the namespace of the functionality anymore. You can use the command DSL to reproduce this effect; for example: -c '.functionality.namespace := \"foo\"'.\nDocker & NXF: Attribute version is deprecated. Instead, the default value will be .functionality.version, which can be overridden by using the tag attribute.\nNXF: When running a viash component as a Nextflow module on its own, you now need to specify all input files on the command line. For instance, if --input and --reference are input file arguments, you need to start the process by running nextflow run main.nf --input <...> --reference <...> <other arguments>. Previously only the input file needed to be specified.\nDocker & NXF: Default separator between namespace and image name has been changed from \"/\" to \"_\"."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#minor-changes-19",
    "href": "bin/data/CHANGELOG.html#minor-changes-19",
    "title": "Viash",
    "section": "MINOR CHANGES",
    "text": "MINOR CHANGES\n\nDocker & NXF: Parsing of image attributes for both Docker and Nextflow platforms are better aligned. You can define an image by specifying either of the following:\n\n{ image: 'ubuntu:latest' }\n{ image: ubuntu, tag: latest }\n\nDocker & NXF: Allow changing the separator between a namespace and the image name."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#nextflow-refactoring",
    "href": "bin/data/CHANGELOG.html#nextflow-refactoring",
    "title": "Viash",
    "section": "NEXTFLOW REFACTORING",
    "text": "NEXTFLOW REFACTORING\nThe generation of Nextflow modules has been refactored thoroughly.\n\nNXF: The implicitly generated names for output files/directories have been improved leading to less clashes.\nNXF: Allow for multiple output files/directories from a module while keeping compatibility for single output. Please refer to the docs.\nNXF: Allow for zero input files by means of passing an empty list [] in the triplet\nNXF: Remove requirement for function_type: todir\nNXF: It is now possible to not only specify label: ... for a nextflow platform but also labels: [ ...]."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-22",
    "href": "bin/data/CHANGELOG.html#bug-fixes-22",
    "title": "Viash",
    "section": "BUG FIXES",
    "text": "BUG FIXES\n\nAllow quotes in functionality descriptions.\nNXF: Providing a default: ... value for output file arguments is no longer necessary."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#breaking-changes-12",
    "href": "bin/data/CHANGELOG.html#breaking-changes-12",
    "title": "Viash",
    "section": "BREAKING CHANGES",
    "text": "BREAKING CHANGES\n\nviash build: Do not automatically generate a viash.yaml when creating an executable. Instead, you need to add the -w|--write_meta flag in order to let viash know that it should generate a viash.yaml in the resources dir."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#major-changes-9",
    "href": "bin/data/CHANGELOG.html#major-changes-9",
    "title": "Viash",
    "section": "MAJOR CHANGES",
    "text": "MAJOR CHANGES\n\nNXF: Add beta functionality for running viash tests in Nextflow."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#minor-changes-20",
    "href": "bin/data/CHANGELOG.html#minor-changes-20",
    "title": "Viash",
    "section": "MINOR CHANGES",
    "text": "MINOR CHANGES\n\nResources: Rework the way resources paths are converted to absolute URIs, should not have any impact on UX."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-23",
    "href": "bin/data/CHANGELOG.html#bug-fixes-23",
    "title": "Viash",
    "section": "BUG FIXES",
    "text": "BUG FIXES\n\nNXF: Add temporary workaround for determining the used image name when running a component.\nDocker Platform: Set default setup strategy to “alwayscachedbuild” as this used to be the default viash behaviour.\nNXF: Fix issue where resource dir would not get mounted depending on which inputs are provided.\nNXF: Accept multiple inputs when component is running as standalone."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#new-features-5",
    "href": "bin/data/CHANGELOG.html#new-features-5",
    "title": "Viash",
    "section": "NEW FEATURES",
    "text": "NEW FEATURES\n\nFunctionality: Added list of authors field. Example:\nfunctionality:\n  authors:\n    - name: Bob Cando\n      roles: [maintainer, author]\n      email: bob@cando.com\n      props: {github: bobcando, orcid: XXXAAABBB}\nDocker: Allow specifying the registry with target_registry. Example:\n- type: docker\n  image: bash:4.0\n  target_registry: foo.io\n  target_image: bar\n  target_tag: 0.1\nDocker: version is now a synonym for target_tag. If both version and target_tag are not defined, functionality.version will be used instead.\nDocker: Can change the Docker Setup Strategy by specifying\n\nin the yaml: setup_strategy: xxx\non command-line: ---docker_setup_strategy xxx or ---dss xxx\n\nSupported values for the setup strategy are:\n\nalwaysbuild / build: build the image from the dockerfile (DEFAULT)\nalwayscachedbuild / cachedbuild: build the image from the dockerfile, with caching\nalwayspull / pull: pull the image from a registry\nalwayspullelsebuild / pullelsebuild: try to pull the image from a registry, else build it\nalwayspullelsecachedbuild / pullelsecachedbuild: try to pull the image from a registry, else build it with caching\nifneedbebuild: if the image does not exist locally, build the image\nifneedbecachedbuild: if the image does not exist locally, build the image with caching\nifneedbepull: if the image does not exist locally, pull the image\nifneedbepullelsebuild: if the image does not exist locally, pull the image else build it\nifneedbepullelsecachedbuild: if the image does not exist locally, pull the image else build it with caching\ndonothing / meh: do not build or pull anything"
  },
  {
    "objectID": "bin/data/CHANGELOG.html#major-changes-10",
    "href": "bin/data/CHANGELOG.html#major-changes-10",
    "title": "Viash",
    "section": "MAJOR CHANGES",
    "text": "MAJOR CHANGES\n\nLicense: viash is now licensed under GPL-3."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#minor-changes-21",
    "href": "bin/data/CHANGELOG.html#minor-changes-21",
    "title": "Viash",
    "section": "MINOR CHANGES",
    "text": "MINOR CHANGES\n\nCLI: Allow parameters before and after specifying a viash config yaml. For example, both following commands now work. Up until now, only the latter would work.\n\nviash run config.vsh.yaml -p docker\nviash run -p docker config.vsh.yaml\n\nFunctionality: Arguments field can now be omitted.\nScripts: Wrapped scripts now contain a minimal header at the top."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-24",
    "href": "bin/data/CHANGELOG.html#bug-fixes-24",
    "title": "Viash",
    "section": "BUG FIXES",
    "text": "BUG FIXES\n\nNXF viash build: Do not assume each config yaml has at least one test.\nScripts: Fix Docker chown failing when multiple outputs are defined (#21).\nJavaScriptRequirements: Fix type getting set to “python” when unparsing.\nviash run . ---debug: Debug session should now work again\nNative ---setup: Fix missing newlines when running native —setup commands.\nMain: Fix crashing when no arguments are supplied.\nNamespace: Show error message when the config file can’t be parsed.\nExecutable resource: Fix Docker automount handling for Executable resources."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#testing-4",
    "href": "bin/data/CHANGELOG.html#testing-4",
    "title": "Viash",
    "section": "TESTING",
    "text": "TESTING\n\nYAML: Test invertibility of parsing/unparsing config objects."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#breaking-changes-13",
    "href": "bin/data/CHANGELOG.html#breaking-changes-13",
    "title": "Viash",
    "section": "BREAKING CHANGES",
    "text": "BREAKING CHANGES\n\nFile format functionality.yaml is no longer supported. Use config.vsh.yaml or script.vsh.R/py/... instead.\nviash run and viash test: By default, temporary files are removed when the execution succeeded, otherwise they are kept. This behaviour can be overridden by specifying --keep true to always keep the temporary files, and --keep false to always remove them.\nNXF: function_type: todir now returns the output directory on the Channel rather than its contents."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#new-features-6",
    "href": "bin/data/CHANGELOG.html#new-features-6",
    "title": "Viash",
    "section": "NEW FEATURES",
    "text": "NEW FEATURES\n\nAdded viash ns test: Run all tests in a particular namespace. For each test, the exit code and duration is reported. Results can be written to a tsv file.\nAdded support for JavaScript scripts.\nAdded support for Scala scripts.\nNXF: publishing has a few more options:\n\npublish: Publish or yes (default is false)\nper_id: Publish results in directories containing the unique (sample) ID (default is true)\npath: A prefix path for the results to be published (default is empty)\n\nFunctionality resources and tests: Allow copying whole directories instead of only single files. Also allow to rename the destination folder by specifying a value for ‘dest’.\nPlatform R / Python dependencies: Allow running a simple command."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#major-changes-11",
    "href": "bin/data/CHANGELOG.html#major-changes-11",
    "title": "Viash",
    "section": "MAJOR CHANGES",
    "text": "MAJOR CHANGES\n\nThe -P <platform> parameter will be deprecated. For now, all -P values are simply passed to -p.\nviash ns build and viash ns test: Now use all available platforms if -p is not specified.\nBy default, python packages will not be installed as user. Use user: true to modify this behaviour."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#minor-changes-22",
    "href": "bin/data/CHANGELOG.html#minor-changes-22",
    "title": "Viash",
    "section": "MINOR CHANGES",
    "text": "MINOR CHANGES\n\nName of autogenerated Docker image is now ns/tool.\nInternal changes to make it easier to extend viash with more scripting languages.\nNXF: Default image is now ns/tool for consistency.\nNXF: Repurpose asis function type for having simple publishing steps (see docs).\nNXF: Add component name to main process name\nR dependencies: by default, do not reinstall Bioconductor packages. Set bioc_force_install: true to revert this behaviour."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-25",
    "href": "bin/data/CHANGELOG.html#bug-fixes-25",
    "title": "Viash",
    "section": "BUG FIXES",
    "text": "BUG FIXES\n\nviash build: Do not display error messages when pwd is not a git repository."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#testing-5",
    "href": "bin/data/CHANGELOG.html#testing-5",
    "title": "Viash",
    "section": "TESTING",
    "text": "TESTING\n\nviash test: Add tests for viash test functionality."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#minor-changes-23",
    "href": "bin/data/CHANGELOG.html#minor-changes-23",
    "title": "Viash",
    "section": "MINOR CHANGES",
    "text": "MINOR CHANGES\n\nAllow generating placeholder without VIASH START/VIASH END blocks."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-26",
    "href": "bin/data/CHANGELOG.html#bug-fixes-26",
    "title": "Viash",
    "section": "BUG FIXES",
    "text": "BUG FIXES\n\nviash ns build: Some platforms would sometimes not be detected.\nviash run: Avoid error when no arguments need to be chowned."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#docker-chown-by-default",
    "href": "bin/data/CHANGELOG.html#docker-chown-by-default",
    "title": "Viash",
    "section": "Docker chown by default",
    "text": "Docker chown by default\nRunning a script using a Docker platform will now chown output files by default, as well as any temporary files. You can turn off this feature by specifying chown: false in the yaml of a Docker platform."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#nxf-data-references",
    "href": "bin/data/CHANGELOG.html#nxf-data-references",
    "title": "Viash",
    "section": "[NXF] Data references",
    "text": "[NXF] Data references\nData references in Map form can now have values being lists. In other words, we can have multiple options which have one or more values."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#viash-ns-build--p-docker-parallel-setup",
    "href": "bin/data/CHANGELOG.html#viash-ns-build--p-docker-parallel-setup",
    "title": "Viash",
    "section": "viash ns build -P docker –parallel –setup",
    "text": "viash ns build -P docker –parallel –setup\nviash ns build has been greatly improved! You can automatically build the docker container by adding --setup to the command, as well as make the whole thing run in parallel using the --parallel or -l flag.\nTo build a docker container, you can run either of the following:\nviash run -f path/to/config.yaml -P docker -- ---setup\nviash build -f path/to/functionality.yaml -P docker -o target/docker/path/to --setup\nNote that the first will only build the docker container, whereas the second will build the executable and then build the docker container.\nTo build a lot of them all at once, run:\nviash ns build -P docker --parallel --setup"
  },
  {
    "objectID": "bin/data/CHANGELOG.html#custom-order-of-platform-requirements",
    "href": "bin/data/CHANGELOG.html#custom-order-of-platform-requirements",
    "title": "Viash",
    "section": "Custom order of platform requirements",
    "text": "Custom order of platform requirements\nYou can now choose the order in which platform requirements are installed!\nBefore:\ntype: docker\nimage: rocker/tidyverse\ntarget_image: \"viash_test/r\"\nr:\n  cran:\n  - optparse\n  github:\n  - dynverse/dynutils@devel\n  bioc:\n  - limma\napt:\n  packages:\n  - libhdf5-serial-dev\ndocker:\n  build_arg:\n  - GITHUB_PAT=\"$GITHUB_PAT\"\n  run:\n  - git clone --depth 1 https://github.com/data-intuitive/viash_docs.git && rm -r viash_docs/.git\n↑ in which order will these three components be run? Who knows!\nNow:\ntype: docker\nimage: rocker/tidyverse\ntarget_image: \"viash_test/r\"\nsetup:\n- type: docker\n  build_arg:\n  - GITHUB_PAT=\"$GITHUB_PAT\"\n- type: apt\n  packages:\n  - libhdf5-serial-dev\n- type: r\n  cran:\n  - optparse\n  - dynutils\n  github:\n  - rcannood/princurve@devel\n  bioc:\n  - limma\n- type: docker\n  run:\n  - git clone --depth 1 https://github.com/data-intuitive/viash_docs.git && rm -r viash_docs/.git\nThis will ensure that the setup instructions are installed in the given order."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#new-features-7",
    "href": "bin/data/CHANGELOG.html#new-features-7",
    "title": "Viash",
    "section": "NEW FEATURES",
    "text": "NEW FEATURES\n\nNXF: Data references in Map form can now have values being lists. In other words, we can have multiple options which have one or more values.\nviash ns build: Added –parallel and –setup flag.\nviash build: Added –setup flag.\nAllow changing the order of setup commands using the setup: variable.\n(HIDDEN) Do not escape ${VIASH_...} elements in default values and descriptions!"
  },
  {
    "objectID": "bin/data/CHANGELOG.html#minor-changes-24",
    "href": "bin/data/CHANGELOG.html#minor-changes-24",
    "title": "Viash",
    "section": "MINOR CHANGES",
    "text": "MINOR CHANGES\n\nRemove ---chown flag, move to platform.docker.chown; is set to true by default.\nPerform chown during both run and test using a Docker platform."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-27",
    "href": "bin/data/CHANGELOG.html#bug-fixes-27",
    "title": "Viash",
    "section": "BUG FIXES",
    "text": "BUG FIXES\n\nIssue trying to parse positional arguments even when none is provided."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#changes-to-functionality-metadata",
    "href": "bin/data/CHANGELOG.html#changes-to-functionality-metadata",
    "title": "Viash",
    "section": "Changes to functionality metadata",
    "text": "Changes to functionality metadata\n\nAdded version attribute\n\n\nAutoresolve docker paths\nArguments of type: file are processed to automatically create a mount in docker. More specifically, when you pass an argument value: --input /path/to/file, this will be processed such that the following parameters are passed to docker:\ndocker run -v /path/to:/viash_automount/path/to ... --input /viash_automount/path/to/file\nIf, for some reason, you need to manually specify a mount, you can do this with ---mount /path/to/mount:/mymount.\n\n\nArgument multiplicity\nFor all parameter types (except for boolean_true and boolean_false), you can specify multiple: true in order to turn this argument into an array-based argument. What this does is allow you to pass multiple values for this argument, e.g. --input file1 --input file2 --input file3:file4:file5.\nThe default separator is : but this can be overridden by changing the separator by setting it to multiple_sep: \",\" (for example).\n\n\nNew format\nViash now supports placing the functionality.yaml, platform*.yaml(s) and script into a single file. For example, this could be a merged script.R:\n#' functionality:\n#'   name: r-estimate\n#'   arguments: ...\n#' platforms:\n#' - type: native\n#' - type: docker\n#'   image: rocker/tidyverse\nlibrary(tidyverse)\ncat(\"Hello world!\\n\")\nInstead of running:\nviash run -f functionality.yaml -p platform_docker.yaml -- arg1\nWith this format, you can now run:\nviash run script.R                     # run script.R with the first platform\nviash run -P docker script.R           # run script.R with the platform called 'docker' with the large P argument\n# use small p to override the platform with a custom yaml:\nviash run -p common_resources/platform_docker.yaml script.R\n# note that any arguments for the run command (e.g. -p or -P) should come before the script.R, as script.R is considered a trailing argument."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#new-features-8",
    "href": "bin/data/CHANGELOG.html#new-features-8",
    "title": "Viash",
    "section": "NEW FEATURES",
    "text": "NEW FEATURES\n\nAllow (optional) version attributes in functionality.yaml and platform.yaml.\nAllow testing a component with the viash test functionality. Tests are executed in a temporary directory on the specified platform. The temporary directory contains all the resource and test files.\nviash --version: Add flag for printing the version of viash.\nAllow fetching resources from URL (http:// and https://)\nAllow retrieving functionality and platform YAMLs from URL.\nFor docker containers, autoresolve path names of files. Use ---v path:path or ---volume path:path to manually mount a specific folder.\nImplement parameter multiplicity. Set multiple: true to denote an argument to have higher multiplicity. Run ./cmd --foo one --foo two --foo three:four in order for multiple values to be added to the same parameter list.\nAdded a new format for defining functionality in which the user passes the script in which the functionality and platforms are listed as yaml headers.\nA ---chown flag has been added to Docker executables to automatically change the ownership of output files to the current user.\nviash ns build: A command for building a whole namespace.\nNXF: Join operations are now fully supported by means of multiple.\nNXF: Modules that perform joins can take either arrays (multiple input files or the same type to be joined) or hashes (multiple input files passed using different options on the CLI). Please refer to the docs for more info."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#major-changes-12",
    "href": "bin/data/CHANGELOG.html#major-changes-12",
    "title": "Viash",
    "section": "MAJOR CHANGES",
    "text": "MAJOR CHANGES\n\nRemove passthrough parameters.\nSince CLI generation is now performed in the outer script, viash pimp has been deprecated.\nWrite out meta.yaml containing viash run information as well as the original functionality.yaml and platform.yaml content.\nRenamed viash export to viash build."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#minor-changes-25",
    "href": "bin/data/CHANGELOG.html#minor-changes-25",
    "title": "Viash",
    "section": "MINOR CHANGES",
    "text": "MINOR CHANGES\n\nviash run and viash test: Allow changing the temporary directory by defining VIASH_TEMP as a environment variable. Temporary directories are cleaned up after successful executions.\nviash run and viash test: Exit(1) when execution or test fails.\nviash build: Add -m flag for outputting metadata after build.\nviash run: Required parameters can have a default value now. Produce error when a required parameter is not passed, even when a default is provided.\nNXF: Modules are now stored under target/nextflow by default"
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-28",
    "href": "bin/data/CHANGELOG.html#bug-fixes-28",
    "title": "Viash",
    "section": "BUG FIXES",
    "text": "BUG FIXES\n\nNXF: Correctly escape path variable when running NXF command.\nNXF: Surround parameters with quotes when running NXF command."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#internal-changes-3",
    "href": "bin/data/CHANGELOG.html#internal-changes-3",
    "title": "Viash",
    "section": "INTERNAL CHANGES",
    "text": "INTERNAL CHANGES\n\nMove CLI from inner script to outer script.\nRenamed Target to Platform\nRenamed Environment to Requirements"
  },
  {
    "objectID": "bin/data/CHANGELOG.html#changes-to-functionality.yaml",
    "href": "bin/data/CHANGELOG.html#changes-to-functionality.yaml",
    "title": "Viash",
    "section": "Changes to functionality.yaml",
    "text": "Changes to functionality.yaml\n\nftype has been renamed to function_type. The value for this field is also being checked.\nplatform has been removed.\nInstead, the first resource listed is expected to have type: r_script, type: bash_script, type: python_script, or type: executable. The other resources are expected to have type: file by default, and are left untouched by Viash.\nin the arguments, field flagValue has been removed. Instead, use type: boolean_true and type: boolean_false to achieve the same effect."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#changes-to-platform_dockernative.yaml",
    "href": "bin/data/CHANGELOG.html#changes-to-platform_dockernative.yaml",
    "title": "Viash",
    "section": "Changes to platform_(docker/native).yaml",
    "text": "Changes to platform_(docker/native).yaml\n\nThe r: packages: field has been renamed to r: cran:."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#major-changes-13",
    "href": "bin/data/CHANGELOG.html#major-changes-13",
    "title": "Viash",
    "section": "MAJOR CHANGES",
    "text": "MAJOR CHANGES\n\nRefactoring of the Functionality class as discussed in VIP1 (#1). This has resulted in a lot of internal changes, but the changes with regard to the yaml definitions are relatively minor. See the section below for more info."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#minor-changes-26",
    "href": "bin/data/CHANGELOG.html#minor-changes-26",
    "title": "Viash",
    "section": "MINOR CHANGES",
    "text": "MINOR CHANGES\n\nUpdated the functionality.yamls under atoms/ and src/test/ to reflect these aforementioned changes.\nAllow for bioconductor and other repositories in the R environment.\nAdd support for pip versioning syntax."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#bug-fixes-29",
    "href": "bin/data/CHANGELOG.html#bug-fixes-29",
    "title": "Viash",
    "section": "BUG FIXES",
    "text": "BUG FIXES\n\nDo not quote passthrough flags.\nAllow for spaces inside of Docker volume paths."
  },
  {
    "objectID": "bin/data/CHANGELOG.html#documentation-1",
    "href": "bin/data/CHANGELOG.html#documentation-1",
    "title": "Viash",
    "section": "DOCUMENTATION",
    "text": "DOCUMENTATION\n\nUpdated the README.md.\nProvide some small examples at doc/examples."
  }
]