---
title: Building an executable
search: true
engine: knitr
---

{{< include ../../includes/_language_chooser.qmd >}}


The following sections discuss how a Viash component can be turned into an executable and how they work.

## Building an executable

We continue with the executables created in the previous section.

<!-- todo: fix urls so that they automatically point to the right branch / to a viash.io url -->

::: {.panel-tabset}

```{r echo=FALSE, output="asis"}
library(purrr)
library(tibble)

root_url <- "https://raw.githubusercontent.com/viash-io/website/issue_9/src/guide/viash_component"
repo_path <- system("git rev-parse --show-toplevel", intern = TRUE)

# download one file to check whether the url is working
download.file(
  paste0(root_url, "/my_copy_bash/config.vsh.yaml"),
  "tmp/check_url.txt"
)
# if (!file.exists("tmp/check_url.txt")) stop("URL does not work")

# construct language tibble
langs <- tribble(
  ~id, ~label, ~script,
  "bash", "Bash", "script.sh",
  "csharp", "C\\#", "script.csx",
  "js", "JavaScript", "script.js",
  "python", "Python", "script.py",
  "scala", "Scala", "script.scala",
  "r", "R", "script.R"
)

quo <- "```"

run_cmd <- function(command, args = character(), wd = NULL) {
  # run tree
  cmd_out <- processx::run(
    command = command,
    args = args,
    wd = wd
  )
  out_indented <- 
    strsplit(cmd_out$stdout, "\n")[[1]] %>% 
    paste0("    ", .) %>%
    paste(., collapse = "\n")
  
  paste0(
    quo, "bash\n",
    command, " ", paste(args, collapse = " "), "\n",
    quo, "\n",
    "\n",
    out_indented, "\n"
  )
}

pwalk(langs, function(id, label, script) {
  cat("## ", label, "\n")

  # create dir
  dir.create(paste0("tmp/", id), recursive = TRUE)

  # download files
  # root_url <- paste0(root_url, "/my_copy_", id)
  # download.file(paste0(root_url, "/config.vsh.yaml"), paste0("tmp/", id, "/config.vsh.yaml"))
  # download.file(paste0(root_url, "/", script), paste0("tmp/", id, "/", script))

  # edit: just copy them
  file.copy(
    paste0(repo_path, "/src/guide/viash_component/my_copy_", id, "/config.vsh.yaml"),
    paste0("tmp/", id, "/config.vsh.yaml")
  )
  file.copy(
    paste0(repo_path, "/src/guide/viash_component/my_copy_", id, "/", script),
    paste0("tmp/", id, "/", script)
  )

  # run viash build
  processx::run(
    "viash",
    args = c(
      "build", 
      paste0("tmp/", id, "/config.vsh.yaml"),
      "--output",
      paste0("tmp/", id, "/target")
    ) 
  )

  # run tree
  tree_out <- run_cmd(
    command = "tree",
    wd = paste0("tmp/", id, "/")
  )

  # generate markdown
  md <- glue::glue("
If you deleted them, you can download them by running the following commands in a Bash terminal:

{quo}bash
root_url=\"{root_url}/my_copy_{id}\"

wget \"$root_url/config.vsh.yaml\" -q -O \"config.vsh.yaml\"
wget \"$root_url/{script}\" -q -O \"{script}\"
{quo}

Next, use the [viash build](/reference/viash/build.qmd) command to generate an executable inside of a `target/` directory:

{quo}bash
viash build \"config.vsh.yaml\" --output \"target\"
{quo}

This will generate an executable in the `target` directory:

{tree_out}

")
  cat(md)
})
```

:::


## Documentation

It's often useful to know what arguments an executable expects before trying to run it.


::: {.panel-tabset}

```{r echo=FALSE, output="asis"}

pwalk(langs, function(id, label, script) {
  cat("## ", label, "\n")

  help_out <- run_cmd(
    command = paste0("target/my_copy_", id),
    args = c("--help"),
    wd = paste0("tmp/", id)
  )

  # generate markdown
  md <- glue::glue("
To display its documentation, run the executable with just the `--help` argument:

{help_out}

")
  cat(md)
})
```

:::


```bash
bin/hello_world --help
```

This will result in output that looks like this:

```
hello_world

A minimal example component.

Options:
    --input
        type: string
        default: World
```

This example takes a single optional string named `--input` as an argument. 

## Running the executable

Running a native executable is the same as any other executable on your system. Simply call it as a command in your terminal:

```bash
bin/hello_world
```

This results in the following output:

```
Hello World
```

You can pass arguments to it directly, which differs from using the [viash run](/guide/component/creation/native.html#running) command as Viash itself isn't called:

```bash
bin/hello_world --input "everyone!"
```

This outputs:

```
Hello everyone!
```

This guide covers how you can can build and run an executable with a Docker backend. Most of what is covered in the [Native Executable](/guide/building-block/native-building-running.html) guide is true for executables with a Docker backend.

## Building the executable

If you have multiple platforms defined in your Viash config file, use the `--platform` argument of [`viash build`](/reference/viash/build.html) to specify you want to create an executable with a Docker backend.

```bash
viash build config.vsh.yaml --platform docker --output bin
```   

## Running the executable

You can run the executable by executing it as a command:

```bash
bin/hello_world
```

Executable with a Docker backend include functions to create a Docker image and a container based on your Viash config file. When you run the executable for the first time, both the image and container will built, followed by running the executable inside of the container:

```
[notice] Checking if Docker image is available at 'hello_world:latest'
[warning] Could not pull from 'hello_world:latest'. Docker image doesn't exist or is not accessible.
[notice] Building container 'hello_world:latest' with Dockerfile
Hello World
```

If you already have the container on your system, that will be used to run the executable:

```
Hello World
```


<!--I would also take sections "Using Viash placeholder variables" and "Executing scripts" from guide/component/languages.qmd to explain that if they include a viash codeblock in their script, they can edit / run the script natively for development / debugging purposes.-->

## What's next?

Now you know how to build and run executables with a Docker backend, you may be interested in [building and running Nextflow modules](/guide/building-block/nextflow/building-running.html).  
<!-- If you prefer to use executables in a simple pipeline, check out the  [Scripted Pipeline](/guide/data-workflow/scripted-pipeline.html) guide.  -->



```{r include=FALSE}
unlink("tmp", recursive = TRUE)
```