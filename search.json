[
  {
    "objectID": "download/components/md_url_checker/bash/Testfile.html",
    "href": "download/components/md_url_checker/bash/Testfile.html",
    "title": "Viash",
    "section": "",
    "text": "This is a simple markdown file with some hyperlinks to test if the check_if_URLS_reachable component works correctly. Some links to websites:\n\nGoogle\nReddit\nA broken link\n\nLinks that are relative to viash.io:\n\nYou can install viash here.\nIt all starts with a script and a config file for your components."
  },
  {
    "objectID": "documentation/guide/building-block/nextflow/building-running.html",
    "href": "documentation/guide/building-block/nextflow/building-running.html",
    "title": "Building and Running",
    "section": "",
    "text": "This guide covers how you can can build a Nextflow module to use in your pipeline."
  },
  {
    "objectID": "documentation/guide/building-block/nextflow/building-running.html#building-a-nextflow-vdsl3-module",
    "href": "documentation/guide/building-block/nextflow/building-running.html#building-a-nextflow-vdsl3-module",
    "title": "Building and Running",
    "section": "Building a Nextflow VDSL3 module",
    "text": "Building a Nextflow VDSL3 module\nTo start with, create a Viash component that targets the Nextflow platform as explained in this guide.\nNext, use the viash build command to generate a Nextflow module inside of a target/remove_comments directory:\nviash build src/remove_comments/config.vsh.yaml -o target/remove_comments\nThis will generate two files in the target/remove_comments directory: main.nf and nextflow.config.\nnextflow_component\n├── src\n│   └── remove_comments\n│       ├── config.vsh.yaml\n│       └── script.sh\n└── target\n    └── remove_comments\n        ├── main.nf\n        └── nextflow.config"
  },
  {
    "objectID": "documentation/guide/building-block/nextflow/building-running.html#runing-a-standalone-pipeline",
    "href": "documentation/guide/building-block/nextflow/building-running.html#runing-a-standalone-pipeline",
    "title": "Building and Running",
    "section": "Runing a standalone pipeline",
    "text": "Runing a standalone pipeline\nA VDSL3 module can be run as a small, standalone Nextflow pipeline.\n\nDocumentation\nIt’s often useful to know what arguments a module expects before trying to run it. To display the documentation for a module, run the module with just the --help argument:\nnextflow run target/remove_comments/main.nf --help\nThis will result in output that looks similar to this:\nN E X T F L O W  ~  version 22.04.3\nLaunching `target/remove_comments/main.nf` [admiring_carlsson] DSL2 - revision: 8de4c7c8eb\nremove_comments\n\nOptions:\n    --input\n        type: file, required parameter\n        example: file.tsv\n\n    --output\n        type: file, required parameter, output\n        example: file.tsv\nAs you can see, this module needs a tsv file as its input and it will write the updated file away to a given output path.\n\n\nRunning the module\nTo test out the module by itself, you need a tsv file to remove the comments from. You can download a sample file we provided here:\n\nDownload sample.tsv\nHere are its contents:\n# this is a header      \n# this is also a header     \none     0.11    123\ntwo     0.23    456\nthree   0.35    789\nfour    0.47    123\nPlace sample.tsv file in a new directory named data, alongside the src and target directories.\nnextflow_component\n├── data\n│   └── sample.tsv\n├── src\n│   └── remove_comments\n│       ├── config.vsh.yaml\n│       └── script.sh\n└── target\n    └── remove_comments\n        ├── main.nf\n        └── nextflow.config\nNow run the module along with the required arguments:\nnextflow run target/remove_comments/main.nf \\\n   --input \"data/sample.tsv\" \\\n   --publishDir output\nBelow is the result:\nN E X T F L O W  ~  version 22.04.3\nLaunching `target/remove_comments/main.nf` [desperate_fermat] DSL2 - revision: 8de4c7c8eb\nWARN: Key for module 'remove_comments' is duplicated.\n\nexecutor >  local (1)\n[2b/17d7a5] process > remove_comments:remove_comments_process1 [100%] 1 of 1 ✔\ninput: [run, [input:/home/user/nextflow_component/data/sample.tsv]]\noutput: [run, /home/user/nextflow_component/work/2b/17d7a50e74d27bc8fd39f098ba06fc/run.remove_comments.output.tsv]\nA new tsv file should’ve been generated now in the output folder named run.remove_comments.output.tsv."
  },
  {
    "objectID": "documentation/guide/building-block/nextflow/building-running.html#whats-next",
    "href": "documentation/guide/building-block/nextflow/building-running.html#whats-next",
    "title": "Building and Running",
    "section": "What’s next?",
    "text": "What’s next?\nto use generated modules inside an actual Nextflow pipeline, see Pipeline Basics"
  },
  {
    "objectID": "documentation/guide/component/creation/nextflow.html",
    "href": "documentation/guide/component/creation/nextflow.html",
    "title": "Nextflow",
    "section": "",
    "text": "When targeting the nextflow platform, a NextFlow module is generated that can run standalone or used in a pipeline."
  },
  {
    "objectID": "documentation/guide/component/creation/nextflow.html#requirements",
    "href": "documentation/guide/component/creation/nextflow.html#requirements",
    "title": "Nextflow",
    "section": "Requirements",
    "text": "Requirements\nThis example targets the Nextflow platform, which requires you to install Nextflow and Docker. Follow the instructions on NextFlow’s homepage to install it on your system if you haven’t done so already. You can find instructions on how to install Docker for your OS on the Viash installation page."
  },
  {
    "objectID": "documentation/guide/component/creation/nextflow.html#creating-a-viash-component",
    "href": "documentation/guide/component/creation/nextflow.html#creating-a-viash-component",
    "title": "Nextflow",
    "section": "Creating a Viash component",
    "text": "Creating a Viash component\nTo start off, create a folder named nextflow_component and create a src folder inside of it. Next, add another folder inside of the src folder and name it remove_comments. This is where the component will be placed, a minimal example that uses a bash script to remove comments from a TSV file.\nThe directory structure should look like this:\nnextflow_component\n└── src\n    └── remove_comments\n\nWriting the script\nAdd the following small script to the remove_comments folder:\n#!/bin/bash\n\ngrep -v '^#' \"$par_input\" > \"$par_output\"\nAs mentioned above, this script removes comments from a TSV file. It does so by removing all lines that start with a hashtag (#) from an input file and writing the result to the output.\n\n\n\n\n\n\nTip\n\n\n\nEvery scripting language has its own way of using variables generated by Viash. Check out the Bash page for more information and examples.\n\n\n\n\nAdding the config\nA Viash config file is a YAML file that describes the functionality of a component and the platform(s) it targets. Create a file name config.vsh.yaml inside of the remove_comments folder and add the contents below.\nDownload config.vsh.yaml\nfunctionality:\n  name: remove_comments\n  description: Remove comments from a TSV file.\n  namespace: nextflow_modules\n  arguments:\n    - name: \"--input\"\n      alternatives: [ \"-i\" ]\n      type: file\n      required: true\n      example: \"file.tsv\"\n    - name: \"--output\"\n      alternatives: [ \"-o\" ]\n      type: file\n      required: true\n      direction: output\n      example: \"file.tsv\"\n  resources:\n  - type: bash_script\n    path: ./script.sh\nplatforms:\n  - type: nextflow\n    variant: vdsl3\n    directives:\n      container: ubuntu:20.04\nHere’s a breakdown of the different sections:\n\nfunctionality\nThis section describes what the component does and the resources it needs. It contains the name, a short description and more importantly, the arguments and resources the component uses. This component is part of a namespace named nextflow_modules, which we’ll explore further in the pipeline guides.\n\n\narguments\nThe arguments section contains all arguments the component accepts and will be passed to the script. In this case, an input and an output file path argument that are both required.\n\n\nresources\nAll references to the necessary files and folders to make the component work are added to this section. For this example, a single script is all that’s needed.\n\n\nplatforms\nThis lists what platforms the component can target. For this example, the only platform is nextflow.\n\nThe variant property can be used to choose between our legacy NextFlow implementation or the next-generation VDSL3 variant. The latter is recommended as it has a lot of features to make creating modules more streamlined. You can read more about VDSL3 in our guide.\nThe directives dictionary contains optional settings that affect the execution of the module. For this example, a single directive is used: container. The container is the base Docker image that should be used to run the module.\n\n\n\n\n\n\n\nTip\n\n\n\nIf you specify a Docker platform in addition to NextFlow, the image in the docker platform section will be automatically used for NextFlow as well:\nplatforms:\n  - type: docker\n    image: ubuntu:20.04\n  - type: nextflow\n    variant: vdsl3\n\n\nWith the script and config added, the final directory should now look like this:\nnextflow_component\n└── src\n    └── remove_comments\n        ├── config.vsh.yaml\n        └── script.sh\n\n\n\nRunning\nIn contrast to native and Docker based components, a Nextflow based component cannot be ran by using the viash run command. These types of components require you to use viash build first to generate a Nextflow module and run that module using nextflow run. See Building and Running Nextflow for more information and an example of how to run a NextFlow module as a standalone pipeline."
  },
  {
    "objectID": "documentation/guide/component/creation/native.html",
    "href": "documentation/guide/component/creation/native.html",
    "title": "Native",
    "section": "",
    "text": "A Viash component can target one or more platforms. When targetting the native platform, a single executable is generated."
  },
  {
    "objectID": "documentation/guide/component/creation/native.html#requirements",
    "href": "documentation/guide/component/creation/native.html#requirements",
    "title": "Native",
    "section": "Requirements",
    "text": "Requirements\nThe example targets the Native platform, which means you will need to have the required packages installed on your system depending on your chosen scripting language. If you are using any of the languages on your system, there’s a good chance you already meet the requirements. To get up and running quickly, we recommend using Bash.\n\nBashC#JavaScriptPythonScalaR\n\n\n\nA Bash Unix shell (built into Linux, macOS and WSL2)\n\n\n\n\nA Bash Unix shell (built into Linux, macOS and WSL2)\nDownload and install .NET Core.\nRun dotnet tool install -g dotnet-script to enable the C# scripting functionality.\n\n\n\n\nA Bash Unix shell (built into Linux, macOS and WSL2)\nDownload and install Node.js.\nExecute the following command to install the required npm packages: npm install --save needle markdown-link-extractor\n\n\n\n\nA Bash Unix shell (built into Linux, macOS and WSL2)\nInstall Python 3.8 or newer. You may have to install the python-is-python3 package on Ubuntu and its derivatives.\n\n\n\n\nA Bash Unix shell (built into Linux, macOS and WSL2)\nInstall Scala 2.\n\n\n\n\nA Bash Unix shell (built into Linux, macOS and WSL2)\nInstall the R software environment"
  },
  {
    "objectID": "documentation/guide/component/creation/native.html#creating-the-viash-component",
    "href": "documentation/guide/component/creation/native.html#creating-the-viash-component",
    "title": "Native",
    "section": "Creating the Viash component",
    "text": "Creating the Viash component\n\nWriting the script\nFor this example, you’ll use a tiny script that simply outputs “Hello Viash”, with the “Viash” part being a variable. To start off, create a folder named hello_viash and follow the instructions below based on your preferred scripting language.\n\nBashC#JavaScriptPythonScalaR\n\n\nCreate a new file named script.sh and copy the following content inside of it:\necho \"Hello $par_input\"\nThis outputs Hello to the console, followed by an input variable. Notice that this variable isn’t defined in the script itself as Viash will generate it for you based on the config file you’ll create in the next step.\n\n\n\n\n\n\nTip\n\n\n\nEvery scripting language has its own way of using variables generated by Viash. Check out the Bash page for more information and examples.\n\n\n\n\nCreate script.csx\nConsole.WriteLine(\"Hello \" + par.input);\nThis outputs Hello to the console, followed by an input variable. Notice that this variable isn’t defined in the script itself as Viash will generate it for you based on the config file you’ll create in the next step.\n\n\n\n\n\n\nTip\n\n\n\nEvery scripting language has its own way of using variables generated by Viash. Check out the C# page for more information and examples.\n\n\n\n\nCreate script.js\nconsole.log('Hello' + par['input']);\nThis outputs Hello to the console, followed by an input variable. Notice that this variable isn’t defined in the script itself as Viash will generate it for you based on the config file you’ll create in the next step.\n\n\n\n\n\n\nTip\n\n\n\nEvery scripting language has its own way of using variables generated by Viash. Check out the JavaScript page for more information and examples.\n\n\n\n\nCreate script.py\nprint(\"Hello\", par[\"input\"])\nThis outputs Hello to the console, followed by an input variable. Notice that this variable isn’t defined in the script itself as Viash will generate it for you based on the config file you’ll create in the next step.\n\n\n\n\n\n\nTip\n\n\n\nEvery scripting language has its own way of using variables generated by Viash. Check out the Python page for more information and examples.\n\n\n\n\nCreate script.scala\nprintln(\"Hello \" + par.input.get)\nThis outputs Hello to the console, followed by an input variable. Notice that this variable isn’t defined in the script itself as Viash will generate it for you based on the config file you’ll create in the next step.\n\n\n\n\n\n\nTip\n\n\n\nEvery scripting language has its own way of using variables generated by Viash. Check out the Scala page for more information and examples.\n\n\n\n\nCreate script.R\ncat(\"Hello \", par$input)\nThis outputs Hello to the console, followed by an input variable. Notice that this variable isn’t defined in the script itself as Viash will generate it for you based on the config file you’ll create in the next step.\n\n\n\n\n\n\nTip\n\n\n\nEvery scripting language has its own way of using variables generated by Viash. Check out the R page for more information and examples.\n\n\n\n\n\n\n\nAdding the config\nA Viash config file is a YAML file that describes the functionality of a component and the platform(s) it targets. Create a file name config.vsh.yaml and add the contents below based on your chosen scripting language.\n\nBashC#JavaScriptPythonScalaR\n\n\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: bash_script\n    path: script.sh\nplatforms:\n  - type: native\n\n\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: csharp_script\n    path: script.csx\nplatforms:\n  - type: native\n\n\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: javascript_script\n    path: script.js\nplatforms:\n  - type: native\n\n\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: python_script\n    path: script.py\nplatforms:\n  - type: native\n\n\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: scala_script\n    path: script.scala\nplatforms:\n  - type: native\n\n\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: r_script\n    path: script.R\nplatforms:\n  - type: native\n\n\n\nHere’s a breakdown of the different sections:\n\nfunctionality describes what the component does and the resources it needs. It contains the name, a short description and more importantly, the arguments and resources the component uses.\n\narguments contains all arguments the component accepts and will be passed to the script. In this case, a single string named --input resides here with a default value of Viash.\nresources holds references to all necessary files and folders to make the component work. For this example, a single script is all that’s needed.\n\nplatforms lists what platforms the component can target. This example targets the native platform, which will generate an executable that’s run using the system resources.\n\n\n\nRunning\nWith the two necessary files present to create a component, you can call upon Viash to generate a temporary executable and run it:\nviash run config.vsh.yaml\nWithout passing any arguments, this will use the default value for --input, which is Viash. This results in the following output:\nHello Viash\nBy providing the a value for --input, you can customize the greeting:\nviash run config.vsh.yaml -- --input World\n\n\n\n\n\n\nNote\n\n\n\nThe double dash (--) between the viash command and the arguments is used to signify the end of the arguments passed to viash and the start of those passed to the component. If you forgot to add these, you’ll get an error similar to this:\n[scallop] Error: Unknown option 'input'\n\n\nThe example above results in this output:\nHello World"
  },
  {
    "objectID": "documentation/guide/component/creation/native.html#whats-next",
    "href": "documentation/guide/component/creation/native.html#whats-next",
    "title": "Native",
    "section": "What’s next?",
    "text": "What’s next?\nTo learn how to use Viash to build an executable and run it, see Native Executable Building and Running."
  },
  {
    "objectID": "documentation/guide/component/creation/docker.html",
    "href": "documentation/guide/component/creation/docker.html",
    "title": "Docker",
    "section": "",
    "text": "When targetting the docker platform, a single executable is generated that will build and run a docker container."
  },
  {
    "objectID": "documentation/guide/component/creation/docker.html#requirements",
    "href": "documentation/guide/component/creation/docker.html#requirements",
    "title": "Docker",
    "section": "Requirements",
    "text": "Requirements\nAs this example targets the Docker platform, the only requirement is to have Docker installed on your system. This is one of the biggest benefits of targeting the Docker platform. You can find instructions on how to install Docker for your OS on the Viash installation page."
  },
  {
    "objectID": "documentation/guide/component/creation/docker.html#creating-the-viash-component",
    "href": "documentation/guide/component/creation/docker.html#creating-the-viash-component",
    "title": "Docker",
    "section": "Creating the Viash component",
    "text": "Creating the Viash component\n\nWriting the script\nFor this example, you’ll use the same tiny script the native guide uses. It simply outputs “Hello Viash”, with the “Viash” part being a variable. To start off, create a folder named hello_viash_docker and follow the instructions below based on your preferred scripting language.\n\nBashC#JavaScriptPythonScalaR\n\n\nCreate a new file named script.sh and copy the following content inside of it:\necho \"Hello $par_input\"\nThis outputs Hello to the console, followed by an input variable. Notice that this variable isn’t defined in the script itself as Viash will generate it for you based on the config file you’ll create in the next step.\n\n\n\n\n\n\nTip\n\n\n\nEvery scripting language has its own way of using variables generated by Viash. Check out the Bash page for more information and examples.\n\n\n\n\nCreate script.csx\nConsole.WriteLine(\"Hello \" + par.input);\nThis outputs Hello to the console, followed by an input variable. Notice that this variable isn’t defined in the script itself as Viash will generate it for you based on the config file you’ll create in the next step.\n\n\n\n\n\n\nTip\n\n\n\nEvery scripting language has its own way of using variables generated by Viash. Check out the C# page for more information and examples.\n\n\n\n\nCreate script.js\nconsole.log('Hello' + par['input']);\nThis outputs Hello to the console, followed by an input variable. Notice that this variable isn’t defined in the script itself as Viash will generate it for you based on the config file you’ll create in the next step.\n\n\n\n\n\n\nTip\n\n\n\nEvery scripting language has its own way of using variables generated by Viash. Check out the JavaScript page for more information and examples.\n\n\n\n\nCreate script.py\nprint(\"Hello\", par[\"input\"])\nThis outputs Hello to the console, followed by an input variable. Notice that this variable isn’t defined in the script itself as Viash will generate it for you based on the config file you’ll create in the next step.\n\n\n\n\n\n\nTip\n\n\n\nEvery scripting language has its own way of using variables generated by Viash. Check out the Python page for more information and examples.\n\n\n\n\nCreate script.scala\nprintln(\"Hello \" + par.input.get)\nThis outputs Hello to the console, followed by an input variable. Notice that this variable isn’t defined in the script itself as Viash will generate it for you based on the config file you’ll create in the next step.\n\n\n\n\n\n\nTip\n\n\n\nEvery scripting language has its own way of using variables generated by Viash. Check out the Scala page for more information and examples.\n\n\n\n\nCreate script.R\ncat(\"Hello \", par$input)\nThis outputs Hello to the console, followed by an input variable. Notice that this variable isn’t defined in the script itself as Viash will generate it for you based on the config file you’ll create in the next step.\n\n\n\n\n\n\nTip\n\n\n\nEvery scripting language has its own way of using variables generated by Viash. Check out the R page for more information and examples.\n\n\n\n\n\n\n\nAdding the config\nA Viash config file is a YAML file that describes the functionality of a component and the platform(s) it targets. Create a file name config.vsh.yaml and add the contents below based on your chosen scripting language.\n\nBashC#JavaScriptPythonScalaR\n\n\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: bash_script\n    path: script.sh\nplatforms:\n  - type: native\n  - type: docker\n    image: bash:4.0\n\n\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: csharp_script\n    path: script.csx\nplatforms:\n  - type: native\n  - type: docker\n    image: \"dataintuitive/dotnet-script:1.2.1\"\n    setup:\n      - type: apk\n        packages: [ bash ]\n\n\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: javascript_script\n    path: script.js\nplatforms:\n  - type: native\n  - type: docker\n    image: node:15-buster\n\n\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: python_script\n    path: script.py\nplatforms:\n  - type: native\n  - type: docker\n    image: \"python:3.8\"\n\n\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: scala_script\n    path: script.scala\nplatforms:\n  - type: native\n  - type: docker\n    image: hseeberger/scala-sbt\n\n\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: r_script\n    path: script.R\nplatforms:\n  - type: native\n  - type: docker\n    image: \"rocker/tidyverse:4.0.4\"\n\n\n\nHere’s a breakdown of the different sections:\n\nfunctionality describes what the component does and the resources it needs. It contains the name, a short description and more importantly, the arguments and resources the component uses.\n\narguments contains all arguments the component accepts and will be passed to the script. In this case, a single string named --input resides here with a default value of Viash.\nresources holds references to all necessary files and folders to make the component work. For this example, a single script is all that’s needed.\n\nplatforms lists what platforms the component can target.\n\nThe platforms list in the example contains two target platforms, native and docker. The docker platform has an image property that points to a Docker image from Docker Hub to use as a base. Depending on the language, a setup might be included that will install additional packages in the final image.\n\n\n\n\n\n\nNote\n\n\n\nWhen building your own components that only target Docker or Nextflow, adding the native target platform isn’t necessary.\n\n\n\n\nRunning\nWith the two necessary files present to create a component, you can call upon Viash to generate a temporary executable and run it:\nviash run config.vsh.yaml -platform docker\nThe -platform argument is passed to viash run so Docker will be chosen as the build target. If the platform isn’t specified, the first one in the platforms list is picked.\nNo arguments are passed to the component, so it will use the default value for --input, which is Viash. This results in the following output:\n[notice] Checking if Docker image is available at 'hello_viash:latest'\n[warning] Could not pull from 'hello_viash:latest'. Docker image doesn't exist or is not accessible.\n[notice] Building container 'hello_viash:latest' with Dockerfile\nHello Viash\nAs you can see, Viash checks first if an image has been generated before continuing. If the image already exists, Viash will run a contained based on the image. In this case, no image was found for this component, so Viash generates the image before building and running the container.\nBy providing the a value for --input, you can customize the greeting:\nviash run config.vsh.yaml -- --input World\n\n\n\n\n\n\nNote\n\n\n\nThe double dash (--) between the viash command and the arguments is used to signify the end of the arguments passed to viash and the start of those passed to the component. If you forgot to add these, you’ll get an error similar to this:\n[scallop] Error: Unknown option 'input'\n\n\nThe example above results in this output:\nHello World"
  },
  {
    "objectID": "documentation/guide/component/creation/docker.html#whats-next",
    "href": "documentation/guide/component/creation/docker.html#whats-next",
    "title": "Docker",
    "section": "What’s next?",
    "text": "What’s next?\nTo learn how to use Viash to build an executable and run it, see Native Executable Building and Running."
  },
  {
    "objectID": "documentation/guide/component/unit-testing.html",
    "href": "documentation/guide/component/unit-testing.html",
    "title": "Unit Testing",
    "section": "",
    "text": "To ensure that your components and namespaces works as expected during its development cycle, writing one or more tests is essential.\nViash supports unit testing, which is a software testing method by which individual units of source code are tested to determine whether they output data as expected."
  },
  {
    "objectID": "documentation/guide/component/unit-testing.html#unit-testing-a-single-component",
    "href": "documentation/guide/component/unit-testing.html#unit-testing-a-single-component",
    "title": "Unit Testing",
    "section": "Unit testing a single component",
    "text": "Unit testing a single component\nTo write a unit test for a component, you need two things: a definition in the config file and a script that runs the executable and verifies its output.\nThis tutorial uses a sample component named md_url_checker to explain how to write a unit test for Viash. To follow along, create a new folder named “testing” on your machine, download the files below and move them to the folder you just created.\nDownload Testfile.md\nDownload config.vsh.yaml\nDownload script.sh\n\nConfiguration\nTo get started, open up config.vsh.yaml file and take a look at the end of the functionality dictionary, between the path: script.sh and platforms: lines:\n  test_resources:\n  - type: bash_script\n    path: test.sh\n  - path: Testfile.md\nThe tests dictionary contains a reference to a test script and all of the files that need to be copied over in order to complete a test:\n\nThe type signifies what scripting language is used for performing the unit test, which doesn’t need to be the same language as the main script. The path points to the test script.\nEvery file path added straight into the tests dictionary will be copied over next to the temporary test directory. Any files that are necessary for the test to work correctly can be added here.\n\nIn the case of this example, test.sh will be the test script and Testfile.md is necessary as an input markdown file for the script to function.\n\n\nTest script\nTo write the test itself, create a new file named test.sh in the testing folder and add this as its content:\nset -ex # Exit the script when one of the checks fail. Output all commands.\n\n# Check 1\necho \">>> Checking whether output is correct\"\n\n# Run md_url_checker component with its required inputs and output the results to test-output.txt\n\"./$meta_functionality_name\" --inputfile Testfile.md > test-output.txt\n\n[[ ! -f test-output.txt ]] && echo \"Test output file could not be found!\" && exit 1 # Check if test-output.txt exists\ngrep -q '1: https://www.google.com' test-output.txt # Did the script find the URL?\ngrep -q 'HTTP/2 404' test-output.txt  # Did the web request return a 404 for the page that doesn't exist?\n\n# Check 2\necho \">>> Checking whether an output file was created correctly\"\n\n[[ ! -f output.txt ]] && echo \"Output file could not be found!\" && exit 1 # Check if output.txt exists\ngrep -q 'URL: https://www.google.com' output.txt # Was the URL written correctly in the report?\ngrep -q 'Status: ERROR! URL cannot be reached. Status code: HTTP/2 404' output.txt # Was the error written correctly in the report?\ngrep -q 'Link name: install viash here' output.txt # Was link name written correctly in the report?\n\necho \">>> Test finished successfully!\"\nexit 0 # Exit with a 0 code to note a success \n\n\n\n\n\n\nTip\n\n\n\nAs you can see above, you can use the meta variable $meta_functionality_name to automatically get the name of the component (and the generated executable). This way, you can more reuse parts of your test scripts.\n\n\n\n\n\n\n\n\nTip\n\n\n\nThis script uses grep to search for files and strings. Make sure to read the comments to understand what is happening.\n\n\nThe bash script above is just a minimal example of how you can write a test. You can use any of the supported languages and your favorite testing framework if that’s your preference. The most important part is the last line, which uses a 0 exit code to signal a success.\n\n\nRunning a test\nTo run all tests defined in a config file, use the viash test command:\nviash test config.vsh.yaml\nViash will now automatically build an executable and place it alongside the other defined resources in a temporary working directory. The output should look like this:\nRunning tests in temporary directory: '/tmp/viash_test_md_url_checker5828773777380597444'\n====================================================================\n+/tmp/viash_test_md_url_checker5828773777380597444/build_executable/md_url_checker ---setup\n====================================================================\n+/tmp/viash_test_md_url_checker5828773777380597444/test_test.sh/test.sh\n>>> Checking whether output is correct\n+ echo '>>> Checking whether output is correct'\n+ ./md_url_checker --inputfile Testfile.md\n+ [[ ! -f test-output.txt ]]\n+ grep -q '1: https://www.google.com' test-output.txt\n+ grep -q 'HTTP/2 404' test-output.txt\n>>> Checking whether an output file was created correctly\n+ echo '>>> Checking whether an output file was created correctly'\n+ [[ ! -f output.txt ]]\n+ grep -q 'URL: https://www.google.com' output.txt\n+ grep -q 'Status: ERROR! URL cannot be reached. Status code: HTTP/2 404' output.txt\n+ grep -q 'Link name: install viash here' output.txt\n+ echo '>>> Test finished successfully!'\n>>> Test finished successfully!\n+ exit 0\n====================================================================\n[32mSUCCESS! All 1 out of 1 test scripts succeeded![0m\nCleaning up temporary directory\nIf the test succeeds, Viash writes the full output to the shell and deletes the temporary files. If there are any issues, the script stops and an error message will appear in red. In this case, you can inspect the temporary files to troubleshoot.\n\n\n\n\n\n\nTip\n\n\n\nYou can pass the --keep true argument to viash test to prevent viash from automatically deleting the temporary files in case of a success: viash test --keep true config.vsh.yaml."
  },
  {
    "objectID": "documentation/guide/component/resources.html",
    "href": "documentation/guide/component/resources.html",
    "title": "External Resources",
    "section": "",
    "text": "TODO: How to define and use external files, executables, etc."
  },
  {
    "objectID": "documentation/guide/component/resources.html#overview",
    "href": "documentation/guide/component/resources.html#overview",
    "title": "External Resources",
    "section": "Overview",
    "text": "Overview"
  },
  {
    "objectID": "documentation/guide/component/namespaces.html",
    "href": "documentation/guide/component/namespaces.html",
    "title": "Namespaces",
    "section": "",
    "text": "A namespace is a group of Viash components.\nHere are some benefits of grouping your components:\n\nGrouping components in namespaces allows for categorizing components.\nEach teams of developers can work on a different set of components in parallel, which improves the separation of concerns.\nGenerating build targets and unit testing can be done in bulk, with optional filtering by namespace using the viash ns commands.\n\nThis guide will cover how to define a namespace and use it with Viash."
  },
  {
    "objectID": "documentation/guide/component/namespaces.html#adding-components-to-a-namespace",
    "href": "documentation/guide/component/namespaces.html#adding-components-to-a-namespace",
    "title": "Namespaces",
    "section": "Adding components to a namespace",
    "text": "Adding components to a namespace\nThere are two ways of defining a namespace: either by adding the namespace property to the Viash config file or by creating a directory structure. You can use one or both of these methods in your projects.\n\nNamespace property\nYou can assign a component to a namespace by defining its namespace attribute in the viash config file:\nfunctionality:\n  name: some_component\n  namespace: my_namespace\n\n\nDirectory structure\nViash can deduce namespaces automatically if you structure the components hierarchically. The namespace directories should be in the root of your (source) directory, with the component directories inside, grouped per namespace.\nIn the example below, there are two namespaces: namespace_one and namespace_two, each of these namespaces has one or more components assigned to them:\nsrc\n├── namespace_one\n│   ├── component_one\n│   │   ├── config.vsh.yaml\n│   │   └── script.sh\n│   └── component_two\n│       ├── config.vsh.yaml\n│       └── script.sh\n└── namespace_two\n    └── component_three\n        ├── config.vsh.yaml\n        └── script.sh\nHere, namespace_one groups component_one and component_two together while namespace_two only consists of a single component, component_three."
  },
  {
    "objectID": "documentation/guide/component/namespaces.html#using-the-viash-ns-subcommands",
    "href": "documentation/guide/component/namespaces.html#using-the-viash-ns-subcommands",
    "title": "Namespaces",
    "section": "Using the viash ns subcommands",
    "text": "Using the viash ns subcommands\nViash comes with a useful viash ns command to work with namespaces. This can be used to inspect, test and build the components that are part of a namespace.\nWe’ve provided a simple example project if you wish to test these commands. Its components use bash for some integer and string manipulation.\nDownload namespace_example.zip\n\nListing components and namespaces\nThe viash ns list command is the namespace equivalent of viash config view, it outputs a parsed version of all config files found in a directory and their subdirectories:\nviash ns list -src src\nThis prints all fields to the terminal, even those not defined in the config files themselves. Here’s a part of the output:\n\n\nOutput\n\n- functionality:\n    name: \"replace\"\n    namespace: \"string_manipulation\"\n    authors: []\n    inputs: []\n    outputs: []\n    arguments:\n    - type: \"string\"\n      name: \"--text\"\n      alternatives: []\n      example: []\n      default:\n      - \"Hello world!\"\n      required: false\n      values: []\n      direction: \"input\"\n      multiple: false\n      multiple_sep: \":\"\n    - type: \"string\"\n      name: \"--search\"\n      alternatives: []\n      example: []\n      default:\n      - \"Hello\"\n      required: false\n      values: []\n      direction: \"input\"\n      multiple: false\n      multiple_sep: \":\"\n    - type: \"string\"\n      name: \"--replace\"\n      alternatives: []\n      example: []\n      default:\n      - \"Greetings\"\n      required: false\n      values: []\n      direction: \"input\"\n      multiple: false\n      multiple_sep: \":\"\n    resources:\n    - type: \"bash_script\"\n      path: \"script.sh\"\n      is_executable: true\n      parent: \"file:/.../namespace_example/src/string_manipulation/replace/config.vsh.yaml\"\n    description: \"Search for a substring in a string and replace it with another string\"\n    test_resources:\n    - type: \"bash_script\"\n      path: \"test.sh\"\n      is_executable: true\n      parent: \"file:/.../namespace_example/src/string_manipulation/replace/config.vsh.yaml\"\n    info: {}\n    dummy_arguments: []\n    set_wd_to_resources_dir: false\n  platform:\n    type: \"native\"\n    id: \"native\"\n  platforms:\n  - type: \"native\"\n    id: \"native\"\n  info:\n    config: \"namespace_example/src/string_manipulation/replace/config.vsh.yaml\"\n    platform: \"native\"\n    viash_version: \"0.5.12\"\n    git_commit: \"d9d624de0264b1154d7eeb5dba3c1deb567311ac\"\n    git_remote: \"https://github.com/...\"\n...\n\n\n\nUnit testing a namespace\nYou can test multiple components using the viash ns test command.\nviash ns test --src src\n\n\n\n\n\n\nTip\n\n\n\nTo speed up the testing, you can use the parallel flag to test all components at once:\nviash ns test --src src --parallel\n\n\nThis will test each component in series and will output a tab separated output that contains the results:\nThe working directory for the namespace tests is /tmp/viash_ns_test2526740097581645786\n           namespace        functionality             platform            test_name exit_code duration               result\n string_manipulation              replace               native                start                                        \n string_manipulation              replace               native              test.sh         0        0              SUCCESS\n                math             subtract               native                start                                        \n                math             subtract               native              test.sh         0        0              SUCCESS\n                math                  add               native                start                                        \n                math                  add               native              test.sh         0        0              SUCCESS\n\n\nBuilding a namespace\nMultiple components can be build in series using the viash ns build command:\nviash ns build --src src --target target\n\n\n\n\n\n\nTip\n\n\n\nTo speed up the building, you can use the parallel flag to build all components at once:\nviash ns build --src src --target target --parallel\n\n\nThis will output the following to the console:\nExporting replace (string_manipulation) =native=> target/native/string_manipulation/replace\nExporting subtract (math) =native=> target/native/math/subtract\nExporting add (math) =native=> target/native/math/add\nAn executable and/or module will be generated for every target platform defined in each of the component configs. These are grouped per platform and namespace in the target directory:\ntarget\n└── native\n    ├── math\n    │   ├── add\n    │   │   └── add\n    │   └── subtract\n    │       └── subtract\n    └── string_manipulation\n        └── replace\n            └── replace"
  },
  {
    "objectID": "documentation/guide/component/supported-languages/r.html",
    "href": "documentation/guide/component/supported-languages/r.html",
    "title": "R",
    "section": "",
    "text": "R is a programming language for statistical computing and graphics. It’s used primarily among data miners, bioinformaticians and staticians for data analysis and developing statistical software."
  },
  {
    "objectID": "documentation/guide/component/supported-languages/r.html#dependencies",
    "href": "documentation/guide/component/supported-languages/r.html#dependencies",
    "title": "R",
    "section": "Dependencies",
    "text": "Dependencies\nTo be able to run R scripts, you’ll need download and install R for your OS."
  },
  {
    "objectID": "documentation/guide/component/supported-languages/r.html#referencing-r-scripts-in-a-viash-config-file",
    "href": "documentation/guide/component/supported-languages/r.html#referencing-r-scripts-in-a-viash-config-file",
    "title": "R",
    "section": "Referencing R scripts in a Viash config file",
    "text": "Referencing R scripts in a Viash config file\nWhen referencing a R script in the resources of the functionality section your Viash config, use r_script as its type:\nfunctionality:\n  name: my_component\n  resources:\n  - type: r_script\n    path: script.r"
  },
  {
    "objectID": "documentation/guide/component/supported-languages/r.html#executing-scripts",
    "href": "documentation/guide/component/supported-languages/r.html#executing-scripts",
    "title": "R",
    "section": "Executing scripts",
    "text": "Executing scripts\nR scripts end with the .r extension. They can be run locally by using the Rscript command:\nRscript script.r"
  },
  {
    "objectID": "documentation/guide/component/supported-languages/r.html#script-examples",
    "href": "documentation/guide/component/supported-languages/r.html#script-examples",
    "title": "R",
    "section": "Script examples",
    "text": "Script examples\nThese examples will briefly show to use R in the context of Viash. Each example shows the source code and the output after running it.\n\nHello World\nHere’s the classic Hello World written in R:\nHelloWorld.r\n#!/usr/bin/env Rscript\n\ncat(\"Hello World!\")\nOutput\nHello World!\n\n\n\n\n\n\nNote\n\n\n\nThe first line with the shebang is optional but recommended as it indicates what interpreter should be used for execution.\n\n\n\n\nUsing variables\nVariables.r\n#!/usr/bin/env Rscript\n\nhello = \"Hello World!\"\ncat(hello)\nOutput\nHello World!\n\n\nUsing Viash arguments as variables\nViash generates variables based on the arguments defined in the Viash config file and injects them at the top of your script. In the case of R, these variables are grouped inside a list named par and can be referenced by name.\nconfig.vsh.yaml\nfunctionality:\n  name: hello_world\n  arguments:\n  - type: string\n    name: --hello\n    default: \"Hello World!\"\n  resources:\n  - type: r_script\n    path: script.r\nViashVariables.r\n#!/usr/bin/env Rscript\n\ncat(par$hello)\nOutput\nHello World!\n\n\nUsing Viash placeholder variables\nIn some cases, you want to be able to write or adapt a script and test it out before creating a component. While you can write your script as normal and switch out the variables later on with their Viash variants, we supply a useful method of adding Viash variables beforehand in the form of a comment section.\nPlaceholderVariables.r\n#!/usr/bin/env Rscript\n\n## VIASH START\npar <- list(\n  hello = \"Hello World!\"\n)\n## VIASH END\n\ncat(par$hello)\nOutput\nHello World!\nAnything between ## VIASH START and ## VIASH END will be replaced by the injected variables Viash generates once the script is executed as part of a component. This allows you to easily troubleshoot your script while being compatible with Viash."
  },
  {
    "objectID": "documentation/guide/component/supported-languages/r.html#meta-variables",
    "href": "documentation/guide/component/supported-languages/r.html#meta-variables",
    "title": "R",
    "section": "Meta variables",
    "text": "Meta variables\nViash offers hidden variables to use in your scripts that can be used to get meta information about your component.\n\nFunctionality name\nName of the component found in the functionality section of the Viash config:\nfunctionality:\n  name: my_component\nThis can be referenced in your script using meta$functionality_name:\ncat(meta$functionality_name)\nOutput\nmy_component\n\n\nResources directory\nPath where the resources as defined in the Viash config file are stored. You can access this value using meta$resources_dir:\ncat(meta$resources_dir)\nWhen using viash run to create a temporary build target and execute it, this will point to the temporary path where the executable was generated:\n/tmp/viash_my_component9560481446119256265\nAfter building a component using viash build and running the generated executable, it points to the directory where the executable and the other resources reside in:\n/home/user/components/my_component_target_dir\n\n\nTemp directory\nPath to the directory supplied by the host system where you can write temporary files to. This can be referenced in your script using meta$temp_dir:\ncat(meta$temp_dir)\nOutput\n/tmp"
  },
  {
    "objectID": "documentation/guide/component/supported-languages/csharp.html",
    "href": "documentation/guide/component/supported-languages/csharp.html",
    "title": "C#",
    "section": "",
    "text": "C# is a general-purpose programming language designed by Microsoft. Viash supports .NET Core C# scripting by utilizing the cross platform dotnet-script tool."
  },
  {
    "objectID": "documentation/guide/component/supported-languages/csharp.html#dependencies",
    "href": "documentation/guide/component/supported-languages/csharp.html#dependencies",
    "title": "C#",
    "section": "Dependencies",
    "text": "Dependencies\nTo get started with C# scripting, you need to download and install the .NET 6.0 SDK.\n\n\n\n\n\n\nNote\n\n\n\nIf you’re using WSL2, make sure to follow the Linux instructions and execute the commands in a WSL2 terminal.\n\n\nAfter installing the SDK, run this command to install the dotnet-script tool:\ndotnet tool install -g dotnet-script\nTo verify that dotnet-script was installed successfully, run this command to get a list of installed tools:\ndotnet tool list -g\nThe output should look something like this:\nPackage Id         Version      Commands     \n---------------------------------------------\ndotnet-script      1.3.1        dotnet-script"
  },
  {
    "objectID": "documentation/guide/component/supported-languages/csharp.html#referencing-c-scripts-in-a-viash-config-file",
    "href": "documentation/guide/component/supported-languages/csharp.html#referencing-c-scripts-in-a-viash-config-file",
    "title": "C#",
    "section": "Referencing C# scripts in a Viash config file",
    "text": "Referencing C# scripts in a Viash config file\nWhen referencing a C# script in the resources of the functionality section your Viash config, use csharp_script as its type:\nfunctionality:\n  name: my_component\n  resources:\n  - type: csharp_script\n    path: script.csx"
  },
  {
    "objectID": "documentation/guide/component/supported-languages/csharp.html#executing-scripts",
    "href": "documentation/guide/component/supported-languages/csharp.html#executing-scripts",
    "title": "C#",
    "section": "Executing scripts",
    "text": "Executing scripts\nC# scripts end with the .csx extension. They can be run locally by using the dotnet script command:\ndotnet script script.csx"
  },
  {
    "objectID": "documentation/guide/component/supported-languages/csharp.html#script-examples",
    "href": "documentation/guide/component/supported-languages/csharp.html#script-examples",
    "title": "C#",
    "section": "Script examples",
    "text": "Script examples\nThese examples will briefly show to use C# in the context of Viash. Each example shows the source code and the output after running it.\n\nHello World\nHere’s the classic Hello World written in C#:\nHelloWorld.csx\n#!/usr/bin/env dotnet-script\n\nConsole.WriteLine(\"Hello World!\");\nOutput\nHello World!\n\n\n\n\n\n\nNote\n\n\n\nThe first line with the shebang is optional but recommended as it indicates what interpreter should be used for execution.\n\n\n\n\nUsing variables\nVariables.csx\n#!/usr/bin/env dotnet-script\n\nstring hello = \"Hello World!\";\nConsole.WriteLine(hello);\nOutput\nHello World!\n\n\nUsing Viash arguments as variables\nViash generates variables based on the arguments defined in the Viash config file and injects them at the top of your script. In the case of C#, these variables are grouped inside an anonymous par class and can be referenced by name.\nconfig.vsh.yaml\nfunctionality:\n  name: hello_world\n  arguments:\n  - type: string\n    name: --hello\n    default: \"Hello World!\"\n  resources:\n  - type: csharp_script\n    path: script.csx\nViashVariables.csx\n#!/usr/bin/env dotnet-script\n\nConsole.WriteLine(par.hello);\nOutput\nHello World!\n\n\nUsing Viash placeholder variables\nIn some cases, you want to be able to write or adapt a script and test it out before creating a component. While you can write your script as normal and switch out the variables later on with their Viash variants, we supply a useful method of adding Viash variables beforehand in the form of a comment section.\nPlaceholderVariables.csx\n#!/usr/bin/env dotnet-script\n\n// VIASH START\nvar par = new {\n  hello = \"Hello World!\"\n};\n// VIASH END\n\nConsole.WriteLine(par.hello);\nOutput\nHello World!\nAnything between // VIASH START and // VIASH END will be replaced by the injected variables Viash generates once the script is executed as part of a component. This allows you to easily troubleshoot your script while being compatible with Viash.\n\n\nUsing NuGet packages\nWith dotnet-script, you can reference NuGet packages directly from within the script. In the example below, we add a reference to Newtonsoft.Json to convert a dictionary to JSON and output it to the console.\nscript.csx\n#!/usr/bin/env dotnet-script\n#r \"nuget: Newtonsoft.Json, 13.0.1\"\n\nusing Newtonsoft.Json;\n\nDictionary<string, int> downloads = new Dictionary<string, int>\n{\n    { \"v1.0\", 501 },\n    { \"v1.1\", 802 },\n    { \"v2.0\", 2857 }\n};\n\nstring json = JsonConvert.SerializeObject(downloads, Formatting.Indented);\nConsole.WriteLine(json);\nRunning script.csx results in the following output:\n{\n  \"v1.0\": 501,\n  \"v1.1\": 802,\n  \"v2.0\": 2857\n}"
  },
  {
    "objectID": "documentation/guide/component/supported-languages/csharp.html#meta-variables",
    "href": "documentation/guide/component/supported-languages/csharp.html#meta-variables",
    "title": "C#",
    "section": "Meta variables",
    "text": "Meta variables\nViash offers hidden variables to use in your scripts that can be used to get meta information about your component.\n\nFunctionality name\nName of the component found in the functionality section of the Viash config:\nfunctionality:\n  name: my_component\nThis can be referenced in your script using meta.functionality_name:\nConsole.WriteLine(meta.functionality_name);\nOutput\nmy_component\n\n\nResources directory\nPath where the resources as defined in the Viash config file are stored. You can access this value using meta.resources_dir:\nConsole.WriteLine(meta.resources_dir);\nWhen using viash run to create a temporary build target and execute it, this will point to the temporary path where the executable was generated:\n/tmp/viash_my_component9560481446119256265\nAfter building a component using viash build and running the generated executable, it points to the directory where the executable and the other resources reside in:\n/home/user/components/my_component_target_dir\n\n\nTemp directory\nPath to the directory supplied by the host system where you can write temporary files to. This can be referenced in your script using meta.temp_dir:\nConsole.WriteLine(meta.temp_dir);\nOutput\n/tmp"
  },
  {
    "objectID": "documentation/guide/component/supported-languages/bash.html",
    "href": "documentation/guide/component/supported-languages/bash.html",
    "title": "Bash",
    "section": "",
    "text": "Bash is the GNU Project’s shell, the Bourne Again SHell. Besides being a shell, Bash can interpret commands in Bash scripts line-by-line.\nAll executables generated by Viash use Bash scripting as a wrapper to provide a CLI and additional logic."
  },
  {
    "objectID": "documentation/guide/component/supported-languages/bash.html#dependencies",
    "href": "documentation/guide/component/supported-languages/bash.html#dependencies",
    "title": "Bash",
    "section": "Dependencies",
    "text": "Dependencies\nBash doesn’t have any dependencies and is included in every modern Linux distro, including those provided for WSL2 on Microsoft’s Store app. On macOS, the default shell is Zsh since 2019, but it still comes packaged with an older Bash 3.2."
  },
  {
    "objectID": "documentation/guide/component/supported-languages/bash.html#referencing-bash-scripts-in-a-viash-config-file",
    "href": "documentation/guide/component/supported-languages/bash.html#referencing-bash-scripts-in-a-viash-config-file",
    "title": "Bash",
    "section": "Referencing Bash scripts in a Viash config file",
    "text": "Referencing Bash scripts in a Viash config file\nWhen referencing a Bash script in the resources of the functionality section your Viash config, use bash_script as its type:\nfunctionality:\n  name: my_component\n  resources:\n  - type: bash_script\n    path: script.sh"
  },
  {
    "objectID": "documentation/guide/component/supported-languages/bash.html#executing-scripts",
    "href": "documentation/guide/component/supported-languages/bash.html#executing-scripts",
    "title": "Bash",
    "section": "Executing scripts",
    "text": "Executing scripts\nBash scripts end with the .sh extension. They can be run locally by using the bash command:\nbash script.sh"
  },
  {
    "objectID": "documentation/guide/component/supported-languages/bash.html#script-examples",
    "href": "documentation/guide/component/supported-languages/bash.html#script-examples",
    "title": "Bash",
    "section": "Script examples",
    "text": "Script examples\nThese examples will briefly show to use Bash in the context of Viash. Each example shows the source code and the output after running it.\n\nHello World\nHere’s the classic Hello World written in Bash:\nHelloWorld.sh\n#!/bin/bash\n\necho \"Hello World!\"\nOutput\nHello World!\n\n\n\n\n\n\nNote\n\n\n\nThe first line with the shebang is optional but recommended as it indicates what interpreter should be used for execution.\n\n\n\n\nUsing variables\nVariables.sh\n#!/bin/bash\n\nhello=\"Hello World!\"\necho $hello\nOutput\nHello World!\n\n\nUsing Viash arguments as variables\nViash generates variables based on the arguments defined in the Viash config file and injects them at the top of your script. In the case of Bash, these variables start with $par_, followed by the name of the argument.\nconfig.vsh.yaml\nfunctionality:\n  name: hello_world\n  arguments:\n  - type: string\n    name: --hello\n    default: \"Hello World!\"\n  resources:\n  - type: bash_script\n    path: script.sh\nViashVariables.sh\n#!/bin/bash\n\necho $par_hello\nOutput\nHello World!\n\n\nUsing Viash placeholder variables\nIn some cases, you want to be able to write or adapt a script and test it out before creating a component. While you can write your script as normal and switch out the variables later on with their Viash variants, we supply a useful method of adding Viash variables beforehand in the form of a comment section.\nPlaceholderVariables.sh\n#!/bin/bash\n\n## VIASH START\npar_hello=\"Hello World!\"\n## VIASH END\n\necho $par_hello\nOutput\nHello World!\nAnything between ## VIASH START and ## VIASH END will be replaced by the injected variables Viash generates once the script is executed as part of a component. This allows you to easily troubleshoot your script while being compatible with Viash.\n\n\nSourcing other scripts\nWith bash, you can include other bash scripts to share content and functionality by using the source command.\nBy writing two scripts and adding them to the same directory, one can reference the other:\nscript.sh\n#!/bin/bash\n\nsource include_me.sh\necho \"Hello from the main script!\"\ninclude_me.sh\n#!/bin/bash\n\necho \"Hi from the included script!\"\nRunning script.sh results in the following output:\nHi from the included script!\nHello from the main script!\nViash supports the sourcing of scripts by adding them as a resource:\nconfig.vsh.yaml\nfunctionality:\n  name: source_example\n  resources:\n  - type: bash_script\n    path: script.sh\n  - type: bash_script\n    path: include_me.sh\nDoing this will ensure any needed scripts will be included with the build target."
  },
  {
    "objectID": "documentation/guide/component/supported-languages/bash.html#meta-variables",
    "href": "documentation/guide/component/supported-languages/bash.html#meta-variables",
    "title": "Bash",
    "section": "Meta variables",
    "text": "Meta variables\nViash offers hidden variables to use in your scripts that can be used to get meta information about your component.\n\nFunctionality name\nName of the component found in the functionality section of the Viash config:\nfunctionality:\n  name: my_component\nThis can be referenced in your script using $meta_functionality_name:\necho $meta_functionality_name\nOutput\nmy_component\n\n\nResources directory\nPath where the resources as defined in the Viash config file are stored. You can access this value using $meta_resources_dir:\necho $meta_resources_dir\nWhen using viash run to create a temporary build target and execute it, this will point to the temporary path where the executable was generated:\n/tmp/viash_my_component9560481446119256265\nAfter building a component using viash build and running the generated executable, it points to the directory where the executable and the other resources reside in:\n/home/user/components/my_component_target_dir\n\n\nTemp directory\nPath to the directory supplied by the host system where you can write temporary files to. This can be referenced in your script using $meta_temp_dir:\necho $meta_temp_dir\nOutput\n/tmp"
  },
  {
    "objectID": "documentation/guide/component/supported-languages/javascript.html",
    "href": "documentation/guide/component/supported-languages/javascript.html",
    "title": "JavaScript",
    "section": "",
    "text": "Viash supports JavaScript as a scripting language via Node.js, a runtime build on Chrome’s V8 JavaScript engine."
  },
  {
    "objectID": "documentation/guide/component/supported-languages/javascript.html#dependencies",
    "href": "documentation/guide/component/supported-languages/javascript.html#dependencies",
    "title": "JavaScript",
    "section": "Dependencies",
    "text": "Dependencies\nTo run JavaScript on your system, you’ll need to download and install Node.js from their homepage."
  },
  {
    "objectID": "documentation/guide/component/supported-languages/javascript.html#referencing-javascript-scripts-in-a-viash-config-file",
    "href": "documentation/guide/component/supported-languages/javascript.html#referencing-javascript-scripts-in-a-viash-config-file",
    "title": "JavaScript",
    "section": "Referencing JavaScript scripts in a Viash config file",
    "text": "Referencing JavaScript scripts in a Viash config file\nWhen referencing a JavaScript script in the resources of the functionality section your Viash config, use javascript_script as its type:\nfunctionality:\n  name: my_component\n  resources:\n  - type: javascript_script\n    path: script.js"
  },
  {
    "objectID": "documentation/guide/component/supported-languages/javascript.html#executing-scripts",
    "href": "documentation/guide/component/supported-languages/javascript.html#executing-scripts",
    "title": "JavaScript",
    "section": "Executing scripts",
    "text": "Executing scripts\nJavaScript scripts end with the .js extension. They can be run locally by using the node command:\nnode script.js"
  },
  {
    "objectID": "documentation/guide/component/supported-languages/javascript.html#script-examples",
    "href": "documentation/guide/component/supported-languages/javascript.html#script-examples",
    "title": "JavaScript",
    "section": "Script examples",
    "text": "Script examples\nThese examples will briefly show to use JavaScript in the context of Viash. Each example shows the source code and the output after running it.\n\nHello World\nHere’s the classic Hello World written in JavaScript:\nHelloWorld.js\n#!/usr/bin/env node\n\nconsole.log('Hello World!')\nOutput\nHello World!\n\n\n\n\n\n\nNote\n\n\n\nThe first line with the shebang is optional but recommended as it indicates what interpreter should be used for execution.\n\n\n\n\nUsing variables\nVariables.js\n#!/usr/bin/env node\n\nlet hello = 'Hello World!'\nconsole.log(hello)\nOutput\nHello World!\n\n\nUsing Viash arguments as variables\nViash generates variables based on the arguments defined in the Viash config file and injects them at the top of your script. In the case of JavaScript, these variables are grouped inside a dictionary named par and can be referenced by name.\nconfig.vsh.yaml\nfunctionality:\n  name: hello_world\n  arguments:\n  - type: string\n    name: --hello\n    default: \"Hello World!\"\n  resources:\n  - type: javascript_script\n    path: script.js\nViashVariables.js\n#!/usr/bin/env node\n\nconsole.log(par['hello'])\nOutput\nHello World!\n\n\nUsing Viash placeholder variables\nIn some cases, you want to be able to write or adapt a script and test it out before creating a component. While you can write your script as normal and switch out the variables later on with their Viash variants, we supply a useful method of adding Viash variables beforehand in the form of a comment section.\nPlaceholderVariables.js\n#!/usr/bin/env node\n\n// VIASH START\nlet par = {\n    'hello': 'Hello World!'\n  }\n// VIASH END\n\nconsole.log(par['hello'])\nOutput\nHello World!\nAnything between // VIASH START and // VIASH END will be replaced by the injected variables Viash generates once the script is executed as part of a component. This allows you to easily troubleshoot your script while being compatible with Viash."
  },
  {
    "objectID": "documentation/guide/component/supported-languages/javascript.html#meta-variables",
    "href": "documentation/guide/component/supported-languages/javascript.html#meta-variables",
    "title": "JavaScript",
    "section": "Meta variables",
    "text": "Meta variables\nViash offers hidden variables to use in your scripts that can be used to get meta information about your component.\n\nFunctionality name\nName of the component found in the functionality section of the Viash config:\nfunctionality:\n  name: my_component\nThis can be referenced in your script using meta['functionality_name']:\nconsole.log(meta['functionality_name']);\nOutput\nmy_component\n\n\nResources directory\nPath where the resources as defined in the Viash config file are stored. You can access this value using meta['resources_dir']:\nconsole.log(meta['resources_dir']);\nWhen using viash run to create a temporary build target and execute it, this will point to the temporary path where the executable was generated:\n/tmp/viash_my_component9560481446119256265\nAfter building a component using viash build and running the generated executable, it points to the directory where the executable and the other resources reside in:\n/home/user/components/my_component_target_dir\n\n\nTemp directory\nPath to the directory supplied by the host system where you can write temporary files to. This can be referenced in your script using meta['temp_dir']:\nconsole.log(meta['temp_dir']);\nOutput\n/tmp"
  },
  {
    "objectID": "documentation/guide/component/supported-languages/scala.html",
    "href": "documentation/guide/component/supported-languages/scala.html",
    "title": "Scala",
    "section": "",
    "text": "Scala is an object-oriented and functional high-level programming language."
  },
  {
    "objectID": "documentation/guide/component/supported-languages/scala.html#dependencies",
    "href": "documentation/guide/component/supported-languages/scala.html#dependencies",
    "title": "Scala",
    "section": "Dependencies",
    "text": "Dependencies\nRunning Scala scripts requires you to download and install Scala."
  },
  {
    "objectID": "documentation/guide/component/supported-languages/scala.html#referencing-scala-scripts-in-a-viash-config-file",
    "href": "documentation/guide/component/supported-languages/scala.html#referencing-scala-scripts-in-a-viash-config-file",
    "title": "Scala",
    "section": "Referencing Scala scripts in a Viash config file",
    "text": "Referencing Scala scripts in a Viash config file\nWhen referencing a Scala script in the resources of the functionality section your Viash config, use scala_script as its type:\nfunctionality:\n  name: my_component\n  resources:\n  - type: scala_script\n    path: script.scala"
  },
  {
    "objectID": "documentation/guide/component/supported-languages/scala.html#executing-scripts",
    "href": "documentation/guide/component/supported-languages/scala.html#executing-scripts",
    "title": "Scala",
    "section": "Executing scripts",
    "text": "Executing scripts\nScala scripts end with the .scala extension. They can be run locally by using the scala -nc command:\nscala -nc script.scala"
  },
  {
    "objectID": "documentation/guide/component/supported-languages/scala.html#script-examples",
    "href": "documentation/guide/component/supported-languages/scala.html#script-examples",
    "title": "Scala",
    "section": "Script examples",
    "text": "Script examples\nThese examples will briefly show to use Scala in the context of Viash. Each example shows the source code and the output after running it.\n\nHello World\nHere’s the classic Hello World written in Scala:\nHelloWorld.scala\n#!/usr/bin/env scala\n\nprintln(\"Hello World!\")\nOutput\nHello World!\n\n\n\n\n\n\nNote\n\n\n\nThe first line with the shebang is optional but recommended as it indicates what interpreter should be used for execution.\n\n\n\n\nUsing variables\nVariables.scala\n#!/usr/bin/env scala\n\nval hello = \"Hello World!\";\nprintln(hello)\nOutput\nHello World!\n\n\nUsing Viash arguments as variables\nViash generates variables based on the arguments defined in the Viash config file and injects them at the top of your script. In the case of Scala, these variables are grouped inside an instance of a class named par and can be referenced by name.\nconfig.vsh.yaml\nfunctionality:\n  name: hello_world\n  arguments:\n  - type: string\n    name: --hello\n    default: \"Hello World!\"\n  resources:\n  - type: scala_script\n    path: script.scala\nViashVariables.scala\n#!/usr/bin/env scala\n\nprintln(par.hello.get)\nOutput\nHello World!\n\n\nUsing Viash placeholder variables\nIn some cases, you want to be able to write or adapt a script and test it out before creating a component. While you can write your script as normal and switch out the variables later on with their Viash variants, we supply a useful method of adding Viash variables beforehand in the form of a comment section.\nPlaceholderVariables.scala\n#!/usr/bin/env scala\n\n// VIASH START\ncase class ViashPar(\n  greeter: Option[String]\n)\n\nval par = ViashPar(\n  greeter = Some(\"Hello World!\")\n)\n// VIASH END\n\nprintln(par.hello.get)\nOutput\nHello World!\nAnything between // VIASH START and // VIASH END will be replaced by the injected variables Viash generates once the script is executed as part of a component. This allows you to easily troubleshoot your script while being compatible with Viash."
  },
  {
    "objectID": "documentation/guide/component/supported-languages/scala.html#meta-variables",
    "href": "documentation/guide/component/supported-languages/scala.html#meta-variables",
    "title": "Scala",
    "section": "Meta variables",
    "text": "Meta variables\nViash offers hidden variables to use in your scripts that can be used to get meta information about your component.\n\nFunctionality name\nName of the component found in the functionality section of the Viash config:\nfunctionality:\n  name: my_component\nThis can be referenced in your script using meta.functionality_name:\nprintln(meta.functionality_name)\nOutput\nmy_component\n\n\nResources directory\nPath where the resources as defined in the Viash config file are stored. You can access this value using meta.resources_dir:\nprintln(meta.resources_dir)\nWhen using viash run to create a temporary build target and execute it, this will point to the temporary path where the executable was generated:\n/tmp/viash_my_component9560481446119256265\nAfter building a component using viash build and running the generated executable, it points to the directory where the executable and the other resources reside in:\n/home/user/components/my_component_target_dir\n\n\nTemp directory\nPath to the directory supplied by the host system where you can write temporary files to. This can be referenced in your script using meta.temp_dir:\nprintln(meta.temp_dir)\nOutput\n/tmp"
  },
  {
    "objectID": "documentation/guide/component/supported-languages/python.html",
    "href": "documentation/guide/component/supported-languages/python.html",
    "title": "Python",
    "section": "",
    "text": "Python is a popular high-level, general-purpose programming language."
  },
  {
    "objectID": "documentation/guide/component/supported-languages/python.html#dependencies",
    "href": "documentation/guide/component/supported-languages/python.html#dependencies",
    "title": "Python",
    "section": "Dependencies",
    "text": "Dependencies\nTo run Python scripts on your system, download and install Python. Most package managers include a python package as well. Make sure to install a version of Python that’s at least version 3.8 or newer."
  },
  {
    "objectID": "documentation/guide/component/supported-languages/python.html#referencing-python-scripts-in-a-viash-config-file",
    "href": "documentation/guide/component/supported-languages/python.html#referencing-python-scripts-in-a-viash-config-file",
    "title": "Python",
    "section": "Referencing Python scripts in a Viash config file",
    "text": "Referencing Python scripts in a Viash config file\nWhen referencing a Python script in the resources of the functionality section your Viash config, use python_script as its type:\nfunctionality:\n  name: my_component\n  resources:\n  - type: python_script\n    path: script.py"
  },
  {
    "objectID": "documentation/guide/component/supported-languages/python.html#executing-scripts",
    "href": "documentation/guide/component/supported-languages/python.html#executing-scripts",
    "title": "Python",
    "section": "Executing scripts",
    "text": "Executing scripts\nPython scripts end with the .py extension. They can be run locally by using the python command:\npython script.py"
  },
  {
    "objectID": "documentation/guide/component/supported-languages/python.html#script-examples",
    "href": "documentation/guide/component/supported-languages/python.html#script-examples",
    "title": "Python",
    "section": "Script examples",
    "text": "Script examples\nThese examples will briefly show to use Python in the context of Viash. Each example shows the source code and the output after running it.\n\nHello World\nHere’s the classic Hello World written in Python:\nHelloWorld.py\n#!/usr/bin/env python3\n\nprint(\"Hello World!\")\nOutput\nHello World!\n\n\n\n\n\n\nNote\n\n\n\nThe first line with the shebang is optional but recommended as it indicates what interpreter should be used for execution.\n\n\n\n\nUsing variables\nVariables.py\n#!/usr/bin/env python3\n\nhello = \"Hello World!\"\nprint(hello)\nOutput\nHello World!\n\n\nUsing Viash arguments as variables\nViash generates variables based on the arguments defined in the Viash config file and injects them at the top of your script. In the case of Python, these variables are grouped inside a dictionary named par and can be referenced by name.\nconfig.vsh.yaml\nfunctionality:\n  name: hello_world\n  arguments:\n  - type: string\n    name: --hello\n    default: \"Hello World!\"\n  resources:\n  - type: python_script\n    path: script.py\nViashVariables.py\n#!/usr/bin/env python3\n\nprint(par[\"hello\"])\nOutput\nHello World!\n\n\nUsing Viash placeholder variables\nIn some cases, you want to be able to write or adapt a script and test it out before creating a component. While you can write your script as normal and switch out the variables later on with their Viash variants, we supply a useful method of adding Viash variables beforehand in the form of a comment section.\nPlaceholderVariables.py\n#!/usr/bin/env python3\n\n## VIASH START\npar = {\n  \"hello\": \"Hello World!\"\n}\n## VIASH END\n\nprint(par[\"hello\"])\nOutput\nHello World!\nAnything between ## VIASH START and ## VIASH END will be replaced by the injected variables Viash generates once the script is executed as part of a component. This allows you to easily troubleshoot your script while being compatible with Viash."
  },
  {
    "objectID": "documentation/guide/component/supported-languages/python.html#meta-variables",
    "href": "documentation/guide/component/supported-languages/python.html#meta-variables",
    "title": "Python",
    "section": "Meta variables",
    "text": "Meta variables\nViash offers hidden variables to use in your scripts that can be used to get meta information about your component.\n\nFunctionality name\nName of the component found in the functionality section of the Viash config:\nfunctionality:\n  name: my_component\nThis can be referenced in your script using meta[\"functionality_name\"]:\nprint(meta[\"functionality_name\"])\nOutput\nmy_component\n\n\nResources directory\nPath where the resources as defined in the Viash config file are stored. You can access this value using meta[\"resources_dir\"]:\nprint(meta[\"resources_dir\"])\nWhen using viash run to create a temporary build target and execute it, this will point to the temporary path where the executable was generated:\n/tmp/viash_my_component9560481446119256265\nAfter building a component using viash build and running the generated executable, it points to the directory where the executable and the other resources reside in:\n/home/user/components/my_component_target_dir\n\n\nTemp directory\nPath to the directory supplied by the host system where you can write temporary files to. This can be referenced in your script using meta[\"temp_dir\"]:\nprint(meta[\"temp_dir\"])\nOutput\n/tmp"
  },
  {
    "objectID": "documentation/guide/data-workflow/nextflow-pipeline/pipeline-advanced.html",
    "href": "documentation/guide/data-workflow/nextflow-pipeline/pipeline-advanced.html",
    "title": "Advanced Pipeline",
    "section": "",
    "text": "explain this pipeline is a more realistic example of a typical use-case of a Nextflow bioinformatics pipeline as it has a mixture of scripting languages used and a join is used to merge all events"
  },
  {
    "objectID": "documentation/guide/data-workflow/nextflow-pipeline/pipeline-advanced.html#creating-the-modules",
    "href": "documentation/guide/data-workflow/nextflow-pipeline/pipeline-advanced.html#creating-the-modules",
    "title": "Advanced Pipeline",
    "section": "Creating the modules",
    "text": "Creating the modules\nThe sections below describe how to create the VDSL3 modules in preparation for creating the pipeline.\n\nPreparation\ncreate a new folder named advanced pipeline, add src folder with a nextflow_module folder inside. Now create three folders inside nextflow_module folder, one per component needed for the pipeline:\n\ncombine_columns\nremove_comments\ntake_columns\n\nThe folder structure should look like this now:\nadvanced_pipeline\n└── src\n    └── nextflow_modules\n        ├── combine_columns\n        ├── remove_comments\n        └── take_column\n\n\nCreating the remove_comments component\nThis component removes all comments (lines starting with a hashtag) from a tsv file.\nDownload or copy the contents of config.vsh.yaml and script.sh below into the remove_comments folder.\nDownload config.vsh.yaml\n\n\n\nContents of config.vsh.yaml\n\nfunctionality:\n  name: remove_comments\n  description: Remove comments from a TSV file.\n  namespace: nextflow_modules\n  arguments:\n    - name: \"--input\"\n      alternatives: [ \"-i\" ]\n      type: file\n      required: true\n      example: \"file.tsv\"\n    - name: \"--output\"\n      alternatives: [ \"-o\" ]\n      type: file\n      required: true\n      direction: output\n      example: \"file.tsv\"\n  resources:\n  - type: bash_script\n    path: ./script.sh\nplatforms:\n  - type: nextflow\n    variant: vdsl3\n    directives:\n      container: ubuntu:20.04\n\nDownload script.sh\n\n\n\nContents of script.sh\n\n#!/bin/bash\n\ngrep -v '^#' \"$par_input\" > \"$par_output\"\n\n\n\nCreating the take_column component\nThis component subsets an incoming tsv file by extracting a certain column from the file.\nDownload or copy the contents of config.vsh.yaml and script.py below into the take_column folder.\nDownload config.vsh.yaml\n\n\n\nContents of config.vsh.yaml\n\nfunctionality:\n  name: take_column\n  namespace: nextflow_modules\n  arguments:\n    - name: \"--input\"\n      alternatives: [ \"-i\" ]\n      type: file\n      required: true\n    - name: \"--output\"\n      alternatives: [ \"-o\" ]\n      type: file\n      required: true\n      direction: output\n    - name: \"--column\"\n      type: integer\n      required: false\n      default: 2\n  resources:\n  - type: python_script\n    path: ./script.py\nplatforms:\n  - type: nextflow\n    variant: vdsl3\n    directives:\n      container: amancevice/pandas:slim\n\nDownload script.py\n\n\n\nContents of script.py\n\nimport pandas as pd\n\n## VIASH START\npar = {\n    \"input\": \"data/file1.tsv\",\n    \"column\": 2,\n    \"output\": \"temp/foo\"\n}\n## VIASH END\n\n# read the tsv file\ntab = pd.read_csv(par[\"input\"], sep=\"\\t\", comment=\"#\")\n\n# subset a column\ntab_filt = tab.iloc[:, par[\"column\"]-1]\n\n# write to file\ntab_filt.to_csv(par[\"output\"], index=False)\n\n\n\nCreating the combine_columns component\nThis component combines multiple tsv files into one by concatenating all of the columns together. It assumes each incoming tsv file has an equal number of rows.\nDownload or copy the contents of config.vsh.yaml and script.R below into the combine_columns folder.\nDownload config.vsh.yaml\n\n\n\nContents of config.vsh.yaml\n\nfunctionality:\n  name: combine_columns\n  namespace: nextflow_modules\n  arguments:\n    - name: \"--input\"\n      alternatives: [ \"-i\" ]\n      type: file\n      multiple: true\n      required: true\n    - name: \"--output\"\n      alternatives: [ \"-o\" ]\n      type: file\n      required: true\n      direction: output\n  resources:\n    - type: r_script\n      path: ./script.R\nplatforms:\n  - type: nextflow\n    variant: vdsl3\n    directives:\n      container: rocker/r-ver:4.1\n\nDownload script.R\n\n\n\nContents of script.R\n\n## VIASH START\npar <- list(\n    input = c(\"data/file1.tsv\", \"data/file2.tsv\"),\n    output = \"temp/foo.tsv\"\n)\n## VIASH END\n\nouts <- lapply(par$input, function(file) {\n  read.delim(file, comment.char = \"#\", sep = \"\\t\", header = FALSE)\n})\n\ntable <- do.call(cbind, outs)\n\nwrite.table(table, par$output, col.names = FALSE, sep = \"\\t\")"
  },
  {
    "objectID": "documentation/guide/data-workflow/nextflow-pipeline/pipeline-advanced.html#building-the-modules",
    "href": "documentation/guide/data-workflow/nextflow-pipeline/pipeline-advanced.html#building-the-modules",
    "title": "Advanced Pipeline",
    "section": "Building the modules",
    "text": "Building the modules\nThe basic pipeline guide describes how to generate an individual VDSL3 Nextflow module using the viash build command, but there’s a better way when it comes to building multiple modules at once: viash ns build. Each one of the three components has its namespace defined as nextflow_modules inside of its config file. Execute this command from the root of the advanced_pipeline directory\nviash ns build\nThis will result in the following output:\nExporting take_column (nextflow_modules) =nextflow=> target/nextflow/nextflow_modules/take_column\nExporting combine_columns (nextflow_modules) =nextflow=> target/nextflow/nextflow_modules/combine_columns\nExporting remove_comments (nextflow_modules) =nextflow=> target/nextflow/nextflow_modules/remove_comments\nThe VDSL3 Nextflow modules were generated inside of a target folder. The directory structure now looks like this:\nadvanced_pipeline\n├── src\n│   └── nextflow_modules\n│       ├── combine_columns\n│       │   ├── config.vsh.yaml\n│       │   └── script.R\n│       ├── remove_comments\n│       │   ├── config.vsh.yaml\n│       │   └── script.sh\n│       └── take_column\n│           ├── config.vsh.yaml\n│           └── script.py\n└── target\n    └── nextflow\n        └── nextflow_modules\n            ├── combine_columns\n            │   ├── main.nf\n            │   └── nextflow.config\n            ├── remove_comments\n            │   ├── main.nf\n            │   └── nextflow.config\n            └── take_column\n                ├── main.nf\n                └── nextflow.config"
  },
  {
    "objectID": "documentation/guide/data-workflow/nextflow-pipeline/pipeline-advanced.html#creating-the-pipeline",
    "href": "documentation/guide/data-workflow/nextflow-pipeline/pipeline-advanced.html#creating-the-pipeline",
    "title": "Advanced Pipeline",
    "section": "Creating the pipeline",
    "text": "Creating the pipeline\nCreate a new file named main.nf and add it to the root of the advanced_pipeline directory. Use the following as its contents:\ntargetDir = \"../../target/nextflow\" // 1\n\n// 2\ninclude { remove_comments } from \"$targetDir/nextflow_modules/remove_comments/main.nf\"\ninclude { take_column } from \"$targetDir/nextflow_modules/take_column/main.nf\"\ninclude { combine_columns } from \"$targetDir/nextflow_modules/combine_columns/main.nf\"\n\nworkflow {\n  Channel.fromPath(params.input) // 3\n  \n    // 4\n    // File -> (String, File)\n    | map{ file -> [ file.baseName, file ] }\n    \n    // 5\n    // (String, File) -> (String, File)\n    | remove_comments\n\n    // 6\n    // (String, File) -> (String, File)\n    | take_column\n\n    // 7\n    // (String, File)* -> List[(String, File)]\n    | toList()\n\n    // 8\n    // List[(String, File)] -> (String, {input: List[File]})\n    | map{ tups -> \n      files = tups.collect{id, file -> file}\n      [ \"combined\", [ input: files ] ] \n    }\n\n    // 9\n    // (String, {input: List[File]}) -> (String, File)\n    | combine_columns.run(\n      auto: [ publish: true ]\n      )\n\n    // 10\n    | view{ file -> \"Output: $file\" }\n}\n\ntarget dir where the modules are located\ninclude the modules from the target directory\nCreate a channel based on the input parameter’s path\nAssign a unique ID to each event using map{}\nRun remove_comments to remove the comments from the TSV\nExtract a single column from TSV by running take_column\nCombine all events into a single List event using toList()\nAdd unique ID to the tuple\nConcatenate the TSVs into one by running the combine_columns module with auto publishing enabled using the auto directive to\nView the channel contents bu printing it to the console using view()"
  },
  {
    "objectID": "documentation/guide/data-workflow/nextflow-pipeline/pipeline-advanced.html#running-the-pipeline",
    "href": "documentation/guide/data-workflow/nextflow-pipeline/pipeline-advanced.html#running-the-pipeline",
    "title": "Advanced Pipeline",
    "section": "Running the pipeline",
    "text": "Running the pipeline\nbefore running, you need some TSV files to work with\nDownload file1.tsv\nDownload file2.tsv\nnow run the following command\nnextflow run main.nf --input \"data/file?.tsv\" --publishDir output\noutput\nN E X T F L O W  ~  version 22.04.3\nLaunching `workflows/310-realistic_pipeline/main.nf` [stupefied_saha] DSL2 - revision: 6669aefc6c\n[93/232aba] Submitted process > remove_comments:remove_comments_process (2)\n[ef/a28e89] Submitted process > remove_comments:remove_comments_process (1)\n[63/279f98] Submitted process > take_column:take_column_process (1)\n[50/2a17ef] Submitted process > take_column:take_column_process (2)\n[8d/6eeff5] Submitted process > combine_columns:combine_columns_process\nOutput: [combined, /home/runner/work/viash_nxf_course/viash_nxf_course/work/8d/6eeff571e9ff2c5389851c6ab3001c/combined.combine_columns.output]\na TSV file was generated in the output directory"
  },
  {
    "objectID": "documentation/guide/data-workflow/nextflow-pipeline/pipeline-basics.html",
    "href": "documentation/guide/data-workflow/nextflow-pipeline/pipeline-basics.html",
    "title": "Pipeline Basics",
    "section": "",
    "text": "explain this guide will go over the basics of VDSL3 and how to use modules inside of a Nextflow pipeline reference to the nextflow website for the basics of nextflow’s Groovy syntax"
  },
  {
    "objectID": "documentation/guide/data-workflow/nextflow-pipeline/pipeline-basics.html#vdsl3",
    "href": "documentation/guide/data-workflow/nextflow-pipeline/pipeline-basics.html#vdsl3",
    "title": "Pipeline Basics",
    "section": "VDSL3",
    "text": "VDSL3\nexplain what VDSL3 is and how it builds upon"
  },
  {
    "objectID": "documentation/guide/data-workflow/nextflow-pipeline/pipeline-basics.html#creating-the-module",
    "href": "documentation/guide/data-workflow/nextflow-pipeline/pipeline-basics.html#creating-the-module",
    "title": "Pipeline Basics",
    "section": "Creating the module",
    "text": "Creating the module\nNextflow works with modules to run scripts and handle their input and output, so the first step is generating a Nextflow module from a Viash component\n\nCreating the component\ncreate a new folder named basic_pipeline, add a new folder to it named src download the remove_comments component files and add them to src\nDownload config.vsh.yaml\nDownload script.sh\n\n\nBuilding the Nextflow module\nviash build src/remove_comments/config.vsh.yaml -o target/remove_comments"
  },
  {
    "objectID": "documentation/guide/data-workflow/nextflow-pipeline/pipeline-basics.html#creating-the-pipeline",
    "href": "documentation/guide/data-workflow/nextflow-pipeline/pipeline-basics.html#creating-the-pipeline",
    "title": "Pipeline Basics",
    "section": "Creating the pipeline",
    "text": "Creating the pipeline\nAdd main.nf:\ntargetDir = \"./target\" // 1\n\ninclude { remove_comments } from \"$targetDir/remove_comments/main.nf\" // 2\n\nworkflow {\n  Channel.fromPath(params.input) // 3\n    | map{ file -> [ file.baseName, file ] } // 4\n    | view{ file -> \"Input: $file\" } // 5\n    | remove_comments.run( // 6\n      auto: [ publish: true ]\n      )\n    | view{ file -> \"Output: $file\" } // 7\n}\nHere’s an overview of this Nextflow script:\n\ntarget dir where the modules are located\ninclude the remove_comments module from the remove_comments/main.nf script\nCreate a channel based on the input parameter’s path\nTake the tuple list and map it to the [ file.baseName, file ] format\nPrint the input tuple to the console\nRun the remove_comments module with auto publishing enabled using the auto directive\nPrint the output tuple to the console"
  },
  {
    "objectID": "documentation/guide/data-workflow/nextflow-pipeline/pipeline-basics.html#running-the-pipeline",
    "href": "documentation/guide/data-workflow/nextflow-pipeline/pipeline-basics.html#running-the-pipeline",
    "title": "Pipeline Basics",
    "section": "Running the pipeline",
    "text": "Running the pipeline\nnextflow run main.nf --input \"data/sample.tsv\" --publishDir output\nN E X T F L O W  ~  version 22.04.3\nLaunching `main.nf` [curious_gates] DSL2 - revision: 3e22e3038c\nexecutor >  local (1)\n[2a/5df658] process > remove_comments:remove_comments_process (1) [100%] 1 of 1 ✔\nInput: [sample, /home/blackdragonbe/GitHub/new_website/basic_pipeline/data/sample.tsv]\nOutput: [sample, /home/blackdragonbe/GitHub/new_website/basic_pipeline/work/2a/5df6584524e26995953a4eaec97136/sample.remove_comments.output.tsv]"
  },
  {
    "objectID": "documentation/guide/data-workflow/nextflow-pipeline/pipeline-basics.html#whats-next",
    "href": "documentation/guide/data-workflow/nextflow-pipeline/pipeline-basics.html#whats-next",
    "title": "Pipeline Basics",
    "section": "What’s next?",
    "text": "What’s next?\nthe pipeline in this guide was the bare minimum to learn more about\nAdvanced Pipeline"
  },
  {
    "objectID": "documentation/get-started/terminology.html",
    "href": "documentation/get-started/terminology.html",
    "title": "Terminology",
    "section": "",
    "text": "The reference below serves as a reference for the terms used throughout the guides and other pages.\n\n\n\n\n\n\n\nTerm\nDescription\n\n\n\n\nViash\nA software package that can generate smart executables and Nextflow modules.\n\n\nComponent\nAt minimum, the combination of a script and a config file. This can also include any needed resources and unit tests.\n\n\nConfig\nA YAML based file that holds all of the parameters needed to create a component.\n\n\nResource\nTools, helper scripts, templates and other files the component depends on to work.\n\n\nUnit test\nA small block of code to test a component.\n\n\nTarget\nAn executable or a VDSL3 module that’s generated by Viash.\n\n\n(VDSL3) Module\nA Nextflow module generated by Viash.\n\n\n(Viash) Executable\nAn executable script generated for the Native or Docker platform.\n\n\n(Docker) Image\nA standard unit of software that packages up the OS, code and its dependencies so the application runs quickly and reliably from one computing environment to another.\n\n\n(Docker) Container\nAn instance of a Docker image.\n\n\nPlatform\nThis is target platform. We currently support Native, Docker and Nextflow."
  },
  {
    "objectID": "documentation/get-started/basics.html",
    "href": "documentation/get-started/basics.html",
    "title": "Viash Basics",
    "section": "",
    "text": "This short tutorial will touch on the basic concepts of Viash. Before getting started, make sure you’ve installed Viash so you can follow along with the example."
  },
  {
    "objectID": "documentation/get-started/basics.html#what-is-viash",
    "href": "documentation/get-started/basics.html#what-is-viash",
    "title": "Viash Basics",
    "section": "What is Viash?",
    "text": "What is Viash?\nViash is … TODO: Add quick breakdown of the core of Viash"
  },
  {
    "objectID": "documentation/get-started/basics.html#hello-viash",
    "href": "documentation/get-started/basics.html#hello-viash",
    "title": "Viash Basics",
    "section": "Hello Viash!",
    "text": "Hello Viash!\nNow that you’re up to speed with what Viash is for, we have provided a quick example on how you can build and run a component. A minimal components consists of a script that holds the logic and a Viash config file to describe the component with metadata.\n\nRequirements\nThe example targets the Native platform, which means you will need to have the required packages installed on your system depending on your chosen scripting language. If you are using any of the languages on your system, there’s a good chance you already meet the requirements. To get up and running quickly, we recommend using Bash.\n\nBashC#JavaScriptPythonScalaR\n\n\n\nA Bash Unix shell (built into Linux, macOS and WSL2)\n\n\n\n\nA Bash Unix shell (built into Linux, macOS and WSL2)\nDownload and install .NET Core.\nRun dotnet tool install -g dotnet-script to enable the C# scripting functionality.\n\n\n\n\nA Bash Unix shell (built into Linux, macOS and WSL2)\nDownload and install Node.js.\nExecute the following command to install the required npm packages: npm install --save needle markdown-link-extractor\n\n\n\n\nA Bash Unix shell (built into Linux, macOS and WSL2)\nInstall Python 3.8 or newer. You may have to install the python-is-python3 package on Ubuntu and its derivatives.\n\n\n\n\nA Bash Unix shell (built into Linux, macOS and WSL2)\nInstall Scala 2.\n\n\n\n\nA Bash Unix shell (built into Linux, macOS and WSL2)\nInstall the R software environment\n\n\n\n\n\n\nWriting the script\nFor this example, you’ll use a tiny script that simply outputs “Hello Viash”, with the “Viash” part being a variable. To start off, create a folder named hello_viash and follow the instructions below based on your preferred scripting language.\n\nBashC#JavaScriptPythonScalaR\n\n\nCreate a new file named script.sh and copy the following content inside of it:\necho \"Hello $par_input\"\nThis outputs Hello to the console, followed by an input variable. Notice that this variable isn’t defined in the script itself as Viash will generate it for you based on the config file you’ll create in the next step.\n\n\n\n\n\n\nTip\n\n\n\nEvery scripting language has its own way of using variables generated by Viash. Check out the Bash page for more information and examples.\n\n\n\n\nCreate script.csx\nConsole.WriteLine(\"Hello \" + par.input);\nThis outputs Hello to the console, followed by an input variable. Notice that this variable isn’t defined in the script itself as Viash will generate it for you based on the config file you’ll create in the next step.\n\n\n\n\n\n\nTip\n\n\n\nEvery scripting language has its own way of using variables generated by Viash. Check out the C# page for more information and examples.\n\n\n\n\nCreate script.js\nconsole.log('Hello' + par['input']);\nThis outputs Hello to the console, followed by an input variable. Notice that this variable isn’t defined in the script itself as Viash will generate it for you based on the config file you’ll create in the next step.\n\n\n\n\n\n\nTip\n\n\n\nEvery scripting language has its own way of using variables generated by Viash. Check out the JavaScript page for more information and examples.\n\n\n\n\nCreate script.py\nprint(\"Hello\", par[\"input\"])\nThis outputs Hello to the console, followed by an input variable. Notice that this variable isn’t defined in the script itself as Viash will generate it for you based on the config file you’ll create in the next step.\n\n\n\n\n\n\nTip\n\n\n\nEvery scripting language has its own way of using variables generated by Viash. Check out the Python page for more information and examples.\n\n\n\n\nCreate script.scala\nprintln(\"Hello \" + par.input.get)\nThis outputs Hello to the console, followed by an input variable. Notice that this variable isn’t defined in the script itself as Viash will generate it for you based on the config file you’ll create in the next step.\n\n\n\n\n\n\nTip\n\n\n\nEvery scripting language has its own way of using variables generated by Viash. Check out the Scala page for more information and examples.\n\n\n\n\nCreate script.R\ncat(\"Hello \", par$input)\nThis outputs Hello to the console, followed by an input variable. Notice that this variable isn’t defined in the script itself as Viash will generate it for you based on the config file you’ll create in the next step.\n\n\n\n\n\n\nTip\n\n\n\nEvery scripting language has its own way of using variables generated by Viash. Check out the R page for more information and examples.\n\n\n\n\n\n\n\nAdding the config\nA Viash config file is a YAML file that describes the functionality of a component and the platform(s) it targets. Create a file name config.vsh.yaml and add the contents below based on your chosen scripting language.\n\nBashC#JavaScriptPythonScalaR\n\n\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: bash_script\n    path: script.sh\nplatforms:\n  - type: native\n\n\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: csharp_script\n    path: script.csx\nplatforms:\n  - type: native\n\n\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: javascript_script\n    path: script.js\nplatforms:\n  - type: native\n\n\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: python_script\n    path: script.py\nplatforms:\n  - type: native\n\n\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: scala_script\n    path: script.scala\nplatforms:\n  - type: native\n\n\nDownload config.vsh.yaml\nfunctionality:\n  name: hello_world\n  description: A minimal example component.\n  arguments:\n  - type: string\n    name: --input\n    default: \"World\"\n  resources:\n  - type: r_script\n    path: script.R\nplatforms:\n  - type: native\n\n\n\nHere’s a breakdown of the different sections:\n\nfunctionality describes what the component does and the resources it needs. It contains the name, a short description and more importantly, the arguments and resources the component uses.\n\narguments contains all arguments the component accepts and will be passed to the script. In this case, a single string named --input resides here with a default value of Viash.\nresources holds references to all necessary files and folders to make the component work. For this example, a single script is all that’s needed.\n\nplatforms lists what platforms the component can target. This example targets the native platform, which will generate an executable that’s run using the system resources.\n\n\n\nRunning\nWith the two necessary files present to create a component, you can call upon Viash to generate a temporary executable and run it:\nviash run config.vsh.yaml\nWithout passing any arguments, this will use the default value for --input, which is Viash. This results in the following output:\nHello Viash\nBy providing the a value for --input, you can customize the greeting:\nviash run config.vsh.yaml -- --input World\n\n\n\n\n\n\nNote\n\n\n\nThe double dash (--) between the viash command and the arguments is used to signify the end of the arguments passed to viash and the start of those passed to the component. If you forgot to add these, you’ll get an error similar to this:\n[scallop] Error: Unknown option 'input'\n\n\nThe example above results in this output:\nHello World"
  },
  {
    "objectID": "documentation/get-started/basics.html#whats-next",
    "href": "documentation/get-started/basics.html#whats-next",
    "title": "Viash Basics",
    "section": "What’s next?",
    "text": "What’s next?\nCheck out our guide for learning more about Viash. To learn more about the Viash commands and the config file, take a look at our API section."
  },
  {
    "objectID": "documentation/faq/rmarkdown.html",
    "href": "documentation/faq/rmarkdown.html",
    "title": "FAQ for R Markdown Users",
    "section": "",
    "text": "Quarto sounds similar to R Markdown. What is the difference and why create a new project?\nAt its core, Quarto works the same way as R Markdown: \n\nThe goal of Quarto is to make the process of creating and collaborating on scientific and technical documents dramatically better. Quarto combines the functionality of R Markdown, bookdown, distill, xaringian, etc into a single consistent system with “batteries included” that reflects everything we’ve learned from R Markdown over the past 10 years.\nThe number of languages and runtimes used for scientific discourse is very broad (and the Jupyter ecosystem in particular is extraordinarily popular). Quarto is at its core multi-language and multi-engine (supporting Knitr, Jupyter, and Observable today and potentially other engines tomorrow).\nOn the other hand, R Markdown is fundamentally tied to R which severely limits the number of practitioners it can benefit. Quarto is RStudio’s attempt to bring R Markdown to everyone! Unlike R Markdown, Quarto doesn’t have a dependency or requirement for R. Quarto was developed to be multilingual, beginning with R, Python, JavaScript, and Julia, with the idea that it will work even for languages that don’t yet exist.\nWhile it is a “new” system, it should also be noted that it is highly compatible with existing content: you can render most R Markdown documents and Jupyter notebooks unmodified with Quarto. The concept is to make a major, long term investment in reproducible research, while keeping it compatible with existing formats and adaptable to the various environments users work in.\n\n\nIs R Markdown going away? Will my R Markdown documents continue to work?\nR Markdown is not going away! R Markdown is used extensively and continues to work well. It will continue to be actively supported. We’re not leaving R Markdown, we’re expanding our scope. Over the years there have been many feature requests, and rather than implementing them all in R Markdown, for certain features we may refer you to Quarto. Everything that is currently in R Markdown will continue to work and be supported. There are no plans for deprecation.\nRead more about this in Yihui Xie’s blog post With Quarto Coming, is R Markdown Going Away? No.\n\n\nShould I switch from R Markdown to Quarto?\nIf you like using R Markdown, there’s no need to switch! R Markdown will continue to be supported and work as it always has been. You’re welcome to try Quarto if you like, but there’s no need to switch. Some new features may only exist in Quarto, so if you want to use those, then that’s where you would give those a try.  \nWe should emphasize that switching is not imperative. While we don’t plan on major feature initiatives in R Markdown and related packages, we are going to continue to maintain them (smaller improvements and bug fixes) for a long time to come. Furthermore, since Rmd files can in most cases be rendered without modification by Quarto, you can continue using R Markdown and the switching cost will still be minimal whenever you decide to do it. \n\n\nI use X (bookdown, blogdown, etc.). What is the Quarto equivalent?\nHere are the Quarto equivalents for various packages and features of the R Markdown ecosystem (in some cases Quarto equivalents are not yet available but will be later this year):\n\n\n\n\nFeature\nR Markdown\nQuarto\n\n\n\n\nBasic Formats\n\nhtml_document\npdf_document\nword_document\n\n\nhtml\npdf\ndocx\n\n\n\nBeamer\n\nbeamer_presentation\n\n\nbeamer\n\n\n\nPowerPoint\n\npowerpoint_presentation\n\n\npptx\n\n\n\nHTML Slides\n\nxaringan\nioslides\nrevealjs\n\n\nrevealjs\n\n\n\nAdvanced Layout\n\ntufte\ndistill\n\n\nQuarto Article Layout\n\n\n\nCross References\n\nhtml_document2\npdf_document2\nword_document2\n\n\nQuarto Crossrefs\n\n\n\nWebsites & Blogs\n\nblogdown\ndistill\n\n\nQuarto Websites\nQuarto Blogs\n\n\n\nBooks\n\nbookdown\n\n\nQuarto Books\n\n\n\nInteractivity\nShiny Documents\nQuarto Interactive Documents\n\n\nPaged HTML\npagedown\nSummer 2022\n\n\nJournal Articles\nrticles\nSummer 2022\n\n\nDashboards\nflexdashboard\nFall 2022\n\n\nInteractive Tutorials\nlearnr\nNo equivalent planned\n\n\n\n\n\n\nCan you create custom formats for Quarto like you can for R Markdown?\nNot currently, but we expect that this capability will be available in version 1.0 of Quarto (which will be available before rstudio::conf in July).\n\n\nWhen would be a good time to start new projects in Quarto rather than R Markdown?\nOur current plan is to announce Quarto v1.0 at rstudio::conf (end of July). This will be a stable release that will be an excellent foundation for starting new projects with Quarto or migrating existing R Markdown projects (if you are so inclined).\n\n\nDoes the RStudio IDE support Quarto?\nYes! You need to use the latest release of RStudio (v2022.02), which includes support for editing and preview of Quarto documents.\nYou can download RStudio v2022.02 from https://rstudio.com/products/rstudio/download/.\n\n\nDoes RStudio Connect support Quarto?\nYes! You can publish Quarto content to RStudio Connect v2021.08.0 or later. Quarto has to be enabled as documented in the RStudio Connect admin guide. Connect’s user documentation refers to Quarto.org docs on how to publish from the RStudio IDE. To publish Python-based Quarto content, you can use the rsconnect-python CLI from various locations, including VSCode, JupyterLab or the terminal."
  },
  {
    "objectID": "documentation/faq/index.html",
    "href": "documentation/faq/index.html",
    "title": "Frequently Asked Questions",
    "section": "",
    "text": "What can I use Quarto for?\nQuarto® is an open-source scientific and technical publishing system built on Pandoc. You can weave together narrative text and code to produce elegantly formatted output as documents, web pages, blog posts, books and more. \n\n\n\nHow do I install Quarto?\nVisit the Quarto.org Get Started page, which provides installation instructions for Windows, Mac OS, and Linux. \n\n\n\nIs Quarto free to use?\nYes! Quarto is open source with a GPL-2 license. You can use or disseminate it any way that you would any GPL-2 licensed open source software. \n\n\nWhat output formats can Quarto create?\nThere are many output formats available in Quarto. This includes all of the built in Pandoc formats (e.g. HTML, PDF, MS Word, Revealjs, ePub, etc.) as well as various ways to publish multiple documents (websites, blogs, and books). Learn more at Quarto Formats. \n\n\nWhat editing tools can I use with Quarto?\nYou can use a wide variety of tools with Quarto. We have provided documentation for writing and editing Quarto documents in VSCode, JupyterLab, RStudio IDE, or any text editor. Visit the Get Started with Quarto page to install, and then choose your tool for a brief introductory guide.\n\n\nCan I use Jupyter notebooks with Quarto?\nYes! Quarto can render Jupyter notebooks and you can use Jupyter, JupyterLab or any other .ipynb notebook editor with Quarto. You can render existing .ipynb notebooks as-is with Quarto, but adding Quarto-specific output options or a YAML header can enhance the output. Visit theJupyterLab page for more information.\n\n\nWhat programming languages are supported in Quarto?\nThe principal languages supported by Quarto are Python, R, Julia, and Observable JavaScript. Integration with Jupyter also enables the use of many other languages. \nEach Quarto document can be optionally processed by a computational engine (the engine can be manually specified or automatically detected based on the code chunks within). Current engines include Knitr (which is also used by R Markdown and supports a variety of languages including R, Python, and Julia, etc.) and Jupyter (which supports many languages including Python, Julia, and R). See the documentation on Engine Binding for additional details.\n\n\nWhat human languages are supported in Quarto?\nYou can write your Quarto documentation in your human language of choice. The lang document option is used to identify the main language of the document using IETF language tags (following the BCP 47 standard), such as en or en-GB. \n\n\nHow can I share documents and have people comment on them?\nYou can publish Quarto content to various locations. See the user guides for publishing documents and publishing websites  for details on using GitHub Pages, Netlify, RStudio Connect, and other services. with Quarto. Once documents are published you can use  hypothes.is, Utterances, or Giscus for commenting. Learn more in the documentation on commenting.\n\n\nCan I do collaborative editing with Quarto?\nThere is not yet anything specific for collaborative editing in Quarto. You can collaborate on .qmd files in the same way you currently do for any text or code files. \nRStudio Workbench allows for Project Sharing for interactive editing and collaboration on the same document.\n\n\nWhere can I publish Quarto websites?\nThere are a wide variety of ways to publish Quarto websites. Website content is by default written to the _site sub-directory (you can customize this using the output-dir option). Publishing is simply a matter of copying the output directory to a web server or web hosting service.\nThe publishing documentation describes several convenient options for Quarto website deployment including RStudio Connect, Netlify, GitHub Pages, Firebase, Site44, and Amazon S3. We’ll mostly defer to the documentation provided by those various services, but will note any Quarto website specific configuration required.\n\n\nDoes RStudio Connect support Quarto?\nYes! You can publish Quarto content to RStudio Connect v2021.08.0 or later. Quarto has to be enabled as documented in the RStudio Connect admin guide. Connect’s user documentation refers to Quarto.org docs on how to publish from the RStudio IDE. To publish Python-based Quarto content, you can use the rsconnect-python CLI from various locations, including VSCode, JupyterLab or the terminal.\n\n\nWho are the developers of Quarto?\nDevelopment of Quarto is sponsored by RStudio, PBC. The same core team works on both Quarto and R Markdown:\n\nCarlos Scheidegger (@cscheid)\nCharles Teague (@dragonstyle)\nChristophe Dervieux (@cderv)\nJ.J. Allaire (@jjallaire)\nYihui Xie (@yihui)\n\nHere is the full contributors list. Quarto is open source and we welcome contributions in our github repository as well! https://github.com/quarto-dev/quarto-cli.\n\n\nWhy the name Quarto?\nWe wanted to use a name that had meaning in the history of publishing and landed on Quarto, which is the format of a book or pamphlet produced from full sheets printed with eight pages of text, four to a side, then folded twice to produce four leaves. The earliest known European printed book is a Quarto, the Sibyllenbuch, believed to have been printed by Johannes Gutenberg in 1452–53.\n\n\nWhere can I report bugs or request features?\nThanks for finding something and sharing with us! You can file an issue in the Quarto repository https://github.com/quarto-dev/quarto-cli/issues.\n\n\nWhere can I ask questions and discuss using Quarto with others?\nThe best place to ask questions and see what questions other people have is in Quarto discussions (https://github.com/quarto-dev/quarto-cli/discussions)."
  },
  {
    "objectID": "documentation/reference/config/arguments/file.html",
    "href": "documentation/reference/config/arguments/file.html",
    "title": "File",
    "section": "",
    "text": "Type: String / List of String"
  },
  {
    "objectID": "documentation/reference/config/arguments/file.html#default",
    "href": "documentation/reference/config/arguments/file.html#default",
    "title": "File",
    "section": "default",
    "text": "default\nType: Path / List of Path"
  },
  {
    "objectID": "documentation/reference/config/arguments/file.html#description",
    "href": "documentation/reference/config/arguments/file.html#description",
    "title": "File",
    "section": "description",
    "text": "description\nType: String"
  },
  {
    "objectID": "documentation/reference/config/arguments/file.html#direction",
    "href": "documentation/reference/config/arguments/file.html#direction",
    "title": "File",
    "section": "direction",
    "text": "direction\nType: Direction"
  },
  {
    "objectID": "documentation/reference/config/arguments/file.html#example",
    "href": "documentation/reference/config/arguments/file.html#example",
    "title": "File",
    "section": "example",
    "text": "example\nType: Path / List of Path"
  },
  {
    "objectID": "documentation/reference/config/arguments/file.html#multiple",
    "href": "documentation/reference/config/arguments/file.html#multiple",
    "title": "File",
    "section": "multiple",
    "text": "multiple\nType: Boolean"
  },
  {
    "objectID": "documentation/reference/config/arguments/file.html#multiple_sep",
    "href": "documentation/reference/config/arguments/file.html#multiple_sep",
    "title": "File",
    "section": "multiple_sep",
    "text": "multiple_sep\nType: Char"
  },
  {
    "objectID": "documentation/reference/config/arguments/file.html#must_exist",
    "href": "documentation/reference/config/arguments/file.html#must_exist",
    "title": "File",
    "section": "must_exist",
    "text": "must_exist\nType: Boolean"
  },
  {
    "objectID": "documentation/reference/config/arguments/file.html#name",
    "href": "documentation/reference/config/arguments/file.html#name",
    "title": "File",
    "section": "name",
    "text": "name\nType: String"
  },
  {
    "objectID": "documentation/reference/config/arguments/file.html#required",
    "href": "documentation/reference/config/arguments/file.html#required",
    "title": "File",
    "section": "required",
    "text": "required\nType: Boolean"
  },
  {
    "objectID": "documentation/reference/config/arguments/file.html#type",
    "href": "documentation/reference/config/arguments/file.html#type",
    "title": "File",
    "section": "type",
    "text": "type\nType: String"
  },
  {
    "objectID": "documentation/reference/config/arguments/double.html",
    "href": "documentation/reference/config/arguments/double.html",
    "title": "Double",
    "section": "",
    "text": "Type: String / List of String"
  },
  {
    "objectID": "documentation/reference/config/arguments/double.html#default",
    "href": "documentation/reference/config/arguments/double.html#default",
    "title": "Double",
    "section": "default",
    "text": "default\nType: Double / List of Double"
  },
  {
    "objectID": "documentation/reference/config/arguments/double.html#description",
    "href": "documentation/reference/config/arguments/double.html#description",
    "title": "Double",
    "section": "description",
    "text": "description\nType: String"
  },
  {
    "objectID": "documentation/reference/config/arguments/double.html#direction",
    "href": "documentation/reference/config/arguments/double.html#direction",
    "title": "Double",
    "section": "direction",
    "text": "direction\nType: Direction"
  },
  {
    "objectID": "documentation/reference/config/arguments/double.html#example",
    "href": "documentation/reference/config/arguments/double.html#example",
    "title": "Double",
    "section": "example",
    "text": "example\nType: Double / List of Double"
  },
  {
    "objectID": "documentation/reference/config/arguments/double.html#max",
    "href": "documentation/reference/config/arguments/double.html#max",
    "title": "Double",
    "section": "max",
    "text": "max\nType: Double"
  },
  {
    "objectID": "documentation/reference/config/arguments/double.html#min",
    "href": "documentation/reference/config/arguments/double.html#min",
    "title": "Double",
    "section": "min",
    "text": "min\nType: Double"
  },
  {
    "objectID": "documentation/reference/config/arguments/double.html#multiple",
    "href": "documentation/reference/config/arguments/double.html#multiple",
    "title": "Double",
    "section": "multiple",
    "text": "multiple\nType: Boolean"
  },
  {
    "objectID": "documentation/reference/config/arguments/double.html#multiple_sep",
    "href": "documentation/reference/config/arguments/double.html#multiple_sep",
    "title": "Double",
    "section": "multiple_sep",
    "text": "multiple_sep\nType: Char"
  },
  {
    "objectID": "documentation/reference/config/arguments/double.html#name",
    "href": "documentation/reference/config/arguments/double.html#name",
    "title": "Double",
    "section": "name",
    "text": "name\nType: String"
  },
  {
    "objectID": "documentation/reference/config/arguments/double.html#required",
    "href": "documentation/reference/config/arguments/double.html#required",
    "title": "Double",
    "section": "required",
    "text": "required\nType: Boolean"
  },
  {
    "objectID": "documentation/reference/config/arguments/double.html#type",
    "href": "documentation/reference/config/arguments/double.html#type",
    "title": "Double",
    "section": "type",
    "text": "type\nType: String"
  },
  {
    "objectID": "documentation/reference/config/arguments/boolean.html",
    "href": "documentation/reference/config/arguments/boolean.html",
    "title": "Boolean",
    "section": "",
    "text": "Type: String / List of String"
  },
  {
    "objectID": "documentation/reference/config/arguments/boolean.html#default",
    "href": "documentation/reference/config/arguments/boolean.html#default",
    "title": "Boolean",
    "section": "default",
    "text": "default\nType: Boolean / List of Boolean"
  },
  {
    "objectID": "documentation/reference/config/arguments/boolean.html#description",
    "href": "documentation/reference/config/arguments/boolean.html#description",
    "title": "Boolean",
    "section": "description",
    "text": "description\nType: String"
  },
  {
    "objectID": "documentation/reference/config/arguments/boolean.html#direction",
    "href": "documentation/reference/config/arguments/boolean.html#direction",
    "title": "Boolean",
    "section": "direction",
    "text": "direction\nType: Direction"
  },
  {
    "objectID": "documentation/reference/config/arguments/boolean.html#example",
    "href": "documentation/reference/config/arguments/boolean.html#example",
    "title": "Boolean",
    "section": "example",
    "text": "example\nType: Boolean / List of Boolean"
  },
  {
    "objectID": "documentation/reference/config/arguments/boolean.html#multiple",
    "href": "documentation/reference/config/arguments/boolean.html#multiple",
    "title": "Boolean",
    "section": "multiple",
    "text": "multiple\nType: Boolean"
  },
  {
    "objectID": "documentation/reference/config/arguments/boolean.html#multiple_sep",
    "href": "documentation/reference/config/arguments/boolean.html#multiple_sep",
    "title": "Boolean",
    "section": "multiple_sep",
    "text": "multiple_sep\nType: Char"
  },
  {
    "objectID": "documentation/reference/config/arguments/boolean.html#name",
    "href": "documentation/reference/config/arguments/boolean.html#name",
    "title": "Boolean",
    "section": "name",
    "text": "name\nType: String"
  },
  {
    "objectID": "documentation/reference/config/arguments/boolean.html#required",
    "href": "documentation/reference/config/arguments/boolean.html#required",
    "title": "Boolean",
    "section": "required",
    "text": "required\nType: Boolean"
  },
  {
    "objectID": "documentation/reference/config/arguments/boolean.html#type",
    "href": "documentation/reference/config/arguments/boolean.html#type",
    "title": "Boolean",
    "section": "type",
    "text": "type\nType: String"
  },
  {
    "objectID": "documentation/reference/config/arguments/boolean_true.html",
    "href": "documentation/reference/config/arguments/boolean_true.html",
    "title": "Boolean_True",
    "section": "",
    "text": "Type: String / List of String"
  },
  {
    "objectID": "documentation/reference/config/arguments/boolean_true.html#description",
    "href": "documentation/reference/config/arguments/boolean_true.html#description",
    "title": "Boolean_True",
    "section": "description",
    "text": "description\nType: String"
  },
  {
    "objectID": "documentation/reference/config/arguments/boolean_true.html#direction",
    "href": "documentation/reference/config/arguments/boolean_true.html#direction",
    "title": "Boolean_True",
    "section": "direction",
    "text": "direction\nType: Direction"
  },
  {
    "objectID": "documentation/reference/config/arguments/boolean_true.html#name",
    "href": "documentation/reference/config/arguments/boolean_true.html#name",
    "title": "Boolean_True",
    "section": "name",
    "text": "name\nType: String"
  },
  {
    "objectID": "documentation/reference/config/arguments/boolean_true.html#type",
    "href": "documentation/reference/config/arguments/boolean_true.html#type",
    "title": "Boolean_True",
    "section": "type",
    "text": "type\nType: String"
  },
  {
    "objectID": "documentation/reference/config/arguments/integer.html",
    "href": "documentation/reference/config/arguments/integer.html",
    "title": "Integer",
    "section": "",
    "text": "Type: String / List of String"
  },
  {
    "objectID": "documentation/reference/config/arguments/integer.html#choices",
    "href": "documentation/reference/config/arguments/integer.html#choices",
    "title": "Integer",
    "section": "choices",
    "text": "choices\nType: List of Int"
  },
  {
    "objectID": "documentation/reference/config/arguments/integer.html#default",
    "href": "documentation/reference/config/arguments/integer.html#default",
    "title": "Integer",
    "section": "default",
    "text": "default\nType: Int / List of Int"
  },
  {
    "objectID": "documentation/reference/config/arguments/integer.html#description",
    "href": "documentation/reference/config/arguments/integer.html#description",
    "title": "Integer",
    "section": "description",
    "text": "description\nType: String"
  },
  {
    "objectID": "documentation/reference/config/arguments/integer.html#direction",
    "href": "documentation/reference/config/arguments/integer.html#direction",
    "title": "Integer",
    "section": "direction",
    "text": "direction\nType: Direction"
  },
  {
    "objectID": "documentation/reference/config/arguments/integer.html#example",
    "href": "documentation/reference/config/arguments/integer.html#example",
    "title": "Integer",
    "section": "example",
    "text": "example\nType: Int / List of Int"
  },
  {
    "objectID": "documentation/reference/config/arguments/integer.html#max",
    "href": "documentation/reference/config/arguments/integer.html#max",
    "title": "Integer",
    "section": "max",
    "text": "max\nType: Int"
  },
  {
    "objectID": "documentation/reference/config/arguments/integer.html#min",
    "href": "documentation/reference/config/arguments/integer.html#min",
    "title": "Integer",
    "section": "min",
    "text": "min\nType: Int"
  },
  {
    "objectID": "documentation/reference/config/arguments/integer.html#multiple",
    "href": "documentation/reference/config/arguments/integer.html#multiple",
    "title": "Integer",
    "section": "multiple",
    "text": "multiple\nType: Boolean"
  },
  {
    "objectID": "documentation/reference/config/arguments/integer.html#multiple_sep",
    "href": "documentation/reference/config/arguments/integer.html#multiple_sep",
    "title": "Integer",
    "section": "multiple_sep",
    "text": "multiple_sep\nType: Char"
  },
  {
    "objectID": "documentation/reference/config/arguments/integer.html#name",
    "href": "documentation/reference/config/arguments/integer.html#name",
    "title": "Integer",
    "section": "name",
    "text": "name\nType: String"
  },
  {
    "objectID": "documentation/reference/config/arguments/integer.html#required",
    "href": "documentation/reference/config/arguments/integer.html#required",
    "title": "Integer",
    "section": "required",
    "text": "required\nType: Boolean"
  },
  {
    "objectID": "documentation/reference/config/arguments/integer.html#type",
    "href": "documentation/reference/config/arguments/integer.html#type",
    "title": "Integer",
    "section": "type",
    "text": "type\nType: String"
  },
  {
    "objectID": "documentation/reference/config/arguments/boolean_false.html",
    "href": "documentation/reference/config/arguments/boolean_false.html",
    "title": "Boolean_False",
    "section": "",
    "text": "Type: String / List of String"
  },
  {
    "objectID": "documentation/reference/config/arguments/boolean_false.html#description",
    "href": "documentation/reference/config/arguments/boolean_false.html#description",
    "title": "Boolean_False",
    "section": "description",
    "text": "description\nType: String"
  },
  {
    "objectID": "documentation/reference/config/arguments/boolean_false.html#direction",
    "href": "documentation/reference/config/arguments/boolean_false.html#direction",
    "title": "Boolean_False",
    "section": "direction",
    "text": "direction\nType: Direction"
  },
  {
    "objectID": "documentation/reference/config/arguments/boolean_false.html#name",
    "href": "documentation/reference/config/arguments/boolean_false.html#name",
    "title": "Boolean_False",
    "section": "name",
    "text": "name\nType: String"
  },
  {
    "objectID": "documentation/reference/config/arguments/boolean_false.html#type",
    "href": "documentation/reference/config/arguments/boolean_false.html#type",
    "title": "Boolean_False",
    "section": "type",
    "text": "type\nType: String"
  },
  {
    "objectID": "documentation/reference/config/arguments/string.html",
    "href": "documentation/reference/config/arguments/string.html",
    "title": "String",
    "section": "",
    "text": "Type: String / List of String"
  },
  {
    "objectID": "documentation/reference/config/arguments/string.html#choices",
    "href": "documentation/reference/config/arguments/string.html#choices",
    "title": "String",
    "section": "choices",
    "text": "choices\nType: List of String"
  },
  {
    "objectID": "documentation/reference/config/arguments/string.html#default",
    "href": "documentation/reference/config/arguments/string.html#default",
    "title": "String",
    "section": "default",
    "text": "default\nType: String / List of String"
  },
  {
    "objectID": "documentation/reference/config/arguments/string.html#description",
    "href": "documentation/reference/config/arguments/string.html#description",
    "title": "String",
    "section": "description",
    "text": "description\nType: String"
  },
  {
    "objectID": "documentation/reference/config/arguments/string.html#direction",
    "href": "documentation/reference/config/arguments/string.html#direction",
    "title": "String",
    "section": "direction",
    "text": "direction\nType: Direction"
  },
  {
    "objectID": "documentation/reference/config/arguments/string.html#example",
    "href": "documentation/reference/config/arguments/string.html#example",
    "title": "String",
    "section": "example",
    "text": "example\nType: String / List of String"
  },
  {
    "objectID": "documentation/reference/config/arguments/string.html#multiple",
    "href": "documentation/reference/config/arguments/string.html#multiple",
    "title": "String",
    "section": "multiple",
    "text": "multiple\nType: Boolean"
  },
  {
    "objectID": "documentation/reference/config/arguments/string.html#multiple_sep",
    "href": "documentation/reference/config/arguments/string.html#multiple_sep",
    "title": "String",
    "section": "multiple_sep",
    "text": "multiple_sep\nType: Char"
  },
  {
    "objectID": "documentation/reference/config/arguments/string.html#name",
    "href": "documentation/reference/config/arguments/string.html#name",
    "title": "String",
    "section": "name",
    "text": "name\nType: String"
  },
  {
    "objectID": "documentation/reference/config/arguments/string.html#required",
    "href": "documentation/reference/config/arguments/string.html#required",
    "title": "String",
    "section": "required",
    "text": "required\nType: Boolean"
  },
  {
    "objectID": "documentation/reference/config/arguments/string.html#type",
    "href": "documentation/reference/config/arguments/string.html#type",
    "title": "String",
    "section": "type",
    "text": "type\nType: String"
  },
  {
    "objectID": "documentation/reference/config/platforms/dockerPlatform.html",
    "href": "documentation/reference/config/platforms/dockerPlatform.html",
    "title": "Docker Platform",
    "section": "",
    "text": "Run a Viash component on a Docker backend platform. By specifying which dependencies your component needs, users will be able to build a docker container from scratch using the setup flag, or pull it from a docker repository."
  },
  {
    "objectID": "documentation/reference/config/platforms/dockerPlatform.html#apk",
    "href": "documentation/reference/config/platforms/dockerPlatform.html#apk",
    "title": "Docker Platform",
    "section": "apk",
    "text": "apk\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.5.15. Use setup instead.\n\n\nType: ApkRequirements\nSpecify which apk packages should be available in order to run the component.\n\nExample(s)\nsetup:\n  - type: apk\n    packages: [ sl ]"
  },
  {
    "objectID": "documentation/reference/config/platforms/dockerPlatform.html#apt",
    "href": "documentation/reference/config/platforms/dockerPlatform.html#apt",
    "title": "Docker Platform",
    "section": "apt",
    "text": "apt\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.5.15. Use setup instead.\n\n\nType: AptRequirements\nSpecify which apt packages should be available in order to run the component.\n\nExample(s)\nsetup:\n  - type: apt\n    packages: [ sl ]"
  },
  {
    "objectID": "documentation/reference/config/platforms/dockerPlatform.html#chown",
    "href": "documentation/reference/config/platforms/dockerPlatform.html#chown",
    "title": "Docker Platform",
    "section": "chown",
    "text": "chown\nType: Boolean\nIn Linux, files created by a Docker container will be owned by root. With chown: true, Viash will automatically change the ownership of output files (arguments with type: file and direction: output) to the user running the Viash command after execution of the component. Default value: true.\n\nExample(s)\nchown: false"
  },
  {
    "objectID": "documentation/reference/config/platforms/dockerPlatform.html#docker",
    "href": "documentation/reference/config/platforms/dockerPlatform.html#docker",
    "title": "Docker Platform",
    "section": "docker",
    "text": "docker\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.5.15. Use setup instead.\n\n\nType: DockerRequirements\nSpecify which Docker commands should be run during setup.\n\nExample(s)\nsetup:\n  - type: docker\n    build_args: [ GITHUB_PAT=hello_world ]\n    run: [ git clone ... ]\n    add: [ \"http://foo.bar .\" ]\n    copy: [ \"http://foo.bar .\" ]\n    resources: \n      - resource.txt /path/to/resource.txt"
  },
  {
    "objectID": "documentation/reference/config/platforms/dockerPlatform.html#id",
    "href": "documentation/reference/config/platforms/dockerPlatform.html#id",
    "title": "Docker Platform",
    "section": "id",
    "text": "id\nType: String\nAs with all platforms, you can give a platform a different name. By specifying id: foo, you can target this platform (only) by specifying -p foo in any of the Viash commands.\n\nExample(s)\nid: foo"
  },
  {
    "objectID": "documentation/reference/config/platforms/dockerPlatform.html#image",
    "href": "documentation/reference/config/platforms/dockerPlatform.html#image",
    "title": "Docker Platform",
    "section": "image",
    "text": "image\nType: String\nThe base container to start from. You can also add the tag here if you wish.\n\nExample(s)\nimage: \"bash:4.0\""
  },
  {
    "objectID": "documentation/reference/config/platforms/dockerPlatform.html#namespace_separator",
    "href": "documentation/reference/config/platforms/dockerPlatform.html#namespace_separator",
    "title": "Docker Platform",
    "section": "namespace_separator",
    "text": "namespace_separator\nType: String\nThe default namespace separator is “_“.\n\nExample(s)\nnamespace_separator: \"+\""
  },
  {
    "objectID": "documentation/reference/config/platforms/dockerPlatform.html#organization",
    "href": "documentation/reference/config/platforms/dockerPlatform.html#organization",
    "title": "Docker Platform",
    "section": "organization",
    "text": "organization\nType: String\nName of a container’s organization."
  },
  {
    "objectID": "documentation/reference/config/platforms/dockerPlatform.html#port",
    "href": "documentation/reference/config/platforms/dockerPlatform.html#port",
    "title": "Docker Platform",
    "section": "port",
    "text": "port\nType: String / List of String\nA list of enabled ports. This doesn’t change the Dockerfile but gets added as a command-line argument at runtime.\n\nExample(s)\nport:\n  - 80\n  - 8080"
  },
  {
    "objectID": "documentation/reference/config/platforms/dockerPlatform.html#python",
    "href": "documentation/reference/config/platforms/dockerPlatform.html#python",
    "title": "Docker Platform",
    "section": "python",
    "text": "python\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.5.15. Use setup instead.\n\n\nType: PythonRequirements\nSpecify which Python packages should be available in order to run the component.\n\nExample(s)\nsetup:\n  - type: python\n    pip: [ numpy ]\n    git: [ https://some.git.repository/org/repo ]\n    github: [ jkbr/httpie ]\n    gitlab: [ foo/bar ]\n    mercurial: [ http://... ]\n    svn: [ http://...]\n    bazaar: [ http://... ]\n    url: [ http://... ]"
  },
  {
    "objectID": "documentation/reference/config/platforms/dockerPlatform.html#r",
    "href": "documentation/reference/config/platforms/dockerPlatform.html#r",
    "title": "Docker Platform",
    "section": "r",
    "text": "r\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.5.15. Use setup instead.\n\n\nType: RRequirements\nSpecify which R packages should be available in order to run the component.\n\nExample(s)\nsetup: \n  - type: r\n    cran: [ dynutils ]\n    bioc: [ AnnotationDbi ]\n    git: [ https://some.git.repository/org/repo ]\n    github: [ rcannood/SCORPIUS ]\n    gitlab: [ org/package ]\n    svn: [ https://path.to.svn/group/repo ]\n    url: [ https://github.com/hadley/stringr/archive/HEAD.zip ]\n    script: [ 'devtools::install(\".\")' ]"
  },
  {
    "objectID": "documentation/reference/config/platforms/dockerPlatform.html#registry",
    "href": "documentation/reference/config/platforms/dockerPlatform.html#registry",
    "title": "Docker Platform",
    "section": "registry",
    "text": "registry\nType: String\nThe URL to the a custom Docker registry\n\nExample(s)\nregistry: https://my-docker-registry.org"
  },
  {
    "objectID": "documentation/reference/config/platforms/dockerPlatform.html#run_args",
    "href": "documentation/reference/config/platforms/dockerPlatform.html#run_args",
    "title": "Docker Platform",
    "section": "run_args",
    "text": "run_args\nType: String / List of String\nAdd docker run arguments."
  },
  {
    "objectID": "documentation/reference/config/platforms/dockerPlatform.html#setup",
    "href": "documentation/reference/config/platforms/dockerPlatform.html#setup",
    "title": "Docker Platform",
    "section": "setup",
    "text": "setup\nType: List of Requirements\nA list of requirements for installing the following types of packages:\n\napt\napk\nyum\nR\nPython\nJavaScript\nDocker setup instructions\n\nThe order in which these dependencies are specified determines the order in which they will be installed."
  },
  {
    "objectID": "documentation/reference/config/platforms/dockerPlatform.html#tag",
    "href": "documentation/reference/config/platforms/dockerPlatform.html#tag",
    "title": "Docker Platform",
    "section": "tag",
    "text": "tag\nType: Version\nSpecify a Docker image based on its tag.\n\nExample(s)\ntag: 4.0"
  },
  {
    "objectID": "documentation/reference/config/platforms/dockerPlatform.html#target_image",
    "href": "documentation/reference/config/platforms/dockerPlatform.html#target_image",
    "title": "Docker Platform",
    "section": "target_image",
    "text": "target_image\nType: String\nIf anything is specified in the setup section, running the ---setup will result in an image with the name of <target_image>:<version>. If nothing is specified in the setup section, simply image will be used.\n\nExample(s)\ntarget_image: myfoo"
  },
  {
    "objectID": "documentation/reference/config/platforms/dockerPlatform.html#target_image_source",
    "href": "documentation/reference/config/platforms/dockerPlatform.html#target_image_source",
    "title": "Docker Platform",
    "section": "target_image_source",
    "text": "target_image_source\nType: String\nThe source of the target image. This is used for defining labels in the dockerfile.\n\nExample(s)\ntarget_image_source: https://github.com/foo/bar"
  },
  {
    "objectID": "documentation/reference/config/platforms/dockerPlatform.html#target_registry",
    "href": "documentation/reference/config/platforms/dockerPlatform.html#target_registry",
    "title": "Docker Platform",
    "section": "target_registry",
    "text": "target_registry\nType: String\nThe URL where the resulting image will be pushed to.\n\nExample(s)\ntarget_registry: https://my-docker-registry.org"
  },
  {
    "objectID": "documentation/reference/config/platforms/dockerPlatform.html#target_tag",
    "href": "documentation/reference/config/platforms/dockerPlatform.html#target_tag",
    "title": "Docker Platform",
    "section": "target_tag",
    "text": "target_tag\nType: Version\nThe tag the resulting image gets.\n\nExample(s)\ntarget_tag: 0.5.0"
  },
  {
    "objectID": "documentation/reference/config/platforms/dockerPlatform.html#workdir",
    "href": "documentation/reference/config/platforms/dockerPlatform.html#workdir",
    "title": "Docker Platform",
    "section": "workdir",
    "text": "workdir\nType: String\nThe working directory when starting the container. This doesn’t change the Dockerfile but gets added as a command-line argument at runtime.\n\nExample(s)\nworkdir: /home/user"
  },
  {
    "objectID": "documentation/reference/config/platforms/dockerPlatform.html#yum",
    "href": "documentation/reference/config/platforms/dockerPlatform.html#yum",
    "title": "Docker Platform",
    "section": "yum",
    "text": "yum\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.5.15. Use setup instead.\n\n\nType: YumRequirements\nSpecify which yum packages should be available in order to run the component.\n\nExample(s)\nsetup:\n  - type: yum\n    packages: [ sl ]"
  },
  {
    "objectID": "documentation/reference/config/platforms/nextflowLegacyPlatform.html",
    "href": "documentation/reference/config/platforms/nextflowLegacyPlatform.html",
    "title": "Nextflow Legacy Platform",
    "section": "",
    "text": "Run a Viash component as a Nextflow module."
  },
  {
    "objectID": "documentation/reference/config/platforms/nextflowLegacyPlatform.html#id",
    "href": "documentation/reference/config/platforms/nextflowLegacyPlatform.html#id",
    "title": "Nextflow Legacy Platform",
    "section": "id",
    "text": "id\nType: String\nEvery platform can be given a specific id that can later be referred to explicitly when running or building the Viash component."
  },
  {
    "objectID": "documentation/reference/config/platforms/nextflowLegacyPlatform.html#image",
    "href": "documentation/reference/config/platforms/nextflowLegacyPlatform.html#image",
    "title": "Nextflow Legacy Platform",
    "section": "image",
    "text": "image\nType: String\nIf no image attributes are configured, Viash will use the auto-generated image name from the Docker platform:\n[<namespace>/]<name>:<version>\nIt’s possible to specify the container image explicitly with which to run the module in different ways:\nimage: dataintuitive/viash:0.4.0\nExactly the same can be obtained with\nimage: dataintuitive/viash\nregistry: index.docker.io/v1/\ntag: 0.4.0\nSpecifying the attribute(s) like this will use the container dataintuitive/viash:0.4.0 from Docker hub (registry).\nIf no tag is specified Viash will use functionality.version as the tag.\nIf no registry is specified, Viash (and NextFlow) will assume the image is available locally or on Docker Hub. In other words, the registry: ... attribute above is superfluous. No other registry is checked automatically due to a limitation from Docker itself."
  },
  {
    "objectID": "documentation/reference/config/platforms/nextflowLegacyPlatform.html#label",
    "href": "documentation/reference/config/platforms/nextflowLegacyPlatform.html#label",
    "title": "Nextflow Legacy Platform",
    "section": "label",
    "text": "label\nType: String\nWhen running the module in a cluster context and depending on the cluster type, NextFlow allows for attaching labels to the process that can later be used as selectors for associating resources to this process.\nIn order to attach one label to a process/component, one can use the label: ... attribute, multiple labels can be added using labels: [ ..., ... ] and the two can even be mixed.\nIn the main nextflow.config, one can now use this label:\nprocess { … withLabel: bigmem { maxForks = 5 … } }\n\nExample(s)\nlabel: highmem labels: [ highmem, highcpu ]"
  },
  {
    "objectID": "documentation/reference/config/platforms/nextflowLegacyPlatform.html#labels",
    "href": "documentation/reference/config/platforms/nextflowLegacyPlatform.html#labels",
    "title": "Nextflow Legacy Platform",
    "section": "labels",
    "text": "labels\nType: String / List of String\nWhen running the module in a cluster context and depending on the cluster type, NextFlow allows for attaching labels to the process that can later be used as selectors for associating resources to this process.\nIn order to attach one label to a process/component, one can use the label: ... attribute, multiple labels can be added using labels: [ ..., ... ] and the two can even be mixed.\nIn the main nextflow.config, one can now use this label:\nprocess { … withLabel: bigmem { maxForks = 5 … } }\n\nExample(s)\nlabel: highmem labels: [ highmem, highcpu ]"
  },
  {
    "objectID": "documentation/reference/config/platforms/nextflowLegacyPlatform.html#namespace_separator",
    "href": "documentation/reference/config/platforms/nextflowLegacyPlatform.html#namespace_separator",
    "title": "Nextflow Legacy Platform",
    "section": "namespace_separator",
    "text": "namespace_separator\nType: String\nThe default namespace separator is “_“.\n\nExample(s)\nnamespace_separator: \"+\""
  },
  {
    "objectID": "documentation/reference/config/platforms/nextflowLegacyPlatform.html#organization",
    "href": "documentation/reference/config/platforms/nextflowLegacyPlatform.html#organization",
    "title": "Nextflow Legacy Platform",
    "section": "organization",
    "text": "organization\nType: String\nName of a container’s organization.\n\nExample(s)\norganization: viash-io"
  },
  {
    "objectID": "documentation/reference/config/platforms/nextflowLegacyPlatform.html#path",
    "href": "documentation/reference/config/platforms/nextflowLegacyPlatform.html#path",
    "title": "Nextflow Legacy Platform",
    "section": "path",
    "text": "path\nType: String\nWhen publish: true, this attribute defines where the output is written relative to the params.publishDir setting. For example, path: processed in combination with --output s3://some_bucket/ will store the output of this component under\ns3://some_bucket/processed/\nThis attribute gives control over the directory structure of the output. For example:\npath: raw_data\nOr even:\npath: raw_data/bcl\nPlease note that per_id and path can be combined."
  },
  {
    "objectID": "documentation/reference/config/platforms/nextflowLegacyPlatform.html#per_id",
    "href": "documentation/reference/config/platforms/nextflowLegacyPlatform.html#per_id",
    "title": "Nextflow Legacy Platform",
    "section": "per_id",
    "text": "per_id\nType: Boolean\nBy default, a subdirectory is created corresponding to the unique ID that is passed in the triplet. Let us illustrate this with an example. The following code snippet uses the value of --input as an input of a workflow. The input can include a wildcard so that multiple samples can run in parallel. We use the parent directory name (.getParent().baseName) as an identifier for the sample. We pass this as the first entry of the triplet:\nChannel.fromPath(params.input) \\\n    | map{ it -> [ it.getParent().baseName , it ] } \\\n    | map{ it -> [ it[0] , it[1], params ] }\n    | ...\nSay the resulting sample names are SAMPLE1 and SAMPLE2. The next step in the pipeline will be published (at least by default) under:\n<publishDir>/SAMPLE1/\n<publishDir>/SAMPLE2/\nThese per-ID subdirectories can be avoided by setting:\nper_id: false"
  },
  {
    "objectID": "documentation/reference/config/platforms/nextflowLegacyPlatform.html#publish",
    "href": "documentation/reference/config/platforms/nextflowLegacyPlatform.html#publish",
    "title": "Nextflow Legacy Platform",
    "section": "publish",
    "text": "publish\nType: Boolean\nNextFlow uses the autogenerated work dirs to manage process IO under the hood. In order effectively output something one can publish the results a module or step in the pipeline. In order to do this, add publish: true to the config:\n\npublish is optional\nDefault value is false\n\nThis attribute simply defines if output of a component should be published yes or no. The output location has to be provided at pipeline launch by means of the option --publishDir ... or as params.publishDir in nextflow.config:\nparams.publishDir = \"...\""
  },
  {
    "objectID": "documentation/reference/config/platforms/nextflowLegacyPlatform.html#registry",
    "href": "documentation/reference/config/platforms/nextflowLegacyPlatform.html#registry",
    "title": "Nextflow Legacy Platform",
    "section": "registry",
    "text": "registry\nType: String\nThe URL to the a custom Docker registry.\n\nExample(s)\nregistry: https://my-docker-registry.org"
  },
  {
    "objectID": "documentation/reference/config/platforms/nextflowLegacyPlatform.html#separate_multiple_outputs",
    "href": "documentation/reference/config/platforms/nextflowLegacyPlatform.html#separate_multiple_outputs",
    "title": "Nextflow Legacy Platform",
    "section": "separate_multiple_outputs",
    "text": "separate_multiple_outputs\nType: Boolean\nSeparates the outputs generated by a Nextflow component with multiple outputs as separate events on the channel. Default value: true.\n\nExample(s)\nseparate_multiple_outputs: false"
  },
  {
    "objectID": "documentation/reference/config/platforms/nextflowLegacyPlatform.html#stageinmode",
    "href": "documentation/reference/config/platforms/nextflowLegacyPlatform.html#stageinmode",
    "title": "Nextflow Legacy Platform",
    "section": "stageInMode",
    "text": "stageInMode\nType: String\nBy default NextFlow will create a symbolic link to the inputs for a process/module and run the tool at hand using those symbolic links. Some applications do not cope well with this strategy, in that case the files should effectively be copied rather than linked to. This can be achieved by using stageInMode: copy. This attribute is optional, the default is symlink.\n\nExample(s)\nstageInMode: copy"
  },
  {
    "objectID": "documentation/reference/config/platforms/nextflowLegacyPlatform.html#tag",
    "href": "documentation/reference/config/platforms/nextflowLegacyPlatform.html#tag",
    "title": "Nextflow Legacy Platform",
    "section": "tag",
    "text": "tag\nType: Version\nSpecify a Docker image based on its tag.\n\nExample(s)\ntag: 4.0"
  },
  {
    "objectID": "documentation/reference/config/platforms/nativePlatform.html",
    "href": "documentation/reference/config/platforms/nativePlatform.html",
    "title": "Native Platform",
    "section": "",
    "text": "Running a Viash component on a native platform means that the script will be executed in your current environment. Any dependencies are assumed to have been installed by the user, so the native platform is meant for developers (who know what they’re doing) or for simple bash scripts (which have no extra dependencies)."
  },
  {
    "objectID": "documentation/reference/config/platforms/nativePlatform.html#id",
    "href": "documentation/reference/config/platforms/nativePlatform.html#id",
    "title": "Native Platform",
    "section": "id",
    "text": "id\nType: String\nAs with all platforms, you can give a platform a different name. By specifying id: foo, you can target this platform (only) by specifying -p foo in any of the Viash commands.\n\nExample(s)\nid: foo"
  },
  {
    "objectID": "documentation/reference/config/overview.html",
    "href": "documentation/reference/config/overview.html",
    "title": "Viash Config Overview",
    "section": "",
    "text": "A Viash configuration is a YAML file which contains metadata to describe the behaviour and build target(s) of a component.\nWe commonly name this file config.vsh.yaml in our examples, but you can name it however you choose.\nHere’s an example of a config file:\nEvery Viash config consists of two main sections: functionality and platforms."
  },
  {
    "objectID": "documentation/reference/config/overview.html#functionality",
    "href": "documentation/reference/config/overview.html#functionality",
    "title": "Viash Config Overview",
    "section": "Functionality",
    "text": "Functionality\nThe functionality section describes the behaviour of the component. This includes a name, a description and the arguments and resources the component needs to function.\nCheck out our Arguments section on the left to find out more about the supported arguments. The External Resources guide contains information on how to add resources and use them."
  },
  {
    "objectID": "documentation/reference/config/overview.html#platforms",
    "href": "documentation/reference/config/overview.html#platforms",
    "title": "Viash Config Overview",
    "section": "Platforms",
    "text": "Platforms\nThe platforms section specifies what platforms are supported as build targets for a component and their requirements. We support native, docker and nextflow. If no platforms are specified, the native platform is used by default."
  },
  {
    "objectID": "documentation/reference/config/functionality.html",
    "href": "documentation/reference/config/functionality.html",
    "title": "Functionality",
    "section": "",
    "text": "The functionality-part of the config file describes the behaviour of the script in terms of arguments and resources. By specifying a few restrictions (e.g. mandatory arguments) and adding some descriptions, Viash will automatically generate a stylish command-line interface for you."
  },
  {
    "objectID": "documentation/reference/config/functionality.html#add_resources_to_path",
    "href": "documentation/reference/config/functionality.html#add_resources_to_path",
    "title": "Functionality",
    "section": "add_resources_to_path",
    "text": "add_resources_to_path\n\n\n\n\n\n\nWarning\n\n\n\nRemoved since Viash 0.5.11. Extending the PATH turned out to be not desirable.\n\n\nType: Boolean\nAdds the resources directory to the PATH variable when set to true. This is set to false by default."
  },
  {
    "objectID": "documentation/reference/config/functionality.html#argument_groups",
    "href": "documentation/reference/config/functionality.html#argument_groups",
    "title": "Functionality",
    "section": "argument_groups",
    "text": "argument_groups\nType: List of ArgumentGroup\nA grouping of the arguments, used to display the help message.\n\nname: foo, the name of the argument group.\ndescription: Description of foo, a description of the argument group. Multiline descriptions are supported.\narguments: [arg1, arg2, ...], list of the arguments names.\n\n\nExample(s)\n- name: \"Input\"\n  arguments: [ id, input1, input2 ]\n- name: \"Output\"\n  arguments: [ output, optional_output ]\n- name: \"Foo\"\n  description: Arguments related to the foo functionality of this component.\n  arguments: [ foo, bar, zing, bork ]"
  },
  {
    "objectID": "documentation/reference/config/functionality.html#arguments",
    "href": "documentation/reference/config/functionality.html#arguments",
    "title": "Functionality",
    "section": "arguments",
    "text": "arguments\nType: List of Argument\nA list of arguments for this component. For each argument, a type and a name must be specified. Depending on the type of argument, different properties can be set. Common properties for all argument types are the following.\n\ntype: string/file/integer/double/boolean/boolean_true/boolean_false, the type of argument determining to what object type the value will be cast in the downstream scripts.\ndirection: input/output, the directionality of the argument. Only needs to be specified for output files. Default: “input”.\nname: --foo, the name of the argument. Can also be -foo or foo. The number of dashes determines how values can be passed:\n\nwith --foo: long option, e.g. exe --foo=bar or exe --foo bar\nwith -foo: short option, e.g. exe -foo bar\nwith foo: argument, e.g. exe bar\n\nalternatives: [-f], list of alternative names. Typically only used to provide a short alternative option.\ndescription: Description of foo, a description of the argument. Multiline descriptions are supported.\ndefault: bar, the default value when no argument value is provided. Not allowed when required: true.\nrequired: true/false, whether the argument is required. If true and the functionality is executed, an error will be produced if no value is provided. Default = false.\nmultiple: true/false, whether to treat the argument value as an array or not. Arrays can be passed using the delimiter --foo=1:2:3 or by providing the same argument multiple times --foo 1 --foo 2. Default = false.\nmultiple_sep: \":\", the delimiter for providing multiple values. Default = “:”.\nmust_exist: true/false, denotes whether the file or folder should exist at the start of the execution. Only when ‘type’ is ‘file’.\n\nOn types:\n\ntype: string, The value passed through an argument of this type is converted to an ‘str’ object in Python, and to a ‘character’ object in R.\ntype: integer, The resulting value is an ‘int’ in Python and an ‘integer’ in R.\ntype: double, The resulting value is a ‘float’ in Python and an ‘double’ in R.\ntype: boolean, The resulting value is a ‘bool’ in Python and a ‘logical’ in R.\ntype: boolean_true/boolean_false, Arguments of this type can only be used by providing a flag --foo or not. The resulting value is a ‘bool’ in Python and a ‘logical’ in R. These properties cannot be altered: required is false, default is undefined, multiple is false.\ntype: file, The resulting value is still an ‘str’ in Python and a ‘character’ in R. In order to correctly pass files in some platforms (e.g. Docker and Nextflow), Viash needs to know which arguments are input/output files.\n\n\nExample(s)\n- name: --foo\n  type: file\n  alternatives: [-f]\n  description: Description of foo\n  default: \"/foo/bar\"\n  must_exist: true\n  required: false\n  multiple: true\n  multiple_sep: \",\""
  },
  {
    "objectID": "documentation/reference/config/functionality.html#authors",
    "href": "documentation/reference/config/functionality.html#authors",
    "title": "Functionality",
    "section": "authors",
    "text": "authors\nType: List of Author\nA list of authors. An author must at least have a name, but can also have a list of roles, an e-mail address, and a map of custom properties.\nSuggested values for roles are:\n\n\n\n\n\n\n\n\nRole\nAbbrev.\nDescription\n\n\n\n\nmaintainer\nmnt\nfor the maintainer of the code. Ideally, exactly one maintainer is specified.\n\n\nauthor\naut\nfor persons who have made substantial contributions to the software.\n\n\ncontributor\nctb\nfor persons who have made smaller contributions (such as code patches).\n\n\ndatacontributor\ndtc\nfor persons or organisations that contributed data sets for the software\n\n\ncopyrightholder\ncph\nfor all copyright holders. This is a legal concept so should use the legal name of an institution or corporate body.\n\n\nfunder\nfnd\nfor persons or organizations that furnished financial support for the development of the software\n\n\n\nThe full list of roles is extremely comprehensive."
  },
  {
    "objectID": "documentation/reference/config/functionality.html#description",
    "href": "documentation/reference/config/functionality.html#description",
    "title": "Functionality",
    "section": "description",
    "text": "description\nType: String\nA description of the component. This will be displayed with –help.\n\nExample(s)\ndescription: |\n  This component performs function Y and Z.\n  It is possible to make this a multiline string."
  },
  {
    "objectID": "documentation/reference/config/functionality.html#enabled",
    "href": "documentation/reference/config/functionality.html#enabled",
    "title": "Functionality",
    "section": "enabled",
    "text": "enabled\nType: Boolean\nSetting this to false with disable this component when using namespaces."
  },
  {
    "objectID": "documentation/reference/config/functionality.html#info",
    "href": "documentation/reference/config/functionality.html#info",
    "title": "Functionality",
    "section": "info",
    "text": "info\nType: Map of String,String\nA map for storing custom annotation."
  },
  {
    "objectID": "documentation/reference/config/functionality.html#inputs",
    "href": "documentation/reference/config/functionality.html#inputs",
    "title": "Functionality",
    "section": "inputs",
    "text": "inputs\nType: List of Argument"
  },
  {
    "objectID": "documentation/reference/config/functionality.html#name",
    "href": "documentation/reference/config/functionality.html#name",
    "title": "Functionality",
    "section": "name",
    "text": "name\nType: String\nName of the component and the filename of the executable when built with viash build.\n\nExample(s)\nname: exe"
  },
  {
    "objectID": "documentation/reference/config/functionality.html#namespace",
    "href": "documentation/reference/config/functionality.html#namespace",
    "title": "Functionality",
    "section": "namespace",
    "text": "namespace\nType: String\nNamespace this component is a part of. This is required when grouping components together in a pipeline and building multiple components at once using viash ns build.\n\nExample(s)\nnamespace: fancy_components"
  },
  {
    "objectID": "documentation/reference/config/functionality.html#outputs",
    "href": "documentation/reference/config/functionality.html#outputs",
    "title": "Functionality",
    "section": "outputs",
    "text": "outputs\nType: List of Argument"
  },
  {
    "objectID": "documentation/reference/config/functionality.html#resources",
    "href": "documentation/reference/config/functionality.html#resources",
    "title": "Functionality",
    "section": "resources",
    "text": "resources\nType: List of Resource\nThe first resource should be a script (bash_script, r_script, python_script, javascript_script, scala_script) which is what will be executed when the functionality is run. Additional resources will be copied to the same directory.\nCommon properties:\n\ntype: file/r_script/python_script/bash_script/javascript_script/scala_script, the type of resource. The first resource cannot be of type file. When the type is not specified, the default type is simply file. For more information regarding how to write a script in Bash, R or Python with Viash, check out the guides for the respective languages on the left.\nname: filename, the resulting name of the resource.\npath: path/to/file, the path of the input file. Can be a relative or an absolute path, or a URI.\ntext: …multiline text…, the raw content of the input file. Exactly one of path or text must be defined, the other undefined.\nis_executable: true/false, whether the resulting file is made executable.\n\n\nExample(s)\nresources:\n  - type: r_script\n    path: script.R\n  - type: file\n    path: resource1.txt"
  },
  {
    "objectID": "documentation/reference/config/functionality.html#test_resources",
    "href": "documentation/reference/config/functionality.html#test_resources",
    "title": "Functionality",
    "section": "test_resources",
    "text": "test_resources\nType: List of Resource\nOne or more Bash/R/Python scripts to be used to test the component behaviour when viash test is invoked. Additional files of type file will be made available only during testing. Each test script should expect no command-line inputs, be platform-independent, and return an exit code >0 when unexpected behaviour occurs during testing.\n\nExample(s)\ntests:\n  - type: bash_script\n    path: tests/test1.sh\n  - type: r_script\n    path: tests/test2.R\n  - path: resource1.txt"
  },
  {
    "objectID": "documentation/reference/config/functionality.html#tests",
    "href": "documentation/reference/config/functionality.html#tests",
    "title": "Functionality",
    "section": "tests",
    "text": "tests\n\n\n\n\n\n\nWarning\n\n\n\nDeprecated since Viash 0.5.13. Use test_resources instead. No functional difference.\n\n\nType: List of Resource\nOne or more Bash/R/Python scripts to be used to test the component behaviour when viash test is invoked. Additional files of type file will be made available only during testing. Each test script should expect no command-line inputs, be platform-independent, and return an exit code >0 when unexpected behaviour occurs during testing."
  },
  {
    "objectID": "documentation/reference/config/functionality.html#usage",
    "href": "documentation/reference/config/functionality.html#usage",
    "title": "Functionality",
    "section": "usage",
    "text": "usage\nType: String\nA description of the component. This will be displayed with –help under the ‘Usage:’ section."
  },
  {
    "objectID": "documentation/reference/config/functionality.html#version",
    "href": "documentation/reference/config/functionality.html#version",
    "title": "Functionality",
    "section": "version",
    "text": "version\nType: Version\nVersion of the component. This field will be used to version the executable and the Docker container."
  },
  {
    "objectID": "documentation/reference/viash/ns.html",
    "href": "documentation/reference/viash/ns.html",
    "title": "viash ns",
    "section": "",
    "text": "Build a namespace from many viash config files.\nUsage:\nviash ns build [-n nmspc] [-s src] [-t target] [-p docker] [--setup] [---push] [--parallel] [--flatten]\n\n\n\n\n\n\n\n\nArgument\nDescription\nType\n\n\n\n\n--config_mod, -c\nModify a viash config at runtime using a custom DSL. For more information, see the online documentation.\nList[String]\n\n\n--flatten, -f\nFlatten the target builds, handy for building one platform to a bin directory.\nBoolean\n\n\n--parallel, -l\nWhether or not to run the process in parallel.\nBoolean\n\n\n--platform, -p\nActs as a regular expression to filter the platform ids specified in the found config files. If this is not provided, all platforms will be used. If no platforms are defined in a config, the native platform will be used. In addition, the path to a platform yaml file can also be specified.\nString\n\n\n--push\nWhether or not to push the container to a Docker registry [Docker Platform only].\nBoolean\n\n\n--query, -q\nFilter which components get selected by name and namespace. Can be a regex. Example: “^mynamespace/component1$”.\nString\n\n\n--query_name\nFilter which components get selected by name. Can be a regex. Example: “^component1”.\nString\n\n\n--query_namespace, -n\nFilter which namespaces get selected by namespace. Can be a regex. Example: “^mynamespace$”.\nString\n\n\n--setup\nWhich setup strategy for creating the container to use [Docker Platform only].\nString\n\n\n--src, -s\nA source directory containing viash config files, possibly structured in a hierarchical folder structure. Default: src/.\nString\n\n\n--target, -t\nA target directory to build the executables into. Default: target/.\nString\n\n\n--write_meta, -w\nWrite out some meta information to RESOURCES_DIR/viash.yaml at the end.\nBoolean"
  },
  {
    "objectID": "documentation/reference/viash/ns.html#viash-ns-test",
    "href": "documentation/reference/viash/ns.html#viash-ns-test",
    "title": "viash ns",
    "section": "viash ns test",
    "text": "viash ns test\nTest a namespace containing many viash config files.\nUsage:\nviash ns test [-n nmspc] [-s src] [-p docker] [--parallel] [--tsv file.tsv] [--append]\n\n\n\n\n\n\n\n\nArgument\nDescription\nType\n\n\n\n\n--append, -a\nAppend to tsv instead of overwrite\nBoolean\n\n\n--config_mod, -c\nModify a viash config at runtime using a custom DSL. For more information, see the online documentation.\nList[String]\n\n\n--keep, -k\nWhether or not to keep temporary files. By default, files will be deleted if all goes well but remain when an error occurs. By specifying –keep true, the temporary files will always be retained, whereas –keep false will always delete them. The temporary directory can be overwritten by setting defining a VIASH_TEMP directory.\nString\n\n\n--parallel, -l\nWhether or not to run the process in parallel.\nBoolean\n\n\n--platform, -p\nActs as a regular expression to filter the platform ids specified in the found config files. If this is not provided, all platforms will be used. If no platforms are defined in a config, the native platform will be used. In addition, the path to a platform yaml file can also be specified.\nString\n\n\n--query, -q\nFilter which components get selected by name and namespace. Can be a regex. Example: “^mynamespace/component1$”.\nString\n\n\n--query_name\nFilter which components get selected by name. Can be a regex. Example: “^component1”.\nString\n\n\n--query_namespace, -n\nFilter which namespaces get selected by namespace. Can be a regex. Example: “^mynamespace$”.\nString\n\n\n--src, -s\nA source directory containing viash config files, possibly structured in a hierarchical folder structure. Default: src/.\nString\n\n\n--tsv, -t\nPath to write a summary of the test results to.\nString"
  },
  {
    "objectID": "documentation/reference/viash/ns.html#viash-ns-list",
    "href": "documentation/reference/viash/ns.html#viash-ns-list",
    "title": "viash ns",
    "section": "viash ns list",
    "text": "viash ns list\nList a namespace containing many viash config files.\nUsage:\nviash ns list [-n nmspc] [-s src] [-p docker]\n\n\n\n\n\n\n\n\nArgument\nDescription\nType\n\n\n\n\n--config_mod, -c\nModify a viash config at runtime using a custom DSL. For more information, see the online documentation.\nList[String]\n\n\n--format, -f\nWhich output format to use.\nString\n\n\n--parallel, -l\nWhether or not to run the process in parallel.\nBoolean\n\n\n--platform, -p\nActs as a regular expression to filter the platform ids specified in the found config files. If this is not provided, all platforms will be used. If no platforms are defined in a config, the native platform will be used. In addition, the path to a platform yaml file can also be specified.\nString\n\n\n--query, -q\nFilter which components get selected by name and namespace. Can be a regex. Example: “^mynamespace/component1$”.\nString\n\n\n--query_name\nFilter which components get selected by name. Can be a regex. Example: “^component1”.\nString\n\n\n--query_namespace, -n\nFilter which namespaces get selected by namespace. Can be a regex. Example: “^mynamespace$”.\nString\n\n\n--src, -s\nA source directory containing viash config files, possibly structured in a hierarchical folder structure. Default: src/.\nString"
  },
  {
    "objectID": "documentation/reference/viash/run.html",
    "href": "documentation/reference/viash/run.html",
    "title": "viash run",
    "section": "",
    "text": "Usage:\nviash run config.vsh.yaml [-p docker] [-k true/false]  -- [arguments for script]\n\n\n\n\n\n\n\n\nArgument\nDescription\nType\n\n\n\n\n--config\nA viash config file (example: config.vsh.yaml). This argument can also be a script with the config as a header. This is a required argument.\nString\n\n\n--config_mod, -c\nModify a viash config at runtime using a custom DSL. For more information, see the online documentation.\nList[String]\n\n\n--keep, -k\nWhether or not to keep temporary files. By default, files will be deleted if all goes well but remain when an error occurs. By specifying –keep true, the temporary files will always be retained, whereas –keep false will always delete them. The temporary directory can be overwritten by setting defining a VIASH_TEMP directory.\nString\n\n\n--platform, -p\nSpecifies which platform amongst those specified in the config to use. If this is not provided, the first platform will be used. If no platforms are defined in the config, the native platform will be used. In addition, the path to a platform yaml file can also be specified.\nString"
  },
  {
    "objectID": "documentation/reference/viash/config.html",
    "href": "documentation/reference/viash/config.html",
    "title": "viash config",
    "section": "",
    "text": "View the config file after parsing.\nUsage:\nviash config view config.vsh.yaml\n\n\n\n\n\n\n\n\nArgument\nDescription\nType\n\n\n\n\n--config\nA viash config file (example: config.vsh.yaml). This argument can also be a script with the config as a header. This is a required argument.\nString\n\n\n--config_mod, -c\nModify a viash config at runtime using a custom DSL. For more information, see the online documentation.\nList[String]\n\n\n--format, -f\nWhich output format to use.\nString\n\n\n--platform, -p\nSpecifies which platform amongst those specified in the config to use. If this is not provided, the first platform will be used. If no platforms are defined in the config, the native platform will be used. In addition, the path to a platform yaml file can also be specified.\nString"
  },
  {
    "objectID": "documentation/reference/viash/config.html#viash-config-inject",
    "href": "documentation/reference/viash/config.html#viash-config-inject",
    "title": "viash config",
    "section": "viash config inject",
    "text": "viash config inject\nInject a Viash header into the main script of a Viash component.\nUsage:\nviash config inject config.vsh.yaml\n\n\n\n\n\n\n\n\nArgument\nDescription\nType\n\n\n\n\n--config\nA viash config file (example: config.vsh.yaml). This argument can also be a script with the config as a header. This is a required argument.\nString\n\n\n--config_mod, -c\nModify a viash config at runtime using a custom DSL. For more information, see the online documentation.\nList[String]\n\n\n--platform, -p\nSpecifies which platform amongst those specified in the config to use. If this is not provided, the first platform will be used. If no platforms are defined in the config, the native platform will be used. In addition, the path to a platform yaml file can also be specified.\nString"
  },
  {
    "objectID": "documentation/reference/viash/test.html",
    "href": "documentation/reference/viash/test.html",
    "title": "viash test",
    "section": "",
    "text": "Usage:\nviash test config.vsh.yaml [-p docker] [-k true/false]\n\n\n\n\n\n\n\n\nArgument\nDescription\nType\n\n\n\n\n--config\nA viash config file (example: config.vsh.yaml). This argument can also be a script with the config as a header. This is a required argument.\nString\n\n\n--config_mod, -c\nModify a viash config at runtime using a custom DSL. For more information, see the online documentation.\nList[String]\n\n\n--keep, -k\nWhether or not to keep temporary files. By default, files will be deleted if all goes well but remain when an error occurs. By specifying –keep true, the temporary files will always be retained, whereas –keep false will always delete them. The temporary directory can be overwritten by setting defining a VIASH_TEMP directory.\nString\n\n\n--platform, -p\nSpecifies which platform amongst those specified in the config to use. If this is not provided, the first platform will be used. If no platforms are defined in the config, the native platform will be used. In addition, the path to a platform yaml file can also be specified.\nString"
  },
  {
    "objectID": "documentation/reference/viash/build.html",
    "href": "documentation/reference/viash/build.html",
    "title": "viash build",
    "section": "",
    "text": "Usage:\nviash build config.vsh.yaml -o output [-p docker] [-m] [-s]\n\n\n\n\n\n\n\n\nArgument\nDescription\nType\n\n\n\n\n--config\nA viash config file (example: config.vsh.yaml). This argument can also be a script with the config as a header. This is a required argument.\nString\n\n\n--config_mod, -c\nModify a viash config at runtime using a custom DSL. For more information, see the online documentation.\nList[String]\n\n\n--meta, -m\nPrint out some meta information at the end.\nBoolean\n\n\n--output\nPath to directory in which the executable and any resources is built to. Default: “output/”. This is a required argument.\nString\n\n\n--platform, -p\nSpecifies which platform amongst those specified in the config to use. If this is not provided, the first platform will be used. If no platforms are defined in the config, the native platform will be used. In addition, the path to a platform yaml file can also be specified.\nString\n\n\n--push\nWhether or not to push the container to a Docker registry [Docker Platform only].\nBoolean\n\n\n--setup\nWhich setup strategy for creating the container to use [Docker Platform only].\nString\n\n\n--write_meta, -w\nWrite out some meta information to RESOURCES_DIR/viash.yaml at the end.\nBoolean"
  },
  {
    "objectID": "trademark.html",
    "href": "trademark.html",
    "title": "Trademark Policy",
    "section": "",
    "text": "This policy is adapted directly from the WordPress Foundation’s trademark policy for the WordPress and WordCamp names and logos. We admire the job that WordPress has done building a thriving open source community while at the same time making possible a wide variety of WordPress related businesses. We hope that this policy will help us do the same for Quarto."
  },
  {
    "objectID": "trademark.html#goals",
    "href": "trademark.html#goals",
    "title": "Trademark Policy",
    "section": "Goals",
    "text": "Goals\nRStudio, PBC owns and oversees the trademark for the Quarto name and logo. We have developed this trademark usage policy with the following goals in mind:\n\nWe’d like to make it easy for anyone to use the Quarto name or logo for community-oriented efforts that help spread and improve Quarto.\nWe’d like to make it clear how Quarto-related businesses and projects can (and cannot) use the Quarto name and logo.\nWe’d like to make it hard for anyone to use the Quarto name and logo to unfairly profit from, trick or confuse people who are looking for official Quarto resources.\n\nPlease note that it is not the goal of this policy to limit open source or commercial activity around Quarto. We actively encourage Quarto-based open source projects and businesses—our goal with this policy is to prevent confusion about the source of Quarto related software and services."
  },
  {
    "objectID": "trademark.html#permission",
    "href": "trademark.html#permission",
    "title": "Trademark Policy",
    "section": "Permission",
    "text": "Permission\nPermission from RStudio is required to use the Quarto name or logo as part of any project, product, service, domain name, or company name.\nWe will grant permission to use the Quarto name and logo for projects that meet the following criteria:\n\nThe primary purpose of your project is to promote the spread and improvement of the Quarto software.\nYour project is non-commercial in nature (it can make money to cover its costs or contribute to non-profit entities, but it cannot be run as a for-profit project or business).\nYour project neither promotes nor is associated with entities that currently fail to comply with the GPL license under which Quarto is distributed.\n\nIf your project meets these criteria, you will be permitted to use the Quarto name and logo to promote your project in any way you see fit with these exceptions: (1) Please do not use Quarto as part of a domain name; and (2) We do not allow the use of the trademark in advertising, including AdSense/AdWords.\nAll other Quarto-related businesses or projects can use the Quarto name and logo to refer to and explain their services, but they cannot use them as part of a product, project, service, domain name, or company name and they cannot use them in any way that suggests an affiliation with or endorsement by the Quarto open source project.\nThe abbreviation “QMD” is not covered by the Quarto trademark and you are free to use it in any way you see fit."
  },
  {
    "objectID": "trademark.html#examples",
    "href": "trademark.html#examples",
    "title": "Trademark Policy",
    "section": "Examples",
    "text": "Examples\nA consulting company can describe its business as “123 Publishing Services, offering Quarto consulting for publishers,” but cannot call its business “The Quarto Consulting Company.” Similarly, a business related to Quarto extensions can describe itself as “XYZ Extensions, the world’s best Quarto extensions,” but cannot call itself “The Quarto Extension Portal.”\nSimilarly, it’s OK to use the Quarto logo as part of a page that describes your products or services, but it is not OK to use it as part of your company or product logo or branding itself. Under no circumstances is it permitted to use Quarto as part of a domain name or top-level domain name.\nWhen in doubt about your use of the Quarto name or logo, please contact RStudio at permissions@rstudio.com for clarification."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Quarto",
    "section": "",
    "text": "The overarching goal of Quarto is to make the process of creating and collaborating on scientific and technical documents dramatically better. We hope to do this in several dimensions:\n\nCreate a writing and publishing environment with great integrated tools for technical content. We want to make authoring with embedded code, equations, figures, complex diagrams, interactive widgets, citations, cross references, and the myriad other special requirements of scientific discourse straightforward and productive for everyone.\nHelp authors take full advantage of the web as a connected, interactive platform for communications, while still providing the ability to create excellent printed output from the same document source. Researchers shouldn’t need to choose between LaTeX, MS Word, and HTML but rather be able to author documents that target all of them at the same time.\nMake reproducible research and publications the norm rather than the exception. Reproducibility requires that the code and data required to create a manuscript are an integrated part of it. However, this isn’t often straightforward in practice—Quarto aims to make it easier to adopt a reproducible workflow than not.\n\nQuarto is open source software licensed under the GNU GPL v2. We believe that it’s better for everyone if the tools used for research and science are free and open. Reproducibility, widespread sharing of knowledge and techniques, and the leveling of the playing field by eliminating cost barriers are but a few of the shared benefits of free software in science."
  },
  {
    "objectID": "about.html#project",
    "href": "about.html#project",
    "title": "About Quarto",
    "section": "Project",
    "text": "Project\nAt the core of Quarto is Pandoc, a powerful and flexible document processing tool. Quarto adds a number of facilities to Pandoc aimed at scientific and technical publishing, including:\n\nEmbedding code and output from Python, R, and JavaScript via integration with Jupyter, Knitr, and Observable.\nA variety of extensions to Pandoc markdown useful for technical writing including cross-references, sub-figures, layout panels, hoverable citations and footnotes, callouts, and more.\nA project system for rendering groups of documents at once, sharing options across documents, and producing aggregate output like websites and books.\n\nDevelopment of Quarto is sponsored by RStudio, PBC, where we previously created a similar system (R Markdown) that shared the same goals, but was targeted principally at users of the R language. The same core team works on both Quarto and R Markdown:\n\nJ.J. Allaire (@jjallaire)\nChristophe Dervieux (@cderv)\nCarlos Scheidegger (@cscheid)\nCharles Teague (@dragonstyle)\nYihui Xie (@yihui)\n\nWith Quarto, we are hoping to bring these tools to a much wider audience.\nQuarto is a registered trademark of RStudio. Please see our trademark policy for guidelines on usage of the Quarto trademark."
  },
  {
    "objectID": "about.html#contribute",
    "href": "about.html#contribute",
    "title": "About Quarto",
    "section": "Contribute",
    "text": "Contribute\nYou can contribute to Quarto in many ways:\n\nBy opening issues to provide feedback and share ideas.\nBy submitting Pull Request (PR) to fix opened issues\nBy submitting Pull Request (PR) to suggest new features (it is considered good practice to open an issue for discussion before working on a pull request for a new feature).\n\nPlease be mindful of our code of conduct as you interact with other community members.\n\nPull Requests\nPull requests are very welcome! Here’s how to contribute via PR:\n\nFork the repository, clone it locally, and make your changes in a new branch specific to the PR. For example:\n# clone your fork\n$ git clone https://github.com/<username>/quarto-cli\n\n# configure for your platform (./configure-macos.sh, ./configure-linux.sh, or ./configure-windows.cmd)\n$ cd quarto-cli\n$ ./configure-macos.sh\n\n# checkout a new branch\n$ git checkout -b feature/newthing\nFor significant changes (e.g more than small bug fixes), ensure that you have signed the individual or corporate contributor agreement as appropriate. You can send the signed copy to jj@rstudio.com.\nSubmit the pull request. It is ok to submit as draft in your are still working on it but would like some feedback from us. It always good to share in the open that you are working on it.\n\nWe’ll try to be as responsive as possible in reviewing and accepting pull requests."
  },
  {
    "objectID": "license.html",
    "href": "license.html",
    "title": "Open Source License",
    "section": "",
    "text": "The Quarto source code is available at https://github.com/quarto-dev/\nQuarto is a registered trademark of RStudio. Please see our trademark policy for guidelines on usage of the Quarto trademark.\nQuarto also makes use of several other open-source projects, the distribution of which is subject to their respective licenses. Major components and their licenses include:\n\n\n\nProject\nLicense\n\n\n\n\nPandoc\nGNU GPL v2\n\n\nBootstrap 5.0\nMIT\n\n\nBootswatch 5.0\nMIT\n\n\nDeno\nMIT\n\n\nesbuild\nMIT\n\n\nDart Sass\nMIT\n\n\nObservable Runtime\nISC"
  }
]